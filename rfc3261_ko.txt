




네트워크 워킹 그룹 J. 로젠버그
댓글 요청 : 3261 dynamicsoft
소비재 : 2543 H. Schulzrinne
카테고리 : 표준 트랙 Columbia U.
                                                            G. 카마 릴로
                                                                에릭슨
                                                             A. 존스턴
                                                                월드컴
                                                             제이 피터슨
                                                                 Neustar
                                                               R. 스파크
                                                             다이나믹 소프트
                                                              M. Handley
                                                                    ICIR
                                                             E. 스쿨 러
                                                                    AT & T
                                                               2002 년 6 월

                    SIP : 세션 시작 프로토콜

이 메모의 상태

   이 문서는 인터넷 표준 트랙 프로토콜을
   인터넷 커뮤니티, 그리고 토론 및 제안 요청
   개량. "인터넷의 현재 버전"을 참조하십시오.
   표준화 상태에 대한 공식 프로토콜 표준 "(STD 1)
   및이 프로토콜의 상태. 이 메모의 배포는 무제한입니다.

저작권 공지

   Copyright (C) The Internet Society (2002). 판권 소유.

추상

   이 문서는 SIP (Session Initiation Protocol),
   애플리케이션 계층 제어 (시그널링) 프로토콜을 생성,
   수정 및 종료 할 수 있습니다.
   이 세션에는 인터넷 전화, 멀티미디어
   배포 및 멀티미디어 회의.

   세션 생성에 사용되는 SIP 초대장은 세션 설명을 포함합니다.
   참가자는 호환되는 미디어 유형 세트에 동의 할 수 있습니다.
   SIP는 경로 요청을 돕기 위해 프록시 서버라는 요소를 사용합니다.
   사용자의 현재 위치에 대한 사용자 인증 및 승인
   서비스를 제공하고 공급자 라우팅 라우팅 정책을 구현하며
   기능을 사용자에게 제공합니다. SIP는 또한 다음과 같은 등록 기능을 제공합니다.
   사용자가 프록시를 통해 현재 위치를 업로드 할 수있게합니다.
   서버. SIP는 몇 가지 다른 전송 프로토콜 위에 실행됩니다.



Rosenberg, et. al. 표준 트랙 [1 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


목차

   1 소개 ........................................ 8
   2 SIP 기능 개요 ........................... 9
   3 용어 ......................................... 10
   4 작동 개요 ................................. 10
   5 의정서의 구조 ........................... 18
   6 정의 ......................................... 20
   7 SIP 메시지 ........................................ 26
   7.1 요청 .................................... 27
   7.2 응답 ........................................... 28
   7.3 헤더 필드 ....................................... 29
   7.3.1 머리글 필드 형식 ............................... 30
   7.3.2 헤더 필드 분류 ......................... 32
   7.3.3 조밀 한 모양 ........................................ 32
   7.4 시체 .............................................. 33
   7.4.1 메시지 본문 유형 ................................... 33
   7.4.2 메시지 본문 길이 ................................. 33
   7.5 프레이밍 SIP 메시지 ................................ 34
   8 일반 사용자 에이전트 동작 ....................... 34
   8.1 UAC 행동 ........................................ 35
   8.1.1 요청 생성 ........................... 35
   8.1.1.1 Request-URI ........................................ 35
   8.1.1.2 To .............................................. .... 36
   8.1.1.3 시작 .............................................. .. 37
   8.1.1.4 통화 ID ............................................ .37
   8.1.1.5 CSeq .............................................. .. 38
   8.1.1.6 맥스 포워드 ........................................ 38
   8.1.1.7 비아 .............................................. 39
   8.1.1.8 연락처 ........................................... 40
   8.1.1.9 지원 및 요구 사항 .................................. 40
   8.1.1.10 추가 메시지 구성 요소 ....................... 41
   8.1.2 요청 보내기 ................................. 41
   8.1.3 응답 처리 ................................. 42
   8.1.3.1 트랜잭션 계층 오류 ........................... 42
   8.1.3.2 인식 할 수없는 응답 .............................. 42
   8.1.3.3 비아 .............................................. .. 43
   8.1.3.4 3xx 응답 처리 중 .......................................
   8.1.3.5 4xx 응답 처리 ........................... 45
   8.2 UAS 행동 ........................................ 46
   8.2.1 방법 검사 .......................................... 46
   8.2.2 헤더 검사 ........................... 46
   8.2.2.1 To 및 Request-URI .................................. 46
   8.2.2.2 병합 된 요청 ..................................... 47
   8.2.2.3 요구 사항 ............................................. 47
   8.2.3 콘텐츠 처리 ................................. 48
   8.2.4 확장 기능 적용 ................................. 49
   8.2.5 요청 처리 ........................... 49



Rosenberg, et. al. 표준 트랙 [Page 2]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   8.2.6 응답 생성 ........................... 49
   8.2.6.1 잠정 응답 보내기 ..................... 49
   8.2.6.2 헤더 및 태그 .................................... 50
   8.2.7 Stateless UAS Behavior .............................. 50
   8.3 리디렉션 서버 ................................... 51
   9 요청 취소 ................................. 53
   9.1 고객 행동 ..................................... 53
   9.2 서버 동작 ................................... 55
   등록 10 건 ....................................... 56
   10.1 개요 .................................... 56
   10.2 REGISTER 요청 생성 ................... 57
   10.2.1 바인딩 추가 ................................. 59
   10.2.1.1 연락처 주소의 만료 간격 설정 60
   10.2.1.2 연락처 주소 간의 기본 설정
   10.2.2 바인딩 제거 ................................... 61
   10.2.3 바인딩 페치 ................................... 61
   10.2.4 바인딩 새로 고침 ................................. 61
   10.2.5 내부 클럭 설정 ....................... 62
   10.2.6 등록 기관 발견 ........................... 62
   10.2.7 요청 전송 ........................... 62
   10.2.8 오류 응답 ......................................... 63
   10.3 REGISTER 요청 처리 중 ........................ 63
   11 기능 쿼리 ........................... 66
   11.1 OPTIONS 요청 생성 ..................... 67
   11.2 OPTIONS 처리 요청 ....................... 68
   12 대화 상자 ........................................... 69
   12.1 대화 상자 생성 ............................ 70
   12.1.1 UAS 행동 .................................... 70
   12.1.2 UAC 행동 .................................... 71
   12.2 대화 상자 내의 요청 ........................... 72
   12.2.1 UAC 행동 ........................................ 73
   12.2.1.1 요청 생성 ........................... 73
   12.2.1.2 응답 처리 ........................... 75
   12.2.2 UAS 행동 .................................... 76
   12.3 대화 상자의 종료 ............................. 77
   13 세션 시작 ................................ 77
   13.1 개요 .................................... 77
   13.2 UAC 처리 중 .............................. 78
   13.2.1 초기 INVITE 생성 ......................... 78
   13.2.2 INVITE 응답 처리 ......................... 81
   13.2.2.1 1xx 응답 ....................................... 81
   13.2.2.2 3xx 응답 ....................................... 81
   13.2.2.3 4xx, 5xx 및 6xx 응답 .......................... 81
   13.2.2.4 2xx 응답 ....................................... 82
   13.3 UAS 처리 중 ................................. 83
   13.3.1 INVITE 처리 ........................ 83
   13.3.1.1 진행 ........................................... 84
   13.3.1.2 INVITE가 재전송됩니다 ........................... 84



Rosenberg, et. al. 표준 트랙 [3 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   13.3.1.3 INVITE 거부 됨 ................................ 85
   13.3.1.4 INVITE가 수락 됨 ................................ 85
   14 기존 세션 수정 ....................... 86
   14.1 UAC 행동 ........................................ 86
   14.2 UAS 행동 ........................................ 88
   15 세션 종료 ........................... 89
   15.1 BYE 요청으로 세션 종료
   15.1.1 UAC 행동 ........................................ 90
   15.1.2 UAS 행동 ........................................ 91
   16 프록시 행위 ......................................................... 91
   16.1 개요 ........................................... 91
   16.2 상태 보존 프록시 .................................... 92
   16.3 요청 유효성 검사 .................................. 94
   16.4 경로 정보 전처리 ..................... 96
   16.5 요청 대상 결정 ......................... 97
   16.6 요청 전달 ................................. 99
   16.7 응답 처리 ......................... 107
   16.8 타이머 C 처리 .......................... 114
   16.9 전송 오류 처리 ........................... 115
   16.10 취소 처리 ......................................... 115
   16.11 무국적 프록시 ..................................... 116
   16.12 프록시 경로 처리 요약 ................... 118
   16.12.1 예 ........................................... 118
   16.12.1.1 기본 SIP 사다리꼴 ................................. 118
   16.12.1.2 엄격 라우팅 프록시 통과 ................... 120
   16.12.1.3 레코드 - 경로 헤더 필드 값 재 작성 .......... 121
   17 거래 ........................................ 122
   17.1 고객 거래 .................................. 124
   17.1.1 INVITE 클라이언트 트랜잭션 ........................... 125
   17.1.1.1 INVITE 거래 개요 ..................... 125
   17.1.1.2 형식 설명 .................................. 125
   17.1.1.3 ACK 요청의 구성 ..................... 129
   17.1.2 비 INVITE 클라이언트 트랜잭션 ....................... 130
   17.1.2.1 비 INVITE 트랜잭션 개요 .............. 130
   17.1.2.2 공식 서술 .................................. 131
   17.1.3 고객 거래에 대한 응답 대응 ........... 132
   17.1.4 전송 오류 처리 ........................... 133
   17.2 서버 트랜잭션 .................................. 134
   17.2.1 INVITE 서버 트랜잭션 ........................... 134
   17.2.2 비 -INITE 서버 트랜잭션 ....................... 137
   17.2.3 서버 트랜잭션에 대한 요청 일치 ................................. 138
   17.2.4 전송 오류 처리 ........................... 141
   18 운반 ........................................... 141
   18.1 고객 ............................................. 142
   18.1.1 요청 보내기 ................................... 142
   18.1.2 수신 응답 ................................. 144
   18.2 서버 ..................................... 145
   18.2.1 요청 수신 ................................. 145



Rosenberg, et. al. 표준 트랙 [Page 4]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   18.2.2 응답 보내기 ................................... 146
   18.3 프레이밍 ..................................... 147
   18.4 오류 처리 ..................................... 147
   19 공통 메시지 구성 요소 ........................... 147
   19.1 SIP 및 SIPS 통일 자원 표시기 .................. 148
   19.1.1 SIP 및 SIPS URI 구성 요소 ......................... 148
   19.1.2 문자 이스케이프 요구 사항 ..................... 152
   19.1.3 SIP 및 SIPS URI의 예 ........................... 153
   19.1.4 URI 비교 .............................. 153
   19.1.5 URI에서 요청 구성 ......................... 156
   19.1.6 SIP URI와 tel URI 관련 ...................... 157
   19.2 옵션 태그 ......................................... 158
   19.3 태그 ................................................ 159
   20 헤더 필드 ....................................... 159
   20.1 수락 ............................................. 161
   20.2 수락 - 인코딩 ..................................... 163
   20.3 수락 언어 ..................................... 164
   20.4 경고 - 정보 .......................................... 164
   20.5 허용 ........................................... 165
   20.6 인증 정보 ............................. 165
   20.7 승인 ....................................... 165
   20.8 통화 ID ..................................... 166
   20.9 통화 정보 ........................................... 166
   20.10 연락처 ............................................. 167
   20.11 내용 - 처분 ................................. 168
   20.12 콘텐츠 인코딩 .................................... 169
   20.13 콘텐츠 언어 .................................... 169
   20.14 콘텐츠 길이 .............................. 169
   20.15 콘텐츠 유형 ....................................... 170
   20.16 CSeq ................................................ 170
   20.17 날짜 ................................................ 170
   20.18 오류 정보 ......................................... 171
   20.19 만료 ..................................... 171
   20.20 ................................................ 172
   20.21 In-Reply-To ......................................... 172
   20.22 최대 - 전달 .................................... 173
   20.23 최소 만료 ......................................... 173
   20.24 MIME 버전 .................................... 173
   20.25기구 ........................................ 174
   20.26 우선 순위 ........................................... 174
   20.27 프록시 - 인증 ................................. 174
   20.28 프록시 인증 ................................. 175
   20.29 대리인 요구 ....................................... 175
   20.30 기록 루트 ........................................ 175
   20.31 답글 달기 ........................................... 176
   20.32 필요함 ............................................. 176
   20.33 재시도 후 ......................................... 176
   20.34 국도 ............................................... 177



Rosenberg, et. al. 표준 트랙 [5 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   20.35 서버 .............................................. 177
   20.36 제목 ............................................. 177
   20.37 지원 ........................................... 178
   20.38 타임 스탬프 ........................................... 178
   20.39 To ................................................ .. 178
   20.40 지원되지 않음 ......................................... 179
   20.41 사용자 에이전트 .......................................... 179
   20.42 경유 ................................................ 179
   20.43 경고 ........................................... 180
   20.44 WWW- 인증 ................................... 182
   21 응답 코드 ................................. 182
   21.1 임시 1xx ................................... 182
   21.1.1 100 시도하기 .......................................... 183
   21.1.2 180 울림 ......................................... 183
   21.1.3 181 통화 전달 중 ......................... 183
   21.1.4 182 대기열 .......................................... 183
   21.1.5 183 세션 진행 ................................ 183
   21.2 성공 2xx ...................................... 183
   21.2.1 200 OK ............................................. .183
   21.3 리디렉션 3xx ..................................... 184
   21.3.1 300 다중 선택 ................................ 184
   21.3.2 301 영구 이사 ............................... 184
   21.3.3 302 일시적으로 이사 ............................... 184
   21.3.4 305 프록시 사용 ....................................... 185
   21.3.5 380 대체 서비스 ............................. 185
   21.4 요청 실패 4xx ................................. 185
   21.4.1 400 개의 잘못된 요청 ..................................... 185
   21.4.2 401 무단 .................................... 185
   21.4.3 402 지불 필요 ................................ 186
   21.4.4 403 금지됨 ....................................... 186
   21.4.5 404를 찾을 수 없음 ....................................... 186
   21.4.6 405 메소드가 허용되지 않음 .............................. 186
   21.4.7 406 허용되지 않음 .................................. 186
   21.4.8 407 프록시 인증 필요 ............. 186
   21.4.9 408 요청 제한 시간 ................................. 186
   21.4.10 410 사라짐 ........................................... 187
   21.4.11 413 요청 엔터티가 너무 큼 ........................ 187
   21.4.12 414 요청 - URI가 너무 깁니다 ............................ 187
   21.4.13 415 지원되지 않는 미디어 유형 .......................... 187
   21.4.14 416 지원되지 않는 URI 체계 .......................... 187
   21.4.15 420 잘못된 확장 ................................... 187
   21.4.16 421 연장 필수 .................................... 188
   21.4.17 423 간격 너무 짧음 .............................. 188
   21.4.18 480 일시적으로 사용할 수 없음 ......................... 188
   21.4.19 481 통화 / 거래가 존재하지 않습니다 ................. 188
   21.4.20 482 루프 감지 됨 ......................................... 188
   21.4.21 483 너무 많은 홉 수 ................................... 189
   21.4.22 484 주소 불완전 .............................. 189



Rosenberg, et. al. 표준 트랙 [Page 6]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   21.4.23 485 모호한 ....................................... 189
   21.4.24 486 여기에서 바쁘다 ....................................... 189
   21.4.25 487 요청 종료 됨 ........................... 190
   21.4.26 488 허용되지 않음 ........................... 190
   21.4.27 491 요청 대기 중 ............................... 190
   21.4.28 493 해독 할 수 없음 .................................. 190
   21.5 서버 오류 5xx ................................. 190
   21.5.1 500 서버 내부 오류 ........................... 190
   21.5.2 501 구현되지 않음 ................................. 191
   21.5.3 502 불량 게이트웨이 ..................................... 191
   21.5.4 503 서비스를 사용할 수 없음 ............................. 191
   21.5.5 504 서버 시간 초과 ................................. 191
   21.5.6 505 버전 지원 안됨 ........................... 192
   21.5.7 513 너무 큰 메시지 ............................... 192
   21.6 세계적인 실패 6xx ......................... 192
   21.6.1 600 바쁜 곳 ................................. 192
   21.6.2 603 거절 ......................................... 192
   21.6.3 604가 어디에도 존재하지 않습니다 ......................... 192
   21.6.4 606 사용할 수 없음 .................................. 192
   22 HTTP 인증 사용 ........................ 193
   22.1 프레임 워크 ........................................... 193
   22.2 사용자 대 사용자 인증 ......................... 195
   22.3 프록시 대 사용자 인증 ...
   22.4 다이제스트 인증 방식 ................... 199
   23 S / MIME .............................................. 201
   23.1 S / MIME 인증서 ................................. 201
   23.2 S / MIME 키 교환 ................................. 202
   23.3 MIME 본문 확보 ................................... 205
   23.4 S / MIME을 사용하는 SIP 헤더 개인 정보 보호 및 무결성 :
              터널링 SIP ....................................... 207
   23.4.1 SIP의 무결성 및 기밀성
              머리글 ............................................. 207
   23.4.1.1 무결성 ........................................... 207
   23.4.1.2 기밀성 ..................................... 208
   23.4.2 터널링 무결성 및 인증 ........................... 209
   23.4.3 터널링 암호화 ................................... 211
   24 예제 .................................... 213
   24.1 등록 ........................................ 213
   24.2 세션 설정 ................................... 214
   25 SIP 프로토콜에 대한 BNF 증대 ......................................................................................................... 219
   25.1 기본 규칙 ......................................... 219
   26 보안 고려 사항 : 위협 모델 및 보안
              사용 권장 사항 ............................... 232
   26.1 공격 및 위협 모델 ........................... 233
   26.1.1 등록 하이재킹 ........................... 233
   26.1.2 서버 위장 ........................... 234
   26.1.3 메시지 본문 조작 ....................... 235
   26.1.4 세션 해체하기 ............................... 235



Rosenberg, et. al. 표준 트랙 [7 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   26.1.5 서비스 거부 및 증폭 ................. 236
   26.2 보안 메커니즘 ................................. 237
   26.2.1 전송 및 네트워크 계층 보안 ........................ 238
   26.2.2 SIPS URI 스킴 ..................................... 239
   26.2.3 HTTP 인증 ........................... 240
   26.2.4 S / MIME ............................................ .. 240
   26.3 보안 메커니즘 구현 ........................... 241
   26.3.1 SIP 구현 자의 요구 사항 ........................... 241
   26.3.2 보안 솔루션 .................................. 242
   26.3.2.1 등록 ........................................ 242
   26.3.2.2 도메인 간 요청 ................................ 243
   26.3.2.3 피어 투 피어 요청 ............................... 245
   26.3.2.4 DoS 보호 .............................. 246
   26.4 제한 사항 ......................................... 247
   26.4.1 HTTP 다이제스트 ......................................... 247
   26.4.2 S / MIME ............................................ .. 248
   26.4.3 TLS .............................................. ... 249
   26.4.4 SIPS URI ........................................... 249
   26.5 개인 정보 보호 ........................................... 251
   27 IANA 고려 사항 ................................. 252
   27.1 옵션 태그 ......................................... 252
   27.2 경고 코드 ......................................... 252
   27.3 헤더 필드 이름 .................................. 253
   27.4 방법 및 응답 코드 ........................... 253
   27.5 "message / sip"MIME 유형. ....................... 254
   27.6 새로운 내용 - 처리 매개 변수 등록 ..... 255
   RFC 2543의 변경 사항 ........................... 255
   28.1 주요 기능 변화 ........................... 255
   28.2 사소한 기능 변화 ........................... 260
   29 참고 문헌 ................................ 261
   30 참고 문헌 .............................. 262
   타이머 값 표 ............................... 265
   감사 인사 ................................................ 266
   저자 주소 ............................................. 267
   전체 저작권 정책 ....................................... 269

1. 소개

   인터넷을 만들 필요가있는 많은 응용 프로그램이 있습니다.
   세션이 관리되는 세션 관리
   참여자 협회 간의 데이터 교환. 그만큼
   이러한 애플리케이션의 구현은 관례에 따라 복잡합니다.
   참가자 중 : 사용자가 끝점 사이를 이동할 수 있습니다.
   여러 이름으로 주소를 지정할 수 있으며, 여러
   다른 미디어 - 때로는 동시에. 수많은 프로토콜이있다.
   다양한 형태의 실시간 멀티미디어를 전송하는 저작자
   음성, 비디오 또는 문자 메시지와 같은 세션 데이터 세션
   개시 프로토콜 (SIP)은 다음 프로토콜과 함께 작동합니다.



Rosenberg, et. al. 표준 트랙 [8 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   인터넷 종단점 (사용자 에이전트라고 함)이
   다른 사람과 그들이 세션의 특성에 동의하는 것
   공유하고 싶습니다. 예비 세션 참가자를 찾거나
   다른 기능의 경우 SIP를 사용하면
   사용자 에이전트가 보낼 수있는 네트워크 호스트 (프록시 서버라고 함)
   등록, 세션 초대 및 기타 요청. SIP
   수정, 수정하기위한 민첩하고 일반적인 도구
   기본 전송과 독립적으로 작동하는 세션 종료
   프로토콜 및 세션의 유형에 의존하지 않고
   설립.

2 SIP 기능 개요

   SIP는 애플리케이션 계층 제어 프로토콜로서,
   수정, 종료 할 수 있습니다.
   인터넷 전화 통화. SIP는 또한 참가자들을
   멀티 캐스트 회의와 같은 기존 세션. 미디어 캔
   기존 세션에 추가되거나 제거 될 수 있습니다. 한모금
   이름 매핑 및 리디렉션 서비스를 투명하게 지원합니다.
   개인 이동성 지원 [27] - 사용자는 단일
   네트워크 위치에 관계없이 외부에서 볼 수있는 식별자.

   SIP는 멀티미디어 설치 및 종료의 다섯 가지면을 지원합니다.
   연락:

      사용자 위치 : 사용할 최종 시스템 결정
           통신;

      사용자 가용성 : 호출 된 사람의 의사 결정
           통신에 종사하는 당사자;

      사용자 기능 : 미디어 및 미디어 매개 변수 결정
           사용될;

      세션 설정 : "벨소리", 세션 매개 변수 설정
           호출 및 호출 당사자 모두;

      세션 관리 : 전송 및 종료 포함
           세션, 세션 매개 변수 수정 및 호출
           서비스.

   SIP는 수직적으로 통합 된 통신 시스템이 아닙니다. SIP
   오히려 다른 IETF 프로토콜과 함께 사용할 수있는 구성 요소
   완전한 멀티미디어 아키텍처를 구축하십시오. 일반적으로 이들
   아키텍처에는 실시간 전송과 같은 프로토콜이 포함됩니다
   실시간 데이터를 전송하기위한 프로토콜 (RTP) (RFC 1889 [28])
   QoS 피드백, 실시간 스트리밍 프로토콜 (RTSP) (RFC
   2326 [29]), 스트리밍 미디어의 전달을 제어하기위한 미디어



Rosenberg, et. al. 표준 트랙 [Page 9]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   제어를위한 게이트웨이 제어 프로토콜 (MEGACO) (RFC 3015 [30])
   PSTN (Public Switched Telephone Network)에 대한 게이트웨이 및
   설명을위한 세션 설명 프로토콜 (SDP) (RFC 2327 [1])

보내는
   멀티미디어 세션. 따라서 SIP는 함께 사용해야합니다.
   다른 프로토콜을 사용하여
   사용자. 그러나 SIP의 기본 기능과 작동은
   이러한 프로토콜에 의존하지 않아야합니다.

   SIP는 서비스를 제공하지 않습니다. 오히려 SIP는
   다른 서비스를 구현하는 데 사용할 수 있습니다. 예를 들어, SIP는
   사용자를 찾고 불투명 한 객체를 현재 위치로 전달합니다.
   이 프리미티브를 사용하여 작성된 세션 설명을 전달하는 경우
   예를 들어, SDP는 엔드 포인트가
   세션. 동일한 프리미티브를 사용하여
   발신자뿐만 아니라 세션 설명, "발신자 ID"서비스는
   쉽게 구현할 수 있습니다. 이 예제에서 보듯이 하나의 프리미티브는
   일반적으로 여러 가지 다른 서비스를 제공하는 데 사용됩니다.

   SIP는 바닥 제어와 같은 회의 제어 서비스를 제공하지 않습니다.
   또는 투표하고 회의가 어떻게 관리되어야 하는지를 규정하지 않습니다.
   SIP는 다른 회의를 사용하는 세션을 시작하는 데 사용할 수 있습니다.
   제어 프로토콜. SIP 메시지와 그들이 설정 한 세션
   전혀 다른 네트워크를 통과 할 수 있습니다. SIP는 할 수 없으며
   아니, 모든 종류의 네트워크 리소스 예약 기능을 제공합니다.

   제공된 서비스의 본질은 특히 보안을 강화합니다.
   중대한. 이를 위해 SIP는 일련의 보안 서비스를 제공하며,
   여기에는 서비스 거부 방지, 인증 (두 사용자
   사용자 및 사용자에 대한 프록시), 무결성 보호 및 암호화
   개인 정보 보호 서비스.

   SIP는 IPv4와 IPv6 모두에서 작동합니다.

3 용어

   이 문서에서 핵심 단어는 "반드시", "반드시", "필수"
   "~해야한다", "~하지 않는다", "~하지 않는다", "권장하지 않는다", "아니다"
   RECOMMENDED ","MAY "및"OPTIONAL "은 다음과 같이 해석됩니다.
   BCP 14, RFC 2119 [2]에 기술되어 있으며
   호환 SIP 구현.

4 작동 개요

   이 섹션에서는 SIP를 사용하는 기본 작업을 간단하게 소개합니다.
   예. 이 섹션은 본질적으로 자습서이며 포함하지 않습니다.
   모든 규범 적 진술.





Rosenberg, et. al. 표준 트랙 [Page 10]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   첫 번째 예는 SIP의 기본 기능을 보여줍니다.
   종점, 의사 소통의 신호, 세션 협상
   세션을 설정하는 매개 변수 및 세션의 해체
   설립.

   그림 1은 SIP 메시지 교환의 일반적인 예를 보여줍니다.
   두 명의 사용자, Alice와 Bob. (각 메시지는 문자로 표시되어 있습니다.
   "F"및 텍스트 참조 번호).이 예제에서 Alice
   자신의 PC에서 SIP 응용 프로그램 (소프트 폰이라고 함)을 사용하여 전화를 겁니다.
   Bob은 인터넷을 통해 SIP 전화를 사용합니다. 또한 두 개의 SIP 프록시
   앨리스 (Alice)와 밥 (Bob)을 대신하여 세션을 용이하게하는 서버
   설립. 이 전형적인 배열은 종종
   점선의 기하학적 모양으로 나타낸 "SIP 사다리꼴"
   그림 1.

   Alice는 자신의 SIP 신원을 사용하여 Bob에게 "일종의 Uniform Resource"
   SIP URI라는 식별자 (URI)입니다. SIP URI는 섹션에서 정의됩니다.
   19.1. 이메일 주소와 비슷한 형식입니다. 일반적으로
   사용자 이름과 호스트 이름이 들어 있습니다. 이 경우,
   sip : bob@biloxi.com, 여기서 biloxi.com은 Bob의 SIP 도메인입니다.
   서비스 제공 업체. Alice의 SIP URI는 sip : alice@atlanta.com입니다.
   Alice가 Bob의 URI에 입력했거나 하이퍼 링크를 클릭했을 수 있습니다.
   또는 주소록의 항목. SIP는 또한 안전한 URI를 제공하며,
   SIPS URI라고합니다. 예 : bob@biloxi.com. 전화
   SIPS URI에 만들어지면 안전한 암호화 된 전송이 보장됩니다.
   (즉, TLS)은 발신자로부터 수신자로 모든 SIP 메시지를 전달하는 데 사용됩니다
   피 호출자의 도메인. 거기에서 요청이 안전하게 전송됩니다.
   피 호출자는 정책에 의존하는 보안 메커니즘을 사용합니다.
   피 호출자의 도메인.

   SIP는 HTTP와 유사한 요청 / 응답 트랜잭션 모델을 기반으로합니다.
   각 트랜잭션은 특정 요청을 호출하는 요청으로 구성됩니다.
   방법 또는 기능에 대한 응답 및 적어도 하나의 응답. 에서
   이 예제에서는 Alice의 소프트 폰 전송으로 트랜잭션이 시작됩니다.
   Bob의 SIP URI로 주소가 지정된 INVITE 요청 INVITE의 예입니다.
   요청자 (Alice)가 요청한 행동을 지정하는 SIP 방법
   서버 (Bob)가 가져 오기를 원합니다. INVITE 요청에 숫자가 포함되어 있습니다.
   헤더 필드 헤더 필드는
   메시지에 대한 추가 정보. 에있는 것들
   INVITE는 통화의 고유 식별자, 대상을 포함합니다.
   주소, Alice의 주소 및 세션 유형에 대한 정보
   앨리스가 밥과 맺고 자하는 INVITE (메시지 F1
   그림 1)은 다음과 같이 보일 수 있습니다.








Rosenberg, et. al. 표준 트랙 [쪽 11]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


                     atlanta.com. . . biloxi.com
                 . 프록시 프록시.
               . .
       앨리스. . . . . . . . . . . . . . . . . . . . 밥의
      소프트 폰 SIP 전화
         | | | |
         | INVITE F1 | | |
         | ---------------> | 초대 F2 | |
         | 100 F3 시도 | ---------------> | INVITE F4 |
         | <--------------- | 100 시도 F5 | ---------------> |
         | | <-------------- | 180 울림 F6 |
         | | 180 울림 F7 | <--------------- |
         | 180 울림 F8 | <--------------- | 200 OK F9 |
         | <--------------- | 200 OK F10 | <--------------- |
         | 200 OK F11 | <--------------- | |
         | <--------------- | | |
         | ACK F12 |
         | ------------------------------------------------- > |
         | 미디어 세션 |
         | <======================================== > |
         | 바이 F13 |
         | <------------------------------------------------ - |
         | 200 OK F14 |
         | ------------------------------------------------- > |
         | |

         그림 1 : SIP 사다리꼴과 SIP 세션 설정 예

      INVITE SIP : bob@biloxi.com SIP / 2.0
      경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bK776asdhds
      최대 전진 : 70
      To : Bob <sip : bob@biloxi.com>
      보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
      통화 ID : a84b4c76e66710@pc33.atlanta.com
      CSeq : 314159 INVITE
      연락처 : <sip : alice@pc33.atlanta.com>
      콘텐츠 유형 : application / sdp
      콘텐츠 길이 : 142

      (앨리스의 SDP는 표시되지 않음)

   텍스트 인코딩 된 메시지의 첫 번째 줄에는 메서드 이름
   (초대). 다음 행은 헤더 필드 목록입니다. 이
   예제에는 필요한 최소 세트가 들어 있습니다. 헤더 필드는 다음과 같습니다.
   아래에서 간단히 설명합니다.






Rosenberg, et. al. 표준 트랙 [12 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   비아에는 앨리스가있는 주소 (pc33.atlanta.com)가 들어 있습니다.
   이 요청에 대한 응답을받을 것으로 기대합니다. 또한
   이 트랜잭션을 식별하는 분기 매개 변수

   To 표시 이름 (Bob) 및 SIP 또는 SIPS URI 포함
   (한 모금 : bob@biloxi.com) 요청을 원래 향해
   감독. 표시 이름은 RFC 2822 [3]에 설명되어 있습니다.

   From은 표시 이름 (Alice)과 SIP 또는 SIPS URI도 포함합니다.
   (sip : alice@atlanta.com) 요청의 발신자를 나타냅니다.
   이 헤더 필드에는 임의의 문자열을 포함하는 태그 매개 변수도 있습니다.
   (1928301774)는 소프트 폰에 의해 URI에 추가되었습니다. 그것은 사용된다.
   식별 목적으로.

   Call-ID에는이 호출에 대한 전역 고유 식별자가 포함되어 있습니다.
   임의의 문자열과 소프트 폰의 조합으로 생성됩니다.
   호스트 이름 또는 IP 주소. To 태그, From 태그,
   및 Call-ID는 피어 - 투 - 피어 SIP 관계를 완전히 정의합니다
   Alice와 Bob 사이의 대화 상자이며 대화 상자라고합니다.

   CSeq 또는 명령 시퀀스에는 정수와 메서드 이름이 포함됩니다. 그만큼
   대화 내에서 새로운 요청마다 CSeq 번호가 증가하고
   전통적인 시퀀스 번호입니다.

   연락처에는 직접 경로를 나타내는 SIP 또는 SIPS URI가 포함됩니다.
   Alice에 연락하십시오. 일반적으로 정규화 된 사용자 이름으로 구성됩니다.
   도메인 이름 (FQDN). FQDN이 선호되는 반면 많은 최종 시스템에서는
   등록 된 도메인 이름이 없으므로 IP 주소가 허용됩니다.
   Via 헤더 필드는 다른 요소들에게
   응답에서 Contact 헤더 필드는 다른 요소에게 보낼 곳을 알려줍니다
   미래의 요청.

   Max-Forwards는 요청을 할 수있는 홉 수를 제한하는 역할을합니다.
   목적지로가는 길. 그것은 다음과 같은 정수로 구성됩니다.
   각 홉에서 1 씩 감소합니다.

   Content-Type은 메시지 본문에 대한 설명을 포함합니다 (표시되지 않음).

   Content-Length는 메시지 본문의 옥텟 (바이트) 카운트를 포함합니다.

   SIP 헤더 필드의 완전한 집합은 20 절에 정의되어있다.

   세션의 세부 정보 (예 : 미디어 유형, 코덱 또는
   샘플링 속도는 SIP를 사용하여 설명되지 않습니다. 오히려
   SIP 메시지는 세션에 대한 설명을 포함하며 일부는
   다른 프로토콜 형식. 그러한 형식 중 하나는 세션 설명입니다
   프로토콜 (SDP) (RFC 2327 [1]). 이 SDP 메시지 (




Rosenberg, et. al. 표준 트랙 [페이지 13]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   예)는 SIP 메시지와 유사한 방식으로 SIP 메시지에 의해 전달됩니다
   전자 메일 메시지 또는 웹에 의해 운반되는 문서 첨부
   페이지가 HTTP 메시지로 전달됩니다.

   소프트 폰은 Bob 또는 SIP의 위치를 ​​알지 못하기 때문에
   서버가 biloxi.com 도메인에 있으면 소프트 폰이 INVITE를
   Alice의 도메인 인 atlanta.com에 서비스를 제공하는 SIP 서버. 주소
   atlanta.com SIP 서버의 구성은 Alice 's
   예를 들어, DHCP에 의해 발견되었을 수도 있습니다.

   atlanta.com SIP 서버는 프록시라고 알려진 SIP 서버 유형입니다.
   섬기는 사람. 프록시 서버가 SIP 요청을 수신하여 전달합니다.
   요청자를 대신하여. 이 예에서 프록시 서버는
   INVITE 요청을 수신하고 100 (Trying) 응답을 Alice 's에 다시 보냅니다.
   소프트 폰. 100 (Trying) 응답은 INVITE에
   프록시가 그녀를 대신하여 경로를 지정하기 위해 작동하고 있음
   목적지에 대한 INVITE. SIP의 응답은 3 자리 숫자를 사용합니다.
   코드 뒤에는 설명적인 문구가옵니다. 이 응답에는
   via To, From, Call-ID, CSeq 및 branch 매개 변수는
   INVITE : 앨리스의 소프트 폰이이 응답을
   보낸 INVITE. atlanta.com 프록시 서버가 프록시를 찾습니다.
   가능하면 특정 유형의 DNS를 수행하여 biloxi.com의 서버
   (도메인 이름 서비스) 조회를 통해 해당 SIP 서버를 찾습니다.
   biloxi.com 도메인. 이것은 [4]에 설명되어 있습니다. 결과적으로,
   biloxi.com 프록시 서버의 IP 주소를 얻고 전달합니다.
   또는 프록시에서 INVITE 요청을 보냅니다. 요청을 전달하기 전에,
   atlanta.com 프록시 서버가 추가 Via 헤더 필드를 추가합니다.
   자체 주소가 포함 된 값 (이미 INVITE에
   첫 번째 비아에있는 앨리스의 주소). biloxi.com 프록시 서버
   INVITE를 수신하고 100 (Trying) 응답으로 응답합니다.
   atlanta.com 프록시 서버가 프록시 서버를 수신했음을 나타냅니다.
   INVITE이며 요청을 처리 중입니다. 프록시 서버가
   데이터베이스 (일반적으로 위치 서비스라고 함)
   Bob의 현재 IP 주소. (다음 섹션에서 우리는 어떻게 볼 것인가?
   이 데이터베이스는 채워질 수 있습니다.) biloxi.com 프록시 서버는
   INVITE에 대한 자신의 주소를 가진 또 다른 Via 헤더 필드 값과
   그것을 Bob의 SIP 전화로 프록시합니다.

   Bob의 SIP 전화는 INVITE를 수신하고 Bob에게 들어오는 것에 경고합니다.
   앨리스로부터 전화해서 밥이 전화에 응답할지 여부를 결정할 수 있도록합니다.
   즉, Bob의 전화벨이 울립니다. Bob의 SIP 전화가 180
   (Ringing) 응답은 두 개의 프록시를 통해 다시 라우팅됩니다.
   반대 방향. 각 프록시는 Via 헤더 필드를 사용하여
   응답을 보낼 위치를 결정하고 자신의 주소를 제거합니다.
   상단. 결과적으로 DNS 및 위치 서비스 조회가
   초기 INVITE를 라우팅하는 데 필요한 경우 180 (Ringing) 응답은
   조회없이 또는 상태가없는 호출자에게 반환 될 수있다.




Rosenberg, et. al. 표준 트랙 [14 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   프록시에서 유지 관리됩니다. 이것은 또한 바람직한 속성을 가지고 있습니다.
   INVITE를 보는 각 프록시는
   초대.

   Alice의 Softphone이 180 (Ringing) 응답을 받으면 통과합니다.
   이 정보는 앨리스에게, 아마 오디오 링백 톤이나
   앨리스의 화면에 메시지를 표시합니다.

   이 예에서 Bob은 통화에 응답하기로 결정합니다. 그가 올 때
   핸드셋에서 SIP 전화가 200 (OK) 응답을 보내면
   전화가 응답되었습니다. 200 (OK)에는 메시지 본문이 들어 있습니다.
   Bob의 세션 유형에 대한 SDP 미디어 설명
   앨리스와 함께 기꺼이 결과적으로, 2 상
   SDP 메시지 교환 : Alice가 Bob을 Bob에게 보내고 Bob이 하나를 보냈습니다.
   앨리스에게. 이 2 단계 교환은 기본 협상을 제공합니다.
   SDP의 간단한 제안 / 응답 모델을 기반으로합니다
   교환. Bob이 전화에 응답하고 싶지 않거나 통화 중일 경우
   다른 호출에서 오류 응답이 대신 전송되었습니다.
   200 (OK), 미디어 세션이 없습니다.
   설립. SIP 응답 코드의 전체 목록은 섹션에 있습니다.
   21. 200 (OK) (그림 1의 메시지 F9)은 다음과 같이 보일 수 있습니다.
   밥 (Bob)이 그것을 발송합니다.

      SIP / 2.0 200 OK
      경유 : SIP / 2.0 / UDP server10.biloxi.com
         ; 지점 = z9hG4bKnashds8; 수신 = 192.0.2.3
      경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com
         ; 지점 = z9hG4bK77ef4c2312983.1; 수신 = 192.0.2.2
      경유 : SIP / 2.0 / UDP pc33.atlanta.com
         ; 지점 = z9hG4bK776asdhds; 수신 = 192.0.2.1
      받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
      보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
      통화 ID : a84b4c76e66710@pc33.atlanta.com
      CSeq : 314159 INVITE
      연락처 : <sip : bob@192.0.2.4>
      콘텐츠 유형 : application / sdp
      콘텐츠 길이 : 131

      (Bob의 SDP는 표시되지 않음)

   응답의 첫 번째 줄에는 응답 코드 (200)와
   이유 구문 (OK). 나머지 행은 머리글 필드를 포함합니다.
   Via, To, From, Call-ID 및 CSeq 헤더 필드는에서 복사됩니다.
   INVITE 요청 (세 개의 Via 헤더 필드 값 - 하나
   Alice의 SIP 전화에 의해 추가 된 것, atlanta.com 프록시에 의해 추가 된 것, 그리고
   하나는 biloxi.com 프록시가 추가했습니다.) Bob의 SIP 전화에 태그가 추가되었습니다.
   매개 변수를 To 헤더 필드에 추가합니다. 이 태그는
   대화 상자에 양쪽 끝점이 포함되며 모든 미래에 포함됩니다.



Rosenberg, et. al. 표준 트랙 [15 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   요청 및 응답. 연락처 헤더 필드
   Bob이 SIP 전화에서 직접 도달 할 수있는 URI를 포함합니다.
   Content-Type과 Content-Length는 메시지 본문을 참조합니다 (
   표시)에 Bob의 SDP 미디어 정보가 들어 있습니다.

   여기에 표시된 DNS 및 위치 서비스 조회 외에도
   예를 들어, 프록시 서버는 "라우팅 결정"을 유연하게 수행 할 수 있습니다.
   요청을 보낼 위치를 결정하십시오. 예를 들어 Bob의 SIP 전화
   486 (Busy Here) 응답 인 biloxi.com 프록시 서버를 반환했습니다.
   Bob의 음성 메일 서버에 INVITE를 프록시 할 수 있습니다. 프록시 서버는
   동시에 여러 위치에 INVITE를 보냅니다. 이
   병렬 검색 유형은 포크 (forking)로 알려져 있습니다.

   이 경우 200 (OK)은 두 개의 프록시를 통해 다시 라우팅되고
   앨리스의 소프트 폰에서 수신 한 다음 링 백톤을 중지합니다
   통화가 응답되었음을 나타냅니다. 마지막으로, Alice 's
   소프트 폰이 Bob의 SIP 전화기에 확인 응답 메시지 (ACK)를 보냅니다.
   최종 응답 (200 (OK))의 수신을 확인합니다. 이
   예를 들어, ACK는 Alice의 소프트 폰에서 Bob의 SIP로 직접 전송됩니다
   두 프록시를 건너 뛰고 있습니다. 이는 엔드 포인트
   Contact 헤더 필드에서 서로의 주소를 배웠습니다.
   INVITE / 200 (OK) 교환을 통해
   초기 INVITE가 전송되었습니다. 두 프록시에 의해 수행 된 조회
   더 이상 필요하지 않으므로 프록시가 통화 흐름에서 빠져 나옵니다. 이
   수립하는 데 사용 된 INVITE / 200 / ACK 세 방향 핸드 셰이크를 완료합니다.
   SIP 세션. 세션 설정에 대한 자세한 내용은 섹션 13에 나와 있습니다.

   Alice와 Bob의 미디어 세션이 이제 시작되었고, 미디어를 보냅니다.
   패킷을 SDP 교환에 동의 한 형식으로 전송합니다.
   일반적으로 엔드 - 투 - 엔드 미디어 패킷은
   SIP 신호 메시지

   세션 중에 앨리스 (Alice) 또는 밥 (Bob)이
   미디어 세션의 특성. 이것은
   새로운 미디어 디스크립션을 포함하는 re-INVITE를 전송한다. 다시 -
   INVITE는 기존 대화 상자를 참조하여 상대방이 알 수 있도록합니다.
   기존 세션을 수정하는 것이 아니라
   새로운 세션. 상대방은 변경 사항을 승인하기 위해 200 (OK)을 보냅니다.
   요청자는 200 (OK)에 ACK로 응답합니다. 다른 쪽
   파티가 변경 사항을 수락하지 않으면 다음과 같은 오류 응답을 보냅니다.
   488 (여기서 허용되지 않음)이며 ACK도 수신합니다. 그러나
   re-INVITE의 실패로 인해 기존 호출이 실패하지 않습니다.
   세션은 이전에 협상 된
   형질. 세션 수정에 대한 자세한 내용은 섹션에 있습니다.
   14.






Rosenberg, et. al. 표준 트랙 [Page 16]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   통화가 끝나면 Bob은 먼저 연결을 끊고 (끊습니다)
   BYE 메시지를 생성합니다. 이 BYE는 Alice 's
   소프트 폰, 다시 프록시를 우회합니다. 앨리스가 영수증을 확인합니다.
   세션을 종료하는 200 (OK) 응답의 BYE 및
   BYE 트랜잭션. ACK가 전송되지 않습니다 - ACK는 다음 형식으로 만 전송됩니다.
   INVITE 요청에 대한 응답. 이 이유
   INVITE에 대한 특별 처리는 나중에 논의되지만 관련 내용은
   SIP의 신뢰성 메커니즘, 시간이 소요될 수있는 기간
   대답 할 수있는 전화, 포크. 이러한 이유로,
   SIP에서의 요청 처리는 종종 INVITE 또는 non-
   INVITE 이외에 다른 모든 메소드를 참조하는 INVITE. 전체 세부 정보
   세션 종료에 관한 내용은 15 항에 있습니다.

   24.2 절은 그림 1에 표시된 메시지를 전체적으로 설명합니다.

   경우에 따라 SIP 신호 경로의 프록시에 유용 할 수 있습니다.
   지속 기간 동안 엔드 포인트 간의 모든 메시징을 볼 수 있습니다.
   세션. 예를 들어, biloxi.com 프록시 서버가
   초기 INVITE를 넘어 SIP 메시징 경로에 남아 있으면
   INVITE에 필요한 라우팅 헤더 필드를 Record-
   호스트 이름 또는 IP 주소로 해석되는 URI가 포함 된 경로
   프록시. 이 정보는 Bob의 SIP
   전화 및 (Record-Route 헤더 필드가 다시 전달되기 때문에
   200 (OK)) Alice의 소프트 폰으로
   대화. 그러면 biloxi.com 프록시 서버는
   ACK, BYE 및 BYE에 대한 200 (OK). 각 프록시는 독립적으로 수행 할 수 있습니다.
   후속 메시지를 수신하기로 결정하면 해당 메시지가 전달됩니다.
   그것을 받기로 선택한 모든 프록시를 통해 이 기능은 다음과 같습니다.
   중간 통화 기능을 제공하는 프록시에 자주 사용됩니다.

   등록은 SIP의 또 다른 공통 작업입니다. 등록은 하나입니다.
   biloxi.com 서버가 Bob의 현재 위치를 알 수 있습니다.
   초기화시 및 주기적 간격으로 Bob의 SIP 전화는
   SIP로 알려진 biloxi.com 도메인의 서버에 메시지 등록
   기록 사무관. REGISTER 메시지는 Bob의 SIP 또는 SIPS URI를 연결합니다.
   (sip : bob@biloxi.com)와 그가 현재있는 머신
   (Contact 헤더 필드에 SIP 또는 SIPS URI로 전달됨).
   레지스트라는 바인딩이라고도하는이 연결을
   위치 서비스라고하는 데이터베이스로, 위치 서비스에서 사용할 수 있습니다.
   프록시는 biloxi.com 도메인에 있습니다. 종종 등록 기관 서버는
   도메인은 해당 도메인의 프록시와 함께 배치됩니다. 이것은
   SIP 서버의 유형을 구분하는 중요한 개념
   물리적 인 것이 아니라 논리적입니다.

   Bob은 단일 장치에서 등록하는 것에만 국한되지 않습니다. 예를 들어,
   집에있는 SIP 전화와 사무실에있는 SIP 전화 모두 보낼 수 있습니다.
   등록. 이 정보는 위치에 함께 저장됩니다.




Rosenberg, et. al. 표준 트랙 [17 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   서비스를 허용하고 프록시가 다양한 유형의 검색을 수행 할 수있게합니다.
   Bob을 찾습니다. 마찬가지로 한 명 이상의 사용자가
   동시에 하나의 장치.

   위치 서비스는 단지 추상적 인 개념 일뿐입니다. 일반적으로
   프록시가 URI를 입력하고
   프록시에게 보낼 URL을 지정하는 0 개 이상의 URI 집합
   의뢰. 등록은이 정보를 만드는 한 가지 방법이지만
   유일한 방법은 아닙니다. 임의의 매핑 기능을에서 구성 할 수 있습니다.
   관리자의 재량.

   마지막으로, SIP에서는 등록이 사용된다는 점에 유의해야합니다.
   들어오는 SIP 요청을 라우팅하는 데 사용되며 권한 부여에 아무런 역할도하지 않습니다.
   나가는 요청. 인증 및 인증은
   요청 / 요청별로 챌린지 / 응답으로 SIP
   메커니즘을 사용하거나 섹션에서 설명한대로 하위 계층 구조를 사용하여
   26.

   이 등록 예제의 전체 SIP 메시지 세부 정보
   24.1 절에있다.

   기능에 대한 쿼리와 같은 SIP의 추가 작업
   OPTIONS를 사용하여 SIP 서버 또는 클라이언트를 종료하거나 보류중인 것을 취소
   CANCEL을 사용한 요청은 이후 섹션에서 소개됩니다.

5 프로토콜의 구조

   SIP는 계층화 된 프로토콜로 구성됩니다.
   행동은 상당히 독립적 인 집합으로 설명됩니다
   각 단계 사이의 느슨한 커플 링만으로 처리 단계를 처리 할 수 ​​있습니다. 그만큼
   프로토콜 동작은 다음과 같은 목적으로 레이어로 설명됩니다.
   프리젠 테이션을 통해 공통 기능에 대한 설명을 허용
   요소를 하나의 섹션에 포함합니다. 구현을 지시하지는 않습니다.
   어떠한 방식으로. 요소가 레이어를 "포함"한다고 말하면,
   해당 계층에 의해 정의 된 규칙 집합을 준수합니다.

   프로토콜에 지정된 모든 요소가 모든 계층을 포함하는 것은 아닙니다.
   또한 SIP에 지정된 요소는 논리적 요소이며
   육체적 인 것들. 육체적 실현은 다른 것으로 행동 할 것을 선택할 수 있습니다.
   논리적 구성 요소를 포함 할 수 있습니다.

   SIP의 가장 낮은 계층은 구문과 인코딩입니다. 인코딩은
   증강 된 Backus-Naur Form 문법 (BNF)을 사용하여 지정됩니다. 그만큼
   완전한 BNF는 섹션 25에 명시되어있다; SIP 개요
   메시지의 구조는 섹션 7에서 찾을 수 있습니다.






Rosenberg, et. al. 표준 트랙 [Page 18]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   두 번째 계층은 전송 계층입니다. 클라이언트 정의 방법을 정의합니다.
   요청을 보내고 응답을받으며 서버가받는 방법
   요청하고 네트워크를 통해 응답을 보냅니다. 모든 SIP 요소
   전송 계층을 포함합니다. 전송 계층은
   섹션 18.

   세 번째 계층은 트랜잭션 계층입니다. 거래는
   SIP의 기본 구성 요소. 트랜잭션은 a가 보낸 요청입니다.
   클라이언트 트랜잭션 (전송 계층 사용)을 서버로 전송
   거래와 함께 보낸 요청에 대한 모든 응답과 함께
   서버 트랜잭션을 클라이언트에 다시 보냅니다. 트랜잭션 계층 핸들
   응용 프로그램 계층 재전송, 요청에 대한 응답 일치,
   및 응용 프로그램 계층 시간 초과. 사용자 에이전트 클라이언트가 수행하는 모든 작업
   (UAC) 수행은 일련의 트랜잭션을 사용하여 수행됩니다.
   거래에 대한 논의는 섹션 17에 나와 있습니다. 사용자 에이전트
   상태 층 프록시와 마찬가지로 트랜잭션 계층을 포함합니다. 무국적자
   프록시는 트랜잭션 계층을 포함하지 않습니다. 트랜잭션 계층
   클라이언트 구성 요소 (클라이언트 트랜잭션이라고 함)와
   서버 구성 요소 (서버 트랜잭션이라고 함)
   유한 상태 기계로 표현된다.
   특정 요청을 처리합니다.

   트랜잭션 계층 위의 계층을 트랜잭션 사용자라고합니다.
   (TU). 무 상태 프록시를 제외한 각각의 SIP 엔터티는
   거래 사용자. TU가 요청을 보내려고하면,
   클라이언트 트랜잭션 인스턴스와 함께 요청을 전달합니다.
   목적지 IP 주소, 포트 및 전송할 전송
   의뢰. 클라이언트 트랜잭션을 생성하는 TU는이를 취소 할 수도 있습니다.
   클라이언트가 트랜잭션을 취소하면 서버가 중지되도록 요청합니다
   추가 처리, 이전에 존재했던 상태로 복귀
   트랜잭션이 시작되고 다음에 대한 특정 오류 응답이 생성됩니다.
   그 거래. 이것은 CANCEL 요청으로 수행됩니다.
   자체 거래를 구성하지만 거래가
   취소됨 (섹션 9).

   SIP 요소, 즉 사용자 에이전트 클라이언트 및 서버, 상태 비 저장
   및 상태 저장 프록시 및 등록 기관은
   서로를 구별합니다. 코어, 무국적자 제외
   프록시는 트랜잭션 사용자입니다. UAC 및 UAS의 동작
   코어는 방법에 따라 다르지만 모두에게 공통된 규칙이 있습니다.
   방법 (섹션 8). UAC의 경우 이러한 규칙이 구성을 제어합니다.
   요청의; UAS의 경우 요청 처리를 관리하며
   응답을 생성합니다. 등록은 중요한 역할을하기 때문에
   SIP, REGISTER를 처리하는 UAS에는 특별한 이름이 부여됩니다.
   기록 사무관. 섹션 10에서는 UAC 및 UAS 코어 동작에 대해 설명합니다.
   REGISTER 메서드. 섹션 11에서는 UAC 및 UAS의 핵심 동작에 대해 설명합니다.
   UA의 기능을 결정하는 데 사용되는 OPTIONS 메서드




Rosenberg, et. al. 표준 트랙 [19 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   특정 다른 요청이 대화 상자 내에서 전송됩니다. 대화 상자는
   지속되는 두 사용자 에이전트 간의 피어 - 투 - 피어 SIP 관계
   몇 시간 동안. 이 대화 상자는 메시지의 순서를
   사용자 에이전트 간의 요청 라우팅. 초대장
   방법은이 규격에서 정의 된 유일한 방법이다.
   대화. UAC가 a의 컨텍스트 내에있는 요청을 보낼 때
   대화 상자에서는 8 장에서 논의 된 일반적인 UAC 규칙을 따르지만
   또한 중간 대화 요청에 대한 규칙. 섹션 12에서는 대화 상자에 대해 설명합니다.
   건설 및 유지 보수 절차를 제시하고,
   대화 상자 내의 요청 구성에 추가됩니다.

   SIP에서 가장 중요한 메소드는 INVITE 메소드로,
   참가자들간에 세션을 수립 할 수 있습니다. 세션은
   참가자들의 모임, 그들 사이의 미디어 흐름
   의사 소통의 목적. 섹션 13에서는 세션이
   하나 이상의 SIP 대화 상자가 나타납니다. 섹션 14
   해당 세션의 특성이
   대화 상자 내에서 INVITE 요청 사용. 마지막으로, 15 조
   세션이 종료되는 방법을 설명합니다.

   섹션 8, 10, 11, 12, 13, 14 및 15의 절차는
   전적으로 UA 코어 (섹션 9에서는 취소를 설명합니다.
   UA 코어와 프록시 코어 모두에 적용됨). 섹션 16에서는
   프록시 요소는 사용자 간 메시지 라우팅을 용이하게합니다.
   자치령 대표.

6 정의

   다음 용어는 SIP에 특별한 의미가 있습니다.

      주소 기록 : AOR (address-of-record)은 SIP 또는 SIPS URI입니다
         지도 할 수있는 위치 서비스가있는 도메인을 가리 킵니다.
         사용자가 사용 가능한 다른 URI에 대한 URI.
         일반적으로 위치 서비스는
         등록. AOR은 종종 "대중"으로 간주됩니다
         주소 ".

      Back-to-Back 사용자 에이전트 : B2BUA (back-to-back user agent)는
         요청을 수신하여 요청을 처리하는 논리적 개체
         사용자 에이전트 서버 (UAS). 요청 방법을 결정하기 위해
         답변을 받아야하는 경우 사용자 에이전트 클라이언트 (UAC) 및
         요청을 생성합니다. 프록시 서버와는 달리,
         주 대화 상자에서 전송 된 모든 요청에 ​​참여해야합니다.
         그것은 확립했다. 그것은 UAC와
         UAS에서는 명시 적 정의가 필요하지 않습니다.






Rosenberg, et. al. 표준 트랙 [쪽 20]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      호출 : 호출은 비공식적 인 용어로 일부 통신을 나타냅니다.
         동료 간, 일반적으로
         멀티미디어 대화.

      Call Leg : 다이얼로그의 다른 이름 [31]; 더 이상이 용도에 사용되지 않음
         사양.

      상태 저장 호출 : 상태에 대한 상태를 유지하면 프록시는 상태 저장 호출을 호출합니다.
         초대 INVITE에서 종료 BYE 로의 대화
         의뢰. 통화 상태 저장 프록시는 항상 트랜잭션 상태 저장이며,
         그러나 그 반대는 반드시 사실이 아니다.

      클라이언트 : 클라이언트는 SIP 요청을 보내는 네트워크 요소입니다.
         수신하다


SIP 응답. 클라이언트는 상호 작용할 수도 있고 그렇지 않을 수도 있습니다.
         인간 사용자와 직접. 사용자 에이전트 클라이언트 및 프록시는 다음과 같습니다.
         고객.

      회의 : 다음을 포함하는 멀티미디어 세션 (아래 참조) :
         여러 참가자.

      코어 : 코어는 특정 유형에 특정한 기능을 지정합니다
         SIP 엔티티의, 즉, 상태 유지 또는 상태 비 저장
         프록시, 사용자 에이전트 또는 등록 기관. 모든 코어
         stateless proxy는 트랜잭션 사용자입니다.

      대화 상자 : 대화 상자는 두 사람 사이의 피어 - 투 - 피어 SIP 관계입니다.
         UA는 얼마 동안 지속됩니다. 대화 상자는
         INVITE 요청에 대한 2xx 응답과 같은 SIP 메시지. 에이
         대화 상자는 호출 식별자, 로컬 태그 및
         원격 태그. 이전에 대화 상자가 RFC의 통화 레그 (call leg)로 알려져있었습니다.
         2543.

      다운 스트림 : 트랜잭션 내의 메시지 전달 방향
         사용자로부터 요청이 전달되는 방향을 나타냅니다.
         에이전트 클라이언트를 사용자 에이전트 서버에 연결합니다.

      최종 응답 : SIP 트랜잭션을 종료하는 응답.
         그렇지 않은 잠정적 대응에 반대한다. 모든 2xx, 3xx,
         4xx, 5xx 및 6xx 응답은 최종입니다.

      헤더 : 헤더는 전달하는 SIP 메시지의 구성 요소입니다.
         메시지에 대한 정보. 시퀀스로 구성됩니다.
         헤더 필드

      헤더 필드 : 헤더 필드는 SIP 메시지의 구성 요소입니다.
         머리글. 헤더 필드는 하나 이상의 헤더 필드로 나타날 수 있습니다.
         행. 헤더 필드 행은 헤더 필드 이름과 0으로 구성됩니다.
         또는 더 많은 헤더 필드 값. 여러 헤더 필드 값



Rosenberg, et. al. 표준 트랙 [쪽 21]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         주어진 헤더 필드 행은 쉼표로 구분됩니다. 일부 헤더
         필드는 단일 헤더 필드 값만 가질 수 있으며
         결과는 항상 단일 헤더 필드 행으로 나타납니다.

      헤더 필드 값 : 헤더 필드 값은 단일 값입니다. 에이
         헤더 필드는 0 개 이상의 헤더 필드 값으로 구성됩니다.

      홈 도메인 (Home Domain) : SIP 사용자에게 서비스를 제공하는 도메인.
         일반적으로 이것은 URI에있는 도메인입니다.
         등록의 기록 주소 (address-of-record).

      정보 응답 : 임시 응답과 동일합니다.

      초 기자, 발신자, 발신자 : 세션을 시작한 당사자
         (및 대화 상자)에 INVITE 요청을 보냅니다. 발신자가 이것을 유지함
         초기 INVITE를 보낸 시간부터 역할
         대화 상자가 종료 될 때까지 대화 상자.

      초대장 : 초대 요청입니다.

      초대받은 사람, 초대 된 사용자, 호출 된 사람, 수신자 : 수신자
         INVITE 요청을 수신하여
         새로운 세션. 피 호출자는이 시점부터이 역할을 유지합니다.
         대화 상자가 종료 될 때까지 INVITE를받습니다.
         INVITE에 의해 설립되었습니다.

      위치 서비스 : 위치 서비스는 SIP 리디렉션 또는
         피 호출자의 가능한 정보를 얻기위한 프록시 서버
         위치. 여기에는 주소의 바인딩 목록이 포함되어 있습니다.
         0 개 이상의 연락처 주소에 키를 기록하십시오. 바인딩
         여러 방법으로 생성 및 제거 할 수 있습니다. 이 사양
         바인딩을 업데이트하는 REGISTER 메서드를 정의합니다.

      루프 : 프록시에 도착한 요청은 전달되고 나중에 요청됩니다.
         동일한 프록시에 다시 도착합니다. 도착하면 두 번째
         시간, 그 Request-URI는 처음과 동일하며, 다른
         프록시 작업에 영향을주는 헤더 필드는 변경되지 않으므로
         프록시가 동일한 처리 결정을 내릴 것이라고
         처음으로 요청하십시오. 루핑 된 요청은 오류,
         그것들을 탐지하고 다루는 절차는 다음과 같다.
         프로토콜에 의해 기술된다.

      느슨한 라우팅 : 다음과 같은 경우 프록시가 느슨한 라우팅이라고합니다.
         처리를 위해이 규격에서 정의 된 절차
         Route 헤더 필드. 이 절차는
         (Request-URI에 존재하는) 요청의 목적지





Rosenberg, et. al. 표준 트랙 [22 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         도중에 방문해야하는 프록시 집합
         (Route 헤더 필드에 있음). 다음을 준수하는 프록시
         이러한 메커니즘은 느슨한 라우터라고도합니다.

      메시지 : 프로토콜의 일부로 SIP 요소간에 전송되는 데이터입니다.
         SIP 메시지는 요청 또는 응답입니다.

      메소드 : 메소드는 요청이 의미하는 기본 함수입니다.
         서버에서 호출 할 수 있습니다. 메서드는 요청에 포함됩니다.
         메시지 자체. 예제 메서드는 INVITE 및 BYE입니다.

      아웃 바운드 프록시 (Outbound Proxy) : 클라이언트로부터 요청을받는 프록시.
         그것은 Request-URI에 의해 해결 된 서버가 아닐지라도.
         일반적으로 UA는 아웃 바운드 프록시로 수동 구성되며,
         자동 구성 프로토콜을 통해 하나에 대해 학습 할 수 있습니다.

      병렬 검색 : 병렬 검색에서 프록시는 여러 개의
         들어오는 메시지 수신시 가능한 사용자 위치에 대한 요청
         의뢰. 하나의 요청을 발행 한 다음 기다리는 것이 아니라
         다음 요청을 발행하기 전의 최종 응답
         순차적 검색, 병렬 검색은
         이전 요청의 결과를 기다리는 중.

      임시 응답 : 서버가 응답을 표시하기 위해 사용하는 응답
         진행하지만 SIP 트랜잭션을 종료하지는 않습니다. 1xx
         응답은 잠정적이며, 다른 응답도 고려됩니다.
         결정적인.

      프록시, 프록시 서버 : 둘 다 역할을하는 중간 엔터티
         서버 및 클라이언트에서 요청을하기위한 목적으로
         다른 고객을 대신하여 프록시 서버는 주로
         라우팅의 역할, 즉 라우팅의 역할은
         요청은 대상에 "가까이"있는 다른 개체로 전송됩니다.
         사용자. 프록시는 정책 실행에 유용합니다 (
         예 : 사용자가 전화를 걸 수 있는지 확인). 에이
         프록시 해석 및 필요한 경우 특정 부분을 다시 작성합니다.
         전달하기 전에 요청 메시지.

      재귀 : 클라이언트가 3xx 응답을 생성 할 때 반복됩니다.
         Contact 헤더에있는 하나 이상의 URI에 대한 새로운 요청
         응답의 필드.

      리디렉션 서버 : 리디렉션 서버는
         수신 한 요청에 대한 3xx 응답을 생성하고
         클라이언트가 대체 URI 세트에 접속할 것을 요청합니다.






Rosenberg, et. al. 표준 트랙 [23 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      등록 기관 : 등록 기관은 REGISTER 요청을 수락하는 서버입니다.
         요청에서받은 정보를
         처리하는 도메인의 위치 서비스

      일반 거래 : 일반 거래는
         INVITE, ACK 또는 CANCEL 이외의 방법.

      요청 : 클라이언트에서 서버로 보낸 SIP 메시지.
         특정 작업을 호출하기위한 목적.

      응답 : 서버에서 클라이언트로 보낸 SIP 메시지.
         클라이언트에서 클라이언트로 보낸 요청의 상태를 나타내는
         섬기는 사람.

      Ringback : Ringback은 호출에 의해 생성 된 신호음입니다.
         착신자가 존재 함을 나타내는 당사자의 신청서
         경고 (울림).

      경로 집합 : 경로 집합은 정렬 된 SIP 또는 SIPS URI의 모음입니다.
         이 때 프록시 서버는 다음과 같은 경우에 통과해야하는 프록시 목록을 나타냅니다.
         특정 요청을 보냅니다. 경로 집합을 학습 할 수 있으며,
         Record-Route와 같은 헤더를 통하거나 구성 할 수 있습니다.

      서버 : 서버는 요청을 수신하는 네트워크 요소입니다.
         그들에게 봉사하기 위해 명령을 내리고 그들에게 응답을 보낸다.
         요청. 서버의 예로는 프록시, 사용자 에이전트 서버,
         리디렉션 서버 및 레지스트라에 액세스 할 수 있습니다.

      순차 검색 : 순차 검색에서 프록시 서버 시도
         각 연락처 주소는 순서대로 다음 주소로 진행합니다.
         이전에 최종 응답이 생성 된 후에 만 2xx
         또는 6xx 클래스 최종 응답은 항상 순차적으로 종료됩니다.
         수색.

      세션 : SDP 사양에서 : "멀티미디어 세션은
         멀티미디어 전송자 및 수신기 집합과 데이터 스트림
         발신자에서 수신자로 흘러 들어갑니다. 멀티미디어 컨퍼런스
         멀티미디어 세션의 예 "(RFC 2327 [1]) (세션
         SDP에 정의 된대로 하나 이상의 RTP 세션을 구성 할 수 있습니다.) As
         피 호출자는 여러 번 초대 할 수 있습니다.
         통화를 동일한 세션으로 보냅니다. SDP가 사용되는 경우 세션은 다음과 같습니다.
         SDP 사용자 이름, 세션 ID,
         네트워크 유형, 주소 유형 및 주소 요소
         들.

      SIP 트랜잭션 : 클라이언트와 클라이언트간에 SIP 트랜잭션이 발생합니다.
         서버로 전송되고 첫 번째 전송 된 요청의 모든 메시지를 포함합니다.
         클라이언트에서 서버로 (1xx가 아닌) 최종 응답까지



Rosenberg, et. al. 표준 트랙 [Page 24]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         서버에서 클라이언트로 전송됩니다. 요청이 INVITE 인 경우
         최종 응답이 2xx가 아닌 경우 트랜잭션도
         응답에 대한 ACK를 포함합니다. 2xx 응답에 대한 ACK
         INVITE 요청은 별도의 트랜잭션입니다.

      나선형 : 나선형은 프록시에 라우팅되는 SIP 요청입니다.
         앞으로 나아가고 그 프록시에 다시 한번 도착하지만
         이 시간은 다른 결과를 초래할 수있는 방식으로 다릅니다.
         원래 요청보다 처리 결정. 일반적으로이
         요청의 Request-URI가 이전 요청과 다르다는 것을 의미합니다
         도착. 나선형은 루프와 달리 오류 조건이 아닙니다. 에이
         이에 대한 일반적인 원인은 착신 전환입니다. 사용자가 전화를 겁니다.
         joe@example.com. example.com 프록시는 Joe 's에 프록시를 전달합니다.
         PC는 bob@example.com으로 전달합니다. 이
         요청은 example.com 프록시로 다시 프록시됩니다. 하나,
         이것은 루프가 아닙니다. 요청이
         다른 사용자, 나선형으로 간주되며 유효합니다.
         조건.

      상태 유지 프록시 : 클라이언트를 유지 관리하는 논리적 개체
         이 명세서에 정의 된 서버 트랜잭션 상태 기계
         트랜잭션 처리라고도하는 요청 처리 중
         stateful 프록시. 상태 저장 프록시의 동작은
         (트랜잭션) 상태 저장 프록시는 섹션 16에 정의되어 있지 않습니다.
         통화 상태 저장 프록시와 동일합니다.

      Stateless Proxy : 상태 유지 프록시를 유지하지 않는 논리적 엔터티
         여기에 정의 된 클라이언트 또는 서버 트랜잭션 상태 머신
         요청을 처리 할 때 무국적 프록시
         다운 스트림과 모든 요청을 전달합니다.
         응답은 업스트림에 수신됩니다.

      엄격한 라우팅 : 프록시는 엄격한 라우팅이라고합니다.
         RFC 2543의 Route 처리 규칙과
         이 RFC의 진행 버전 그 규칙 때문에 프록시가
         Route 헤더가있을 때 Request-URI의 내용을 파괴한다.
         필드가 존재했다. 엄격한 라우팅 동작은 여기에 사용되지 않습니다.
         명세, 느슨한 라우팅 동작을 선호합니다. 프록시
         엄격한 라우팅을 수행하는 라우터는 엄격한 라우터라고도합니다.

      타겟 새로 고침 요청 :
         대화 상자는 리모컨을 수정할 수있는 요청으로 정의됩니다.
         대화 상자의 대상.

      트랜잭션 사용자 (TU) :
         트랜잭션 계층 위에 상주합니다. 거래 사용자는 다음을 포함합니다.
         UAC 코어, UAS 코어 및 프록시 코어.




Rosenberg, et. al. 표준 트랙 [페이지 25]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      상향 (Upstream) : 거래 내에서 메시지 전달의 방향
         사용자로부터 응답이 전달되는 방향을 나타냅니다.
         에이전트 서버를 사용자 에이전트 클라이언트에 다시 보냅니다.

      URL 인코딩 : RFC 2396에 따라 인코딩 된 문자열,
         섹션 2.4 [5].

      UAC (User Agent Client) : 사용자 에이전트 클라이언트는 논리적 엔티티입니다.
         새 요청을 만든 다음 클라이언트를 사용합니다.
         거래 상태 기계가 그것을 보낼 수 있습니다. UAC의 역할은 지속됩니다.
         해당 거래 기간 동안 만 즉,
         소프트웨어의 일부가 요청을 시작하면 UAC로 작동합니다.
         해당 트랜잭션의 지속 기간. 요청을 받으면
         나중에, 그것은 사용자 에이전트 서버의 역할을 가정합니다.
         해당 트랜잭션의 처리.

      UAC 코어 : UAC에 필요한 일련의 처리 기능
         트랜잭션 및 전송 계층 위에 상주합니다.

      UAS (User Agent Server) : 사용자 에이전트 서버는 논리적 엔터티입니다.
         SIP 요청에 대한 응답을 생성합니다. 응답
         요청을 수락, 거부 또는 리디렉션합니다. 이 역할은 지속됩니다.
         해당 거래 기간 동안 만 즉,
         소프트웨어의 일부가 요청에 응답하고, UAS로 작동합니다.
         해당 트랜잭션의 지속 기간. 요청을 생성하는 경우
         나중에, 그것은 사용자 에이전트 클라이언트의 역할을 가정합니다.
         해당 트랜잭션의 처리.

      UAS 코어 : UAS에서 요구되는 일련의 처리 기능
         트랜잭션 및 전송 계층 위에 상주합니다.

      사용자 에이전트 (UA) : 사용자로 작동 할 수있는 논리적 개체
         에이전트 클라이언트 및 사용자 에이전트 서버.

   프록시 및 리디렉션 서버뿐만 아니라 UAC 및 UAS의 역할은 다음과 같습니다.
   트랜잭션 단위로 정의됩니다. 예를 들어, 사용자
   호출을 시작하는 에이전트는 초기 INVITE를 보낼 때 UAC의 역할을 수행합니다
   요청과 수신자로부터 BYE 요청을 수신 할 때 UAS로 요청할 수 있습니다.
   마찬가지로, 동일한 소프트웨어가 하나의 프록시 서버로 작동 할 수 있습니다.
   다음 요청에 대한 리디렉션 서버로 사용됩니다.

   위에 정의 된 프록시, 위치 및 등록자 서버는 논리적입니다.
   엔티티; 구현은 그것들을 단일 애플리케이션으로 결합 할 수있다.

7 SIP 메시지

   SIP는 텍스트 기반 프로토콜이며 UTF-8 문자 세트 (RFC 2279
   [7]).



Rosenberg, et. al. 표준 트랙 [쪽 26]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   SIP 메시지는 클라이언트에서 서버로의 요청이거나
   서버에서 클라이언트로의 응답.

   요청 (7.1 절)과 응답 (7.2 절) 메시지 모두 사용
   문법이 다르더라도 RFC 2822 [3]의 기본 형식
   문자 세트 및 구문의 세부 사항. (SIP는 헤더 필드에서
   예를 들어 유효한 RFC 2822 헤더 필드가 아닐 것입니다.) 두 유형 모두
   메시지는 시작 라인, 하나 이상의 헤더 필드,
   헤더 필드의 끝을 나타내는 빈 줄 및 선택적
   메시지 - 본문.

         일반 메시지 = 시작 라인
                             * 메시지 머리글
                             CRLF
                             [message-body]
         시작 줄 = 요청 줄 / 상태 줄

   시작 줄, 각 메시지 머리글 줄 및 빈 줄은 반드시 있어야합니다.
   캐리지 리턴 라인 피드 시퀀스 (CRLF)에 의해 종료됩니다. 유의 사항
   메시지 본문이 없어도 빈 줄이 존재해야합니다 (MUST).

   위 문자 집합의 차이점을 제외하면 SIP의 대부분
   메시지 및 헤더 필드 구문은 HTTP / 1.1과 동일합니다. 차라리
   여기서 구문과 의미를 반복하는 것보다 [HX.Y]를 사용하여
   현재 HTTP / 1.1 명세 (RFC 2616 [8])의 X.Y 절까지.

   그러나 SIP는 HTTP의 확장이 아닙니다.

7.1 요청

   SIP 요청은 시작 - 요청에 대한 요청 -
   선. Request-Line은 메소드 이름, Request-URI 및
   프로토콜 버전은 단일 공백 ​​(SP) 문자로 구분됩니다.

   Request-Line은 CRLF로 끝납니다. 다음을 제외한 CR 또는 LF는 허용되지 않습니다.
   행의 끝의 CRLF 순서 선형 공백 (LWS)이 허용되지 않습니다.
   어떤 요소에서든.

         요청 라인 = 방법 SP 요청 URI SP SIP 버전 CRLF

      방법 :이 명세는 6 가지 방법을 정의한다 : REGISTER for
           연락처 정보 등록, INVITE, ACK 및 CANCEL
           세션 설정, 세션 종료를위한 BYE 및
           서버에 기능을 쿼리하는 옵션 한모금
           표준 트랙 RFC에 문서화 된 확장은
           추가 방법.





Rosenberg, et. al. 표준 트랙 [27 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      Request-URI : Request-URI는 다음에서 설명하는 SIP 또는 SIPS URI입니다.
           섹션 19.1 또는 일반적인 URI (RFC 2396 [5]). 그것은
           이 요청이 처리되는 사용자 또는 서비스.
           Request-URI는 이스케이프되지 않은 공백이나 제어를 포함해서는 안됩니다
           문자는 "<>"로 묶어서는 안됩니다.

           SIP 요소는 다음 이외의 방식으로 Request-URI를 지원할 수있다.
           "sip"과 "sips"(예 : RFC의 "tel"URI 스킴)
           2806 [9]. SIP 요소는 any를 사용하여 non-SIP URI를 번역 할 수있다.
           메커니즘을 사용하여 SIP URI, SIPS URI,
           또는 다른 어떤 계획.

      SIP 버전 : 요청 및 응답 메시지에는 모두
           버전의 SIP를 사용하고 [H3.1]을 따르십시오 (HTTP를 대체 함).
           SIP 및 HTTP / 1.1을 SIP / 2.0으로 대체) 버전 관련
           주문, 컴플라이언스 요구 사항 및 버전 업그레이드
           번호. 이 사양을 준수하려면,
           SIP 메시지를 보내는 응용 프로그램은 SIP 버전을 포함해야합니다
           "SIP / 2.0" SIP 버전 문자열은 대소 문자를 구분하지 않으므로,
           구현은 반드시 대문자를 보내야한다.

           HTTP / 1.1과 달리 SIP는 버전 번호를 리터럴로 취급합니다.
           끈. 실제로 이것은 아무런 차이가 없어야합니다.

7.2 응답

   SIP 응답은 Status-Line을 사용하여 요청과 구별됩니다.
   그들의 시작 라인으로. 상태 - 라인은 프로토콜 버전으로 구성됩니다
   이어서 숫자로 된 Status-Code와 그와 연관된 텍스트 문구,
   각 요소는 단일 SP 문자로 구분됩니다.

   최종 CRLF 순서를 제외하고 CR 또는 LF는 허용되지 않습니다.

      상태 줄 = SIP 버전 SP 상태 코드 SP 이유 - 구문 CRLF

   Status-Code는 3 자리 정수 결과 코드로,
   요청을 이해하고 충족시키기위한 시도의 결과. 그만큼
   이유 - 구문은 짧은 텍스트 설명을 제공하기위한 것입니다.
   상태 코드. 상태 코드는 오토마타에서 사용하기위한 것이며,
   Reason-Phrase는 인간 사용자를위한 것입니다. 클라이언트
   Reason-Phrase를 검사하거나 표시 할 필요가 없습니다.

   이 규격은 이유에 대한 구체적인 표현을 제시하고 있지만
   구문, 구현은 다른 텍스트를 선택할 수 있습니다 (예 :
   언어의 Accept-Language 헤더 필드에 표시된 언어
   의뢰.





Rosenberg, et. al. 표준품 [28 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   상태 코드의 첫 번째 숫자는 응답 클래스를 정의합니다.
   마지막 두 자리에는 분류 역할이 없습니다. 이것을 위해
   이유는 100과 199 사이의 상태 코드가있는 응답은
   "1xx 응답"이라고하는 상태 코드가있는 응답
   200과 299 사이의 "2xx 응답"등. SIP / 2.0 허용
   첫 번째 숫자에 대한 6 개의 값 :

      1xx : 잠정 - 요청을 접수하고 처리를 계속합니다.
           의뢰;

      2xx : 성공 - 행동이 성공적으로 접수되고, 이해되었으며,
           받아 들여지고;

      3xx : 리디렉션 - 추가 작업을 수행해야합니다.
           요청을 완료하십시오.

      4xx : 클라이언트 오류 - 요청에 잘못된 구문이 있거나 사용할 수 없습니다.
           이 서버에서 수행;

      5xx : 서버 오류 - 서버가 분명히 수행하지 못했습니다.
           유효한 요청;

      6xx : 글로벌 실패 - 요청이 충족 될 수 없음
           섬기는 사람.

   섹션 21에서는 이러한 클래스를 정의하고 개별 코드를 설명합니다.

7.3 헤더 필드

   SIP 헤더 필드는 두 구문 모두 HTTP 헤더 필드와 유사합니다.
   및 의미론. 특히, SIP 헤더 필드는 [H4.2]
   메시지 헤더의 구문 정의 및
   헤더 필드를 여러 줄로 확장합니다. 그러나 후자는
   HTTP에서 암시 적 공백 및 폴딩으로 지정됩니다. 이
   명세는 RFC 2234 [10]를 따르며 명시 적
   공백 및 접기는 문법의 필수적인 부분입니다.

   [H4.2]는 또한 동일한 필드의 여러 헤더 필드
   값이 쉼표로 구분 된 목록 인 이름은 하나로 결합 될 수 있습니다.
   헤더 필드. SIP에도 적용되지만 구체적인 규칙은 다음과 같습니다.
   다른 문법 때문에 다름. 특히, SIP
   문법이 형식의 헤더

      header = "header-name"HCOLON 헤더 값 * (COMMA 헤더 값)

   같은 이름의 헤더 필드를 콤마 상자에 결합 할 수 있습니다.
   구분 된 목록. 연락처 헤더 필드는 쉼표로 구분 된
   헤더 필드 값이 "*"가 아닌 한 목록에 추가하십시오.



Rosenberg, et. al. 표준 트랙 [29 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


7.3.1 헤더 필드 형식

   헤더 필드는에서 주어진 것과 동일한 일반 헤더 형식을 따릅니다.
   RFC 2822의 섹션 2.2 [3]. 각 헤더 필드는 필드로 구성됩니다.
   이름 뒤에 콜론 ( ":") 및 필드 값이옵니다.

      field-name : 필드 값

   25 절에 명시된 메시지 헤더의 형식 문법
   임의의 양의 공백을 허용합니다.
   콜론; 그러나 구현은 필드 사이의 공간을 피해야합니다.
   이름과 콜론 사이에 단일 공간 (SP)을 사용하십시오.
   필드 값.

      제목 : 점심 식사
      제목 : 점심 식사
      제목 : 점심 식사
      제목 : 점심 식사

   따라서 위의 내용은 모두 유효하고 동등하지만 마지막 부분은
   선호하는 형태.

   머리글 필드는 여러 줄로 확장 할 수 있습니다.
   적어도 하나의 SP 또는 수평 탭 (HT)이있는 추가 라인. 라인
   break와 다음 줄의 시작 부분에있는 공백은
   단일 SP 문자로 취급됩니다. 따라서, 다음과 같다.
   동등한:

      제목 : 당신이 거기에 있다는 것을 알고, 전화를 받아 나와 이야기하십시오!
      제목 : 네가 거기 있다는 걸 알아,
               전화를 받아
               그리고 나에게 말해!

   필드 이름이 다른 헤더 필드의 상대적인 순서는 다릅니다.
   중요한. 그러나, 헤더 필드가
   프록시 프로세싱에 필요 (비아, 루트, 레코드 - 루트, 프록시 - 요구,
   Max-Forwards 및 Proxy-Authorization)은 다음과 같이 나타납니다.
   빠른 파싱을 용이하게하기 위해 메시지 맨. 친척
   필드 이름이 같은 헤더 필드 행의 순서가 중요합니다.
   동일한 필드 이름을 가진 다중 헤더 필드 행은
   해당 헤더 필드의 전체 필드 값이
   쉼표로 구분 된 목록으로 정의됩니다 (즉, 문법을 따르는 경우
   7.3 절에서 정의 됨). 여러 개를 결합 할 수 있어야합니다 (MUST).
   헤더 필드 행을 하나의 "field-name : field-value"쌍으로
   메시지의 의미를 변경하는 것.
   필드 값을 첫 번째 값으로, 각각 쉼표로 구분합니다. 예외
   이 규칙에는 WWW-Authenticate, Authorization, Proxy-
   인증 및 프록시 인증 헤더 필드 다중 헤더



Rosenberg, et. al. 표준 트랙 [30 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   이러한 이름을 가진 필드 행은 메시지에 나타날 수 있지만
   문법은 7.3 절에 나열된 일반적인 형식을 따르지 않으며,
   그것들은 단일 헤더 필드 행에 결합되어서는 안된다.

   구현은 여러 헤더 필드 행을 처리 할 수 ​​있어야합니다 (MUST)
   한 줄에 하나의 값 또는 한 줄에 하나의 값을 조합하여 동일한 이름으로
   쉼표로 구분 된 값 형식.

   헤더 필드 행의 다음 그룹은 유효하며 동등합니다.

      경로 : <sip : alice@atlanta.com>
      제목 : 점심
      경로 : <sip : bob@biloxi.com>
      경로 : <sip : carol@chicago.com>

      경로 : <sip : alice@atlanta.com>, <sip : bob@biloxi.com>
      경로 : <sip : carol@chicago.com>
      제목 : 점심

      제목 : 점심
      경로 : <sip : alice@atlanta.com>, <sip : bob@biloxi.com>,
             <sip : carol@chicago.com>

   다음 블록은 모두 유효하지만
   기타 :

      경로 : <sip : alice@atlanta.com>
      경로 : <sip : bob@biloxi.com>
      경로 : <sip : carol@chicago.com>

      경로 : <sip : bob@biloxi.com>
      경로 : <sip : alice@atlanta.com>
      경로 : <sip : carol@chicago.com>

      경로 : <sip : alice@atlanta.com>, <sip : carol@chicago.com>,
             <sip : bob@biloxi.com>

   헤더 필드 값의 형식은 header-name마다 정의됩니다. 이것
   항상 TEXT-UTF8 옥텟의 불투명 한 시퀀스이거나
   공백, 토큰, 구분 기호 및 따옴표 붙은 문자열의 조합.
   기존의 많은 헤더 필드는 일반 형식의
   값 다음에 세미콜론으로 구분 된 sequence-parameter-name,
   매개 변수 - 값 쌍 :

         필드 이름 : 필드 값 * (; 매개 변수 이름 = 매개 변수 값)






Rosenberg, et. al. 표준 트랙 [Page 31]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   임의의 수의 매개 변수 쌍이
   헤더 필드 값, 주어진 매개 변수 이름은 더 이상 나타나서는 안됩니다
   한번 이상.

   헤더 필드를 비교할 때 필드 이름은 항상 대소 문자를 구별합니다.
   무신경. 정의에 달리 명시되어 있지 않는 한
   특정 헤더 필드, 필드 값, 매개 변수 이름 및 매개 변수
   값은 대소 문자를 구분하지 않습니다. 토큰은 항상 대소 문자를 구별합니다.
   달리 명시하지 않는 한 인용 문자열로 표시된 값은 다음과 같습니다.
   대소 문자를 구분합니다. 예를 들어,

      연락처 : <sip : alice@atlanta.com>; 만료 = 3600

   ~에 해당합니다.

      연락처 : <sip : alice@atlanta.com>, ExPiReS = 3600

   과

      내용 - 처리 : 세션, 처리 = 선택 사항

   ~에 해당합니다.

      content-disposition : 세션; HANDLING = OPTIONAL

   다음 두 헤더 필드는 동일하지 않습니다.

      경고 : 370 devnull "더 큰 파이프 선택"
      경고 : 370 devnull "큰 파이프 선택"

7.3.2 헤더 필드 분류

   일부 헤더 필드는 요청이나 응답에서만 의미가 있습니다. 이들
   요청 헤더 필드 및 응답 헤더 필드라고하며,
   각기. 헤더 필드가 일치하지 않는 메시지에 나타나는 경우
   그 범주 (응답의 요청 헤더 필드와 같은), 그것은 반드시
   무시해라. 섹션 20은 각 헤더의 분류를 정의합니다.
   들.

7.3.3 조밀 한 모양

   SIP는 공통 헤더 필드 이름을
   약식 형태. 이것은 메시지가 다른 경우에 유용 할 수 있습니다.
   이용할 수있는 수송 수단에서 운반하기에는 너무 커진다.
   (UDP 사용시 최대 전송 단위 (MTU) 초과,
   예). 이러한 소형 폼은 섹션 20에 정의되어 있습니다.
   폼은에서 더 긴 형태의 헤더 필드 이름으로 대체 될 수있다.
   언제든지 메시지의 의미를 변경하지 않아도됩니다. 헤더



Rosenberg, et. al. 표준 트랙 [32 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   필드 이름은 동일한 필드 내에서 긴 형식과 짧은 형식으로 나타날 수 있습니다.
   메시지. 구현은 반드시 긴 형식과 짧은 형식을 모두 받아 들여야 만한다
   각 헤더 이름의.

7.4 시체

   이 요청에 대한 확장으로 정의 된 새 요청을 포함하여 요청
   명세는 다른 언급이없는 한 메시지 본문을 포함 할 수있다.
   신체의 해석은 요청 방법에 달려 있습니다.

   응답 메시지의 경우 요청 방법과 응답 상태
   코드는 메시지 본문의 유형과 해석을 결정합니다. 모든
   응답에는 시체가 포함될 수 있습니다.

7.4.1 메시지 본문 유형

   메시지 본문의 인터넷 미디어 유형은 반드시
   Content-Type 헤더 필드. 본문에 인코딩이 완료된 경우
   (예 : 압축), Content-
   헤더 필드 인코딩; 그렇지 않으면 Content-Encoding을 생략해야합니다 (MUST).
   적용 가능한 경우 메시지 본문의 문자 집합은 다음과 같이 표시됩니다.
   Content-Type 헤더 필드 값의 일부.

   RFC 2046 [11]에 정의 된 "multipart"MIME 유형은
   메시지 본문. 요청을 보내는 구현
   포함 멀티 파트 메시지 본문은 세션 설명을 보내야합니다
   원격 구현 요구가있는 경우는, non-multipart 메세지 본문
   이것은 멀티 파트를 포함하지 않는 Accept 헤더 필드를 통해 이루어집니다.

   SIP 메시지는 2 진 본문 또는 본문 부분을 포함 할 수 있습니다. 없을 때
   명시 적 charset 매개 변수는 보낸 사람, 미디어 하위 유형
   "텍스트"유형의 기본 charset 값은
   "UTF-8".

7.4.2 메시지 본문 길이

   바이트 단위의 본문 길이는 Content-Length 헤더에 의해 제공됩니다.
   들. 20.14 절은이 헤더의 필요한 내용을 기술한다.
   필드에 자세히 설명합니다.

   HTTP / 1.1의 "chunked"전송 인코딩은 SIP에 사용되어서는 안된다.
   (참고 : 청크 분할 인코딩은 메시지 본문을 순서대로 수정합니다.
   그것을 자체 크기의 일련의 청크로 전송하기 위해
   지시자.)







Rosenberg, et. al. 표준 트랙 [33 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


7.5 프레이밍 SIP 메시지

   HTTP와 달리 SIP 구현은 UDP 또는 기타 신뢰할 수없는
   데이터 그램 프로토콜. 각 데이터 그램은 하나의 요청을 전달하거나
   응답. 사용법에 대한 제약에 대해서는 섹션 18을 참조하십시오.


믿을 수없는
   전송합니다.

   스트림 지향으로 SIP 메시지를 처리하는 구현
   전송은 시작 라인 앞에 나타나는 모든 CRLF를 반드시 무시해야합니다
   [H4.1].

      Content-Length 헤더 필드 값은
      각 SIP 메시지는 스트림 내에 존재한다. SIP가있을 때 항상 존재합니다.
      메시지는 스트림 지향 전송을 통해 전송됩니다.

8 일반 사용자 에이전트 동작

   사용자 에이전트는 최종 시스템을 나타냅니다. 그것은 사용자 에이전트를 포함합니다
   요청을 생성하는 클라이언트 (UAC)와 사용자 에이전트 서버
   (UAS)에 응답합니다. UAC는
   외부 자극 (사용자가 버튼을 클릭하면,
   또는 PSTN 회선상의 신호)를 수신하고 응답을 처리한다. UAS는
   요청을 수신하고 다음을 기반으로 응답을 생성 할 수 있습니다.
   사용자 입력, 외부 자극, 프로그램 실행 결과, 또는
   어떤 다른 메커니즘.

   UAC가 요청을 보내면 요청은
   프록시 서버는 요청을 UAS쪽으로 전달합니다. 때
   UAS는 응답을 생성하고, 응답은 UAC로 전달됩니다.

   UAC 및 UAS 절차는 두 가지 요인에 크게 의존합니다. 첫째, 기반
   요청 또는 응답이 대화 상자의 내부 또는 외부에 있는지,
   둘째, 요청 방법에 기반합니다. 대화 상자 토론
   12 절을 철저히 준수한다. 피어 - 투 - 피어 관계를 나타냅니다.
   사용자 에이전트들 사이에 존재하며 특정 SIP 방법들에 의해 설정된다.
   INVITE.

   이 섹션에서는 UAC에 대한 메소드 독립적 인 규칙과
   대화 상자 외부에있는 요청을 처리 할 때의 UAS 작동.
   여기에는 물론 자신이 요구하는 요청이 포함됩니다.
   대화.

   대화 상자 외부의 요청 및 응답 보안 절차
   26 절에서 설명한다.
   UAS와 UAC는 상호 인증을합니다. 제한된 개인 정보
   기능은 다음을 사용하여 본문의 암호화를 통해 지원됩니다.
   S / MIME.




Rosenberg, et. al. 표준 트랙 [34 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


8.1 UAC 행동

   이 절에서는 대화 상자 외부의 UAC 동작에 대해 설명합니다.

8.1.1 요청 생성

   UAC가 공식화 한 유효한 SIP 요청은 최소한 다음을 포함해야합니다.
   다음 헤더 필드 : To, From, CSeq, Call-ID, Max-Forwards,
   및 비아; 모든 헤더 필드는 모든 SIP에서 필수 항목입니다.
   요청. 이 6 개의 헤더 필드는 기본 건물입니다.
   SIP 메시지의 대부분의 블록을 공동으로 제공하기 때문에
   중요한 메시지 라우팅 서비스
   메시지, 응답 라우팅, 메시지 전파 제한,
   메시지의 순서 지정, 트랜잭션의 고유 한 식별 등이 있습니다.
   이 헤더 필드는 필수 요청 행에 추가되며,
   Request-URI 및 SIP 버전을 포함합니다.

   대화 상자 외부로 전송 된 요청의 예로는 INVITE to
   세션을 설정하고 (섹션 13) 쿼리 할 OPTIONS
   능력 (섹션 11).

8.1.1.1 요청 URI

   메시지의 초기 Request-URI는 다음과 같은 값으로 설정되어야한다 (SHOULD).
   To 필드의 URI 한 가지 주목할만한 예외는 REGISTER
   방법; REGISTER의 Request-URI를 설정하는 동작은 다음과 같습니다.
   제 10 절. 사생활 보호를 이유로 바람직하지 않을 수도 있습니다.
   이 필드를 동일한 값으로 설정할 때 편리합니다 (특히
   발신 UA는 Request-URI가
   운송).

   일부 특수한 상황에서 기존 경로가 있음
   set은 메시지의 Request-URI에 영향을 줄 수 있습니다. 기존 경로
   set은 서버 체인을 식별하는 URI의 정렬 된 집합입니다.
   UAC는 대화 상자 외부에있는 나가는 요청을 보냅니다.
   일반적으로 사용자 또는 서비스 공급자가 UA에서 구성합니다.
   수동으로 또는 다른 비 SIP 메커니즘을 통해 제공자가
   아웃 바운드 프록시를 사용하여 UA를 구성하려는 경우 권장됩니다.
   기존의 경로를 제공하여
   하나의 URI, 아웃 바운드 프록시의 URI.

   선재 경로가 존재할 때,
   섹션에 설명 된 Request-URI 및 Route 헤더 필드 채우기
   12.2.1.1 (대화 상자가 없더라도) 반드시 따라야하며,
   원하는 Request-URI를 원격 대상 URI로 사용합니다.






Rosenberg, et. al. 표준 트랙 [35 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


8.1.1.2받는 사람

   먼저 To 헤더 필드는 원하는 것을 지정합니다
   요청의 "논리적"수신자 또는 요청의
   이 요청의 대상인 사용자 또는 리소스 이것은 또는
   요청의 최종 수신자가 아니어야합니다. To 헤더 필드
   SIP 또는 SIPS URI를 포함 할 수 있지만 다른 URI를 사용할 수도 있습니다
   schemes (예 : tel URL (RFC 2806 [9]))을 사용합니다.
   모든 SIP 구현은 반드시 SIP URI 스킴을 지원해야한다. 어떤
   TLS를 지원하는 구현은 SIPS URI 체계를 지원해야한다.
   To 헤더 필드는 표시 이름을 허용합니다.

   UAC는 특정 헤더에 대해 To 헤더 필드를 채우는 방법을 배울 수 있습니다
   여러 가지 방법으로 요청하십시오. 일반적으로 사용자는
   URI를 입력하는 휴먼 인터페이스를 통한 헤더 필드
   수동으로 또는 일종의 주소록에서 선택하십시오. 자주,
   사용자는 완전한 URI를 입력하지 않고 오히려 숫자 문자열을 입력합니다
   또는 편지 (예 : "봅"). UA의 재량에 달려있다.
   이 입력을 해석하는 방법을 선택하십시오. 문자열을 사용하여
   SIP URI의 사용자 부분은 UA가 그 이름이
   도메인에서 at-sign의 오른쪽 (RHS)으로 결정됨
   SIP URI (예 : sip : bob@example.com)입니다. 문자열을 사용하여
   SIPS URI의 사용자 부분을 형성한다는 것은 UA가
   안전하게 소통하고 그 이름을
   도메인을 at 기호의 RHS에 추가하십시오. RHS는 종종
   홈 도메인을 허용하는 요청자의 홈 도메인
   나가는 요청을 처리합니다. 이것은 다음과 같은 기능에 유용합니다.
   집에서 사용자 부분의 해석이 필요한 "단축 다이얼"
   도메인. UA가 지정을 원하지 않을 때 tel URL이 사용될 수 있습니다.
   전화 번호를 해석해야하는 도메인
   사용자가 입력합니다. 오히려 요청을 처리하는 각 도메인
   패스에는 그 기회가 주어집니다. 예를 들어,
   공항에 로그인하여 아웃 바운드 프록시를 통해 요청을 보낼 수 있습니다.
   공항. '411'을 입력하면 (지역 전화 번호입니다.
   미국의 디렉토리 지원)
   공항의 아웃 바운드 프록시가 해석하고 처리합니다.
   사용자의 홈 도메인 이 경우 tel : 411이 맞을 것입니다.
   선택.

   대화 상자 외부의 요청에는 To 태그가 없어야합니다 (MUST NOT). ~ 안에있는 태그
   요청의받는 사람 필드는 대화 상대의 피어를 식별합니다. 이후
   대화 상자가 설정되지 않고 태그가 없습니다.

   To 헤더 필드에 대한 자세한 내용은 20.39 절을 참조하십시오.
   다음은 유효한 To 헤더 필드의 예입니다.

      받는 사람 : Carol <sip : carol@chicago.com>




Rosenberg, et. al. 표준 트랙 [36 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


8.1.1.3

   From 헤더 필드는 초 기자의 논리적 ID를 나타냅니다
   요청의, 아마도 사용자의 레코드 주소. 할일처럼
   헤더 필드에는 URI와 선택적으로 표시 이름이 포함됩니다. 그것은
   적용 할 처리 규칙을 결정하기 위해 SIP 요소에서 사용합니다.
   요청 (예 : 자동 통화 거절). 따라서,
   From URI에 IP 주소 나 FQDN이 포함되지 않는 것이 매우 중요합니다.
   UA가 실행중인 호스트의 이름은 논리적이 아니기 때문에
   이름.

   From 헤더 필드는 표시 이름을 허용합니다. UAC는 사용해야한다.
   구문 적으로 올바른 표시 이름 "익명",하지만
   그렇지 않으면 의미없는 URI (예 : sip : thisis@anonymous.invalid).
   클라이언트의 신원은 숨겨져 있어야합니다.

   일반적으로 요청의 From 헤더 필드를 채우는 값
   특정 UA가 생성 한 정보는 사용자 또는
   사용자의 로컬 도메인 관리자 특정 UA가
   여러 사용자가 사용하는 전환 가능한 프로필이있을 수 있습니다.
   프로파일 링 된 사용자의 신원에 해당하는 URI를 포함하십시오.
   요청 수신자는 요청의 발신자를 인증 할 수 있습니다.
   From 헤더 필드가 누구인지 확인하기 위해
   주장하고있다 (인증에 대한 자세한 내용은 22 절 참조).

   From 필드는 반드시 UAC에 의해 선택된 새로운 "태그"매개 변수를 포함해야합니다.
   태그 선택에 대한 자세한 내용은 19.3 절을 참조하십시오.

   From 헤더 필드에 대한 자세한 내용은 20.20 절을 참조하십시오.
   예 :

      보낸 사람 : "Bob"<sips : bob@biloxi.com>; tag = a48s
      보낸 사람 : sip : +12125551212@phone2net.com, tag = 887s
      보낸 사람 : 익명 <sip : c8oqz84zk7z@privacy.org>; tag = hyh8

8.1.1.4 통화 ID

   Call-ID 헤더 필드는 그룹에 대한 고유 한 식별자로 사용됩니다
   함께 일련의 메시지. 모든 요청에 ​​대해 동일해야합니다.
   대화 상자에서 UA 중 하나가 보낸 응답을 표시합니다. 그것은 같아야한다.
   UA에서 등록 할 때마다

   대화 상자 외부에서 UAC에 의해 생성 된 새로운 요청에서 Call-ID
   헤더 필드는 UAC에 의해 전역 적으로 유일해야한다.
   특정 메소드에 의해 오버라이드 (override)되지 않는 한 공간과 시간에 대한 식별자
   행동. 모든 SIP UA는 Call-
   ID 헤더 필드는 실수로 생성되지 않습니다.
   다른 UA. 특정 요청 후 요청이 재 시도 될 때



Rosenberg, et. al. 표준 트랙 [37 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   요청에 대한 수정을 요구하는 실패 응답 (
   예를 들어, 인증을위한 시도), 이러한 재 시도 된 요청은
   새 요청으로 간주되지 않으므로 새로운 Call-ID가 필요하지 않습니다.
   헤더 필드; 8.1.3.5 절을 보라.

   암호 무작위 식별자의 사용 (RFC 1750 [12])
   Call-ID 생성은 권장됩니다. 구현시에
   localid @ host "를 작성하십시오. 통화 ID는 대소 문자를 구분하며 간단합니다.
   바이트 단위로 비교했다.

      암호 학적으로 임의의 식별자를 사용하면
      세션 하이재킹에 대한 보호 및
      의도하지 않은 Call-ID 충돌.

   선택을위한 프로비저닝 또는 휴먼 인터페이스가 필요하지 않습니다.
   요청에 대한 Call-ID 헤더 필드 값.

   Call-ID 헤더 필드에 대한 자세한 내용은 섹션을 참조하십시오.
   20.8.

   예:

      통화 ID : f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com

8.1.1.5 CSeq

   CSeq 헤더 필드는 식별 및 주문 방법입니다
   업무. 시퀀스 번호와 메소드로 구성됩니다. 그만큼
   메소드는 요청과 일치해야합니다. 비 REGISTER 요청의 경우
   대화 상자 외부에서 순차 번호 값은 임의적입니다. 그만큼
   시퀀스 번호 값은 32 비트 부호없는 것으로 표현 가능해야한다.
   2 ** 31보다 작아야한다. 위의 내용을 따르는 한
   지침에 따라 클라이언트는 선택할 메커니즘을 사용할 수 있습니다
   CSeq 헤더 필드 값.

   12.2.1.1 절은 요청에 대한 CSeq의 구성에 대해 설명합니다.
   대화 상자 내에서.

   예:

      CSeq : 4711 초대










Rosenberg, et. al. 표준은 궤도 [38 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


8.1.1.6 Max-Forwards

   Max-Forwards 헤더 필드는 홉 수를 제한하는 역할을합니다.
   요청은 목적지로가는 도중에 통과 할 수 있습니다. 그것은
   각 홉에서 1 씩 감소하는 정수 맥스 포워드 (Max-Forwards)
   요청이 목적지에 도달하기 전에 값이 0에 도달하면
   483 (너무 많은 홉스) 오류 응답으로 거부 될 수 있습니다.

   UAC는 각 요청에 Max-Forwards 헤더 필드를 삽입해야합니다
   이 값은 70이어야한다.
   요구가 이루어지지 않을 정도로 충분히 커야한다.
   루프가 없었지만 그다지 크지 않은 SIP 네트워크에서는
   루프가 발생할 때 프록시 리소스를 소비합니다. 낮은 값
   주의해서 사용해야하며 토폴로지가있는 네트워크에서만 사용해야합니다.
   UA에 의해 알려진.

8.1.1.7 비아

   Via 헤더 필드는 트랜잭션에 사용 된 전송을 나타냅니다.
   응답을 보낼 위치를 식별합니다. 비아
   헤더 필드 값은 전송 후에 만 ​​추가됩니다.
   다음 홉에 도달하는 데 사용 된 항목이 선택되었습니다 (
   [4]의 절차 사용).

   UAC가 요청을 생성 할 때 반드시 Via를 삽입해야합니다
   의뢰. 헤더 필드의 프로토콜 이름 및 프로토콜 버전
   SIP 및 2.0이어야합니다. 비아 헤더 필드 값 (MUST)
   분기 매개 변수를 포함합니다. 이 매개 변수는
   해당 요청에 의해 생성 된 트랜잭션. 이 매개 변수는 둘 다 사용됩니다.
   클라이언트와 서버.

   분기 매개 변수 값은 공간 및 시간에 대해 고유해야합니다 (MUST).
   UA가 보낸 모든 요청 이 규칙의 예외는 CANCEL입니다.
   비 2xx 응답에 대한 ACK 아래에 설명 된 바와 같이, CANCEL 요청
   요청과 동일한 분기 매개 변수 값을가집니다.
   취소합니다. 섹션 17.1.1.3에서 논의 되었 듯이, 2xx가 아닌 것에 대한 ACK
   응답에는 INVITE와 동일한 지점 ID가 있습니다.
   그것이 인정하는 응답.

      지점 ID 매개 변수의 고유성 속성으로 쉽게 사용할 수 있습니다.
      트랜잭션 ID로 사용하는 것은 RFC 2543의 일부가 아닙니다.

   이 항목과 일치하는 요소에서 삽입 한 분기 ID
   사양은 항상 "z9hG4bK"문자로 시작해야합니다. 이들
   7 개의 문자가 마법 쿠키로 사용됩니다 (7은
   이전 RFC 2543 구현이 그러한
   값), 요청을 수신 한 서버는
   지점 ID는 다음에 설명 된 방식으로 구성되었습니다.



Rosenberg, et. al. 표준 트랙 [39 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   명세 (즉, 세계적으로 유일한). 이 요구 사항을 넘어,
   분기 토큰의 정확한 형식은 구현에 따라 정의됩니다.

   Via 헤더 maddr, ttl 및 sent-by 구성 요소는 다음과 같이 설정됩니다.
   요청은 전송 계층에 의해 처리된다 (18 절).

   프록시를위한 비아 처리는 16.6 절 항목 8에 설명되어 있습니다.
   섹션 16.7 항목 3.

연락처 8.1.1.8

   Contact 헤더 필드는 사용할 수있는 SIP 또는 SIPS URI를 제공합니다
   후속 요청을 위해 UA의 해당 특정 인스턴스에 연락해야합니다.
   Contact 헤더 필드는 반드시 존재해야하며 정확히 하나의 SIP
   또는 SIPS URI를 요청할 수 있습니다.
   대화. 본 명세서에서 정의 된 방법들에는 다음을 포함한다.
   INVITE 요청 만 이러한 요청의 경우,
   연락처는 글로벌입니다. 즉, Contact 헤더 필드 값에는 다음이 포함됩니다.
   UA가 요청을 수신하고자하는 URI 및이 URI
   외부의 후속 요청에 사용 된 경우에도 유효해야합니다.
   대화 상자.

   Request-URI 또는 ​​Top Route 헤더 필드 값에 SIPS가 포함 된 경우
   URI의 경우 Contact 헤더 필드는 SIPS URI도 포함해야합니다.

   Contact 헤더 필드에 대한 자세한 내용은 섹션을 참조하십시오.
   20.10.

8.1.1.9 지원 및 요구 사항

   UAC가 SIP 확장 기능을 지원하는 경우
   서버가 응답에 UAC는 지원 헤더를 포함해야합니다
   필드에 해당 옵션 태그 (섹션 19.2)가 나열된 요청
   확장.

   나열된 옵션 태그는에서 정의 된 확장 만 참조해야합니다.
   표준 추적 RFCs. 이것은 서버가
   클라이언트는 비표준 벤더 정의 기능을 구현하여
   서비스를받습니다. 시험 버전 및 확장 버전으로 정의 된 확장 프로그램
   정보 용 RFC는 명시 적으로 사용에서 제외됩니다.
   요청에서 지원되는 헤더 필드. 너무 자주 사용되기 때문에
   공급 업체 정의 확장을 문서화합니다.

   UAC가 UAS가 확장을 이해한다고 주장한다면
   UAC는 요청을 처리하기 위해 요청에 적용 할 것이며,
   요청 헤더 필드를 요청 목록에 삽입해야합니다.
   그 확장을위한 옵션 태그. UAC가
   요청을 확장하고 모든 프록시가



Rosenberg, et. al. 표준 트랙 [Page 40]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   확장을 이해하면, 프록시 - 요구를 삽입해야한다.
   헤더 필드를 요청에 포함시켜 그 옵션 태그를 나열합니다.
   신장.

   Supported 헤더 필드와 마찬가지로 Require의 옵션 태그
   및 Proxy-Require 헤더 필드는 정의 된 확장만을 참조해야합니다.
   표준 추적 RFC에 포함되어 있습니다.

8.1.1.10 추가 메시지 구성 요소

   새로운 요청이 생성되고 헤더 필드가 설명 된 후
   상기의 임의의 추가 선택 헤더
   메소드와 관련된 모든 헤더 필드와 마찬가지로 필드가 추가됩니다.

   SIP 요청은 MIME 인코딩 된 메시지 본문을 포함 할 수 있습니다 (MAY). 관계없이
   요청에 포함 된 본문의 유형, 특정 헤더 필드는
   신체의 내용을 특징 짓기 위해 공식화되어야한다. 추가 정보
   이 헤더 필드에 대한 정보는 섹션 20.11에서 20.15를 참조하십시오.

8.1.2 요청 보내기

   그런 다음 요청의 대상이 계산됩니다. 없는 한
   그렇지 않으면 목적지를 결정해야만한다.
   [4]에 설명 된 DNS 절차를 적용하여 다음과 같이합니다. 만약
   경로 집합의 첫 번째 요소는 엄격한 라우터를 나타냅니다 (결과적으로
   12.2.1.1 절에서 설명한대로 요청을 구성 할 때)
   절차는 요청의 Request-URI에 반드시 적용되어야한다.
   그렇지 않은 경우 절차는 첫 번째 Route 헤더 필드에 적용됩니다
   요청의 값 (있는 경우) 또는 요청의 요청 URI
   Route 헤더 필드가없는 경우. 이 절차를 통해
   주소, 포트 및 전송 집합을 시도합니다. 독립적 인
   그 중 URI가 [4]의 절차에 대한 입력으로 사용되는 경우,
   Request-URI는 SIPS 리소스를 지정하며 UAC는
   입력 URI가 SIPS URI 인 것처럼 [4]의 절차

   로컬 정책은 시도 할 대체 목적지 세트를 지정할 수있다.
   Request-URI가 SIPS URI를 포함하는 경우, 대체 목적지
   TLS와 반드시 연락해야합니다. 그 너머에는 제한이 없습니다.
   요청에 Route 헤더가없는 경우 대체 대상에
   들. 이는 기존 경로에 대한 간단한 대안을 제공합니다.
   아웃 바운드 프록시를 지정하는 방법으로 설정합니다. 그러나, 그 접근법
   아웃 바운드 프록시를 구성하는 것은 권장되지 않습니다. 선재
   대신 하나의 URI를 사용하는 라우트 집합이 사용되어야한다 (SHOULD). 요청이있는 경우
   Route 헤더 필드를 포함하고 있다면, 요청은
   위치는 최상위 값에서 파생되지만 임의의 위치로 전송 될 수 있습니다
   UA가 확실한 서버는 Route 및 Request-URI를 존중합니다.
   이 문서에 지정된 정책 (RFC
   2543). 특히 아웃 바운드 프록시로 구성된 UAC는



Rosenberg, et. al. 표준 트랙 [41 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   요청을 첫 번째 위치에 표시된 위치로 보내려고 시도합니다.
   전송 정책을 채택하는 대신 헤더 필드 값 전달
   아웃 바운드 프록시에 대한 모든 메시지

      이렇게하면 Record-Route를 추가하지 않는 아웃 바운드 프록시
      헤더 필드 값은 이후의 경로에서 벗어납니다.
      요청. 첫 번째 경로를 해결할 수없는 끝점을 허용합니다.
      URI를 사용하여 해당 작업을 아웃 바운드 프록시에 위임합니다.

   UAC는 [4]에서 정의 된 절차에 따라 스테이트 풀
   요소를 사용하여 서버에 접속할 때까지 각 주소를 시도하십시오. 각 시도
   새로운 거래를 구성하므로 각각 다른
   새로운 분기 매개 변수가있는 최상위 Via 헤더 필드 값.
   또한, Via 헤더 필드의 전송 값은
   대상 서버에 대해 결정된 전송.

8.1.3 응답 처리

   응답은 먼저 전송 계층에서 처리 된 다음 전달됩니다.
   트랜잭션 계층까지. 트랜잭션 계층은
   처리 한 다음 응답을 TU로 전달합니다. 대다수
   TU에서의 응답 처리는 방법에 따라 다릅니다. 그러나 거기에
   방법과 무관 한 일반적인 행동입니다.

8.1.3.1 트랜잭션 계층 오류

   경우에 따라 트랜잭션 계층에서 반환하는 응답은
   SIP 메시지가 아니라 오히려 트랜잭션 계층 오류입니다. 때
   타임 아웃 오류가 트랜잭션 계층으로부터 수신되면
   마치 408 (Request Timeout) 상태 코드가 수신 된 것처럼 처리됩니다.
   전송 계층에서 치명적인 전송 오류가보고되면
   (일반적으로 UDP의 치명적인 ICMP 오류 또는
   TCP), 조건은 503 (서비스 사용 불가능)으로 처리되어야합니다 (MUST)
   상태 코드.

8.1.3.2 인식 할 수없는 응답

   UAC는 그것이 인식하지 못하는 최종 응답을 반드시 처리해야합니다
   그 클래스의 x00 응답 코드와 동등하며,
   모든 클래스에 대한 x00 응답 코드를 처리합니다. 예를 들어,
   UAC는 431의 인식 할 수없는 응답 코드를받습니다.
   요청에 잘못된 것이 있다고 생각하고
   400 (잘못된 요청) 응답 코드를받은 것처럼 응답합니다. 에이
   UAC는 100과 다른 임시 응답을 반드시 처리해야합니다
   183 (세션 진행)으로 인식하지 못합니다. UAC는 다음을 수행 할 수 있어야합니다.
   100 개 및 183 개의 응답을 처리합니다.





Rosenberg, et. al. 표준 트랙 [42 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


8.1.3.3 비아

   하나 이상의 Via 헤더 필드 값이 응답에 존재하면
   UAC는 메시지를 폐기해야합니다.

      앞에있는 추가 Via 헤더 필드 값의 존재
      요청의 발신자는 메시지가
      잘못 라우팅되었거나 손상되었을 수 있습니다.

8.1.3.4 3xx 응답 처리

   리디렉션 응답 (예 : 301 응답
   상태 코드), 클라이언트는 Contact 헤더의 URI를 사용해야한다 (SHOULD).
   리다이렉트 된 정보에 기초하여 하나 이상의 새로운 요청을 공식화하기위한 필드
   의뢰. 이 프로세스는 프록시에서 재귀 호출하는 프로세스와 유사합니다.
   섹션 16.5 및 16.6에 설명 된 3xx 클래스 응답. 클라이언트
   정확히 하나의 URI를 포함하는 초기 대상 세트로 시작하여
   요청 - 원래 요청의 URI. 고객이 공식화하고자하는 경우
   해당 요청에 대한 3xx 클래스 응답을 기반으로하는 새 요청
   타겟 세트에 들어가기위한 URI. 에서 제한에 따라
   이 사양에서는 클라이언트가 어떤 연락처 URI를 선택할 수 있습니다.
   목표 세트에 넣습니다. 프록시 재귀와 마찬가지로, 클라이언트 처리
   3xx 클래스 응답은 지정된 URI를 대상 집합에 더 추가해서는 안됩니다
   한번 이상. 원래의 요청이 Request-
   URI 일 때, 클라이언트는 non-SIPS URI로 재귀하도록 선택할 수 있지만,
   안전하지 않은 URI 로의 리디렉션을 사용자에게 알립니다.

      새로운 요청은 3xx 응답 자체를 수신 할 수 있습니다.
      원래 URI를 연락처로 사용합니다. 두 개의 위치를 ​​다음과 같이 구성 할 수 있습니다.
      서로에게 방향을 바꾼다. 지정된 URI를 대상 집합에 배치
      무한 리디렉션 루프를 한 번만 방지합니다.

   목표 세트가 커짐에 따라, 클라이언트는
   임의의 순서로 된 URI. 일반적인 메커니즘은 "q"로 세트를 주문하는 것입니다.
   매개 변수 값은 Contact 헤더 필드 값에서 가져옵니다. 요청은
   URI는 순차적으로 또는 병렬로 생성 될 수 있습니다 (MAY). 하나의 접근법은
   감소하는 q- 값을 연속적으로 처리하고 URI를 처리하는 그룹
   각 q- 값 그룹에서 병렬로. 다른 하나는 시리얼 만 수행하는 것입니다.
   q 값 순서를 줄이거 나 임의로 선택
   동일한 q 값의 접촉.

   목록에있는 주소에 접속하면 정의 된대로 실패합니다
   다음 단락에서 요소는 다음 주소로 이동합니다.
   목록이 소진 될 때까지 목록이 고갈 된 경우
   요청이 실패했습니다.






Rosenberg, et. al. 표준 Track [43 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   실패는 실패 응답 코드 (코드
   399보다 큼); 네트워크 오류의 경우 클라이언트 트랜잭션은
   트랜잭션 사용자에게 전송 계층 실패를보고합니다. 노트
   일부 응답 코드 (8.1.3.5에서 자세히 설명 됨)는
   요청을 다시 시도 할 수 있습니다. 다시 시도되는 요청은
   고려 된 실패.

   특정 연락처 주소에 대한 오류가 수신되면
   클라이언트는 다음 연락처 주소를 시도해야합니다. 이것은
   새로운 요청을 전달하기 위해 새로운 클라이언트 트랜잭션을 생성합니다.

   3xx의 연락처 주소를 기반으로 요청을 작성하려면
   응답에서 UAC는 대상 세트의 전체 URI를
   Request-URI ( "method-param"및 "header"URI 제외)
   매개 변수 (이 매개 변수의 정의는 19.1.1 절 참조).
   'header'매개 변수를 사용하여
   새 요청, 해당 헤더 필드 값을 덮어 씁니다.
   섹션의 지침에 따라 리디렉션 된 요청
   19.1.5.

   경우에 따라 헤더 필드가
   연락처 주소로 전달 된 정보가 기존 정보에 추가 될 수 있습니다.
   원래 리디렉션 된 요청의 헤더 필드를 요청합니다. 마찬가지로
   일반 규칙, 헤더 필드가 쉼표로 구분 된 목록을 허용 할 수있는 경우
   새로운 헤더 필드 값은 임의의 값에 추가 될 수있다.
   원래 리디렉션 된 요청의 기존 값 헤더의 경우
   필드는 여러 값을 허용하지 않습니다. 원래 값
   리디렉션 된 요청은 헤더 필드 값으로 덮어 쓸 수 있습니다.
   연락처 주소로 전달되었습니다. 예를 들어, 연락처
   주소는 다음 값과 함께 반환됩니다.

      sip : user @ host? Subject = foo & Call-Info = <http://www.foo.com>

   그런 다음 원래의 리디렉션 된 요청의 제목 헤더 필드는 다음과 같습니다.
   덮어 씌여 지지만 HTTP URL은 기존의
   호출 정보 헤더 필드 값.

   UAC가 동일한 To, From 및 Call-ID를 재사용하는 것이 좋습니다
   원래의 리디렉션 된 요청에 사용되지만 UAC는 또한
   새 요청에 대한 Call-ID 헤더 필드 값을 업데이트하려면
   예.

   마지막으로, 새로운 요청이 구성되면, 다음을 사용하여 전송됩니다.
   새 클라이언트 트랜잭션이므로 새 분기 ID가 있어야합니다.
   섹션 8.1.1.7에서 논의 된 바와 같이 최상위 필드.






Rosenberg, et. al. 표준 트랙 [44 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   다른 모든면에서 리디렉션을 받으면 요청이 전송됩니다.
   응답은 원래의 헤더 필드와 본문을 다시 사용해야한다.
   의뢰.

   경우에 따라 Contact 헤더 필드 값이 UAC에 캐시 될 수 있습니다
   받은 상태 코드에 따라 일시적으로 또는 영구적으로
   만기 간격의 존재; 섹션 21.3.2 및
   21.3.3.

8.1.3.5 4xx 응답 처리

   특정 4xx 응답 코드에는 특정 UA 처리가 필요하며,
   방법에 독립적입니다.

   401 (인증되지 않음) 또는 407 (프록시 인증 필요)
   응답을 받으면 UAC가 승인을 받아야합니다
   섹션 22.2 및 섹션 22.3의 절차를 사용하여 요청을 재 시도하십시오.
   신임장.

   413 (요청 개체가 너무 큼) 응답을받은 경우 (섹션
   21.4.11), 요청에는 UAS보다 긴 시체가 포함되었다
   받아 들일 용의가있었습니다. 가능한 경우, UAC는 다시 시도해야한다.
   몸을 생략하거나 더 작은 길이를 사용하십시오.

   415 (지원되지 않는 미디어 유형) 응답이 수신 된 경우 (섹션
   21.4.13) 요청에는 UAS에서 지원하지 않는 미디어 유형이 포함되었습니다.
   UAC는 요청 전송을 재 시도해야하며, 이번에는
   응답의 Accept 헤더 필드에 나열된 유형의 컨텐츠,
   Accept-Encoding 헤더 필드에 나열된 인코딩을 사용하여
   응답 및 언어의 수락 언어 목록에
   응답.

   416 (Unsupported URI Scheme) 응답이 수신되면 (섹션
   21.4.14), Request-URI는
   섬기는 사람. 클라이언트는 이번에는 SIP를 사용하여 요청을 재 시도해야한다 (SHOULD).
   URI.

   420 (잘못된 확장) 응답을 받으면 (21.4.15 절),
   요청에는 Require 또는 Proxy-Require 헤더 필드가 포함되어 있습니다.
   proxy 또는 UAS에서 지원하지 않는 기능에 대한 옵션 태그. UAC
   요청을 재 시도해야하며, 이번에는
   응답의 Unsupported 헤더 필드

   위의 모든 경우에 요청을 새로 작성하여 다시 시도합니다.
   요청을 수정하십시오. 이 새로운 요청
   새로운 거래를 구성하며 동일한 가치를 지니고 있어야합니다.
   이전 요청의 Call-ID, To 및 From은 있지만 CSeq는
   이전 시퀀스보다 하나 더 높은 새 시퀀스 번호를 포함합니다.



Rosenberg, et. al. 표준 트랙 [45 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   아직 정의되지 않은 응답을 포함하여 다른 4xx 응답의 경우 재 시도
   방법 및 사용 사례에 따라 가능하지 않을 수도 있습니다.

8.2 UAS 동작

   대화 상자 외부의 요청이 UAS에 의해 처리되면
   메소드와 독립적으로 추적되는 처리 룰 세트.
   12 절에서는 UAS가 요청이
   대화 상자의 내부 또는 외부.

   요청 처리는 원자 적입니다. 요청이 수락되면,
   그와 관련된 모든 상태 변경 사항을 반드시 수행해야합니다. 만약에 그것이
   거부 된 경우 모든 상태 변경 사항을 수행해서는 안됩니다.

   UAS는 요청을 다음 단계의 순서대로 처리해야합니다 (SHAULD).
   이 섹션을 참조하십시오 (즉, 인증부터 시작하여
   영감
메서드, 헤더 필드 등을
   이 섹션의 나머지 부분).

8.2.1 방법 검사

   요청이 인증되면 (또는 인증을 건너 뛰면)
   UAS는 요청 방법을 검사해야합니다 (MUST). UAS가
   그러나 요청의 방법을 지원하지 않으면 반드시 405를 생성해야한다.
   (Method Not Allowed) 응답. 응답 생성 절차
   8.2.6 절에 설명되어있다. 또한 UAS는 허용을 추가해야합니다
   헤더 필드를 405 (Method Not Allowed) 응답에 추가합니다. 허용
   헤더 필드는 반드시 UAS가 지원하는 메소드 세트를 나열해야한다.
   메시지를 생성합니다. 허용 헤더 필드는
   20.5 절.

   메소드가 서버에서 지원하는 메소드 인 경우 처리가 계속됩니다.

8.2.2 헤더 검사

   UAS가 요청의 헤더 필드를 이해하지 못하는 경우 (즉,
   헤더 필드는 본 명세서 또는 임의의
   지원되는 확장자), 서버는 해당 헤더 필드를 무시해야하며
   메시지 처리를 계속합니다. UAS는 기형의 모든 것을 무시해야합니다
   헤더 필드는 요청을 처리하는 데 필요하지 않습니다.

To 및 Request-URI 8.2.2.1

   To 헤더 필드는 요청의 원래 수신자를 식별합니다.
   From 필드에서 식별 된 사용자가 지정합니다. 원래
   수령인은 요청을 처리하는 UAS 일 수도 그렇지 않을 수도 있습니다.
   착신 전환 또는 기타 프록시 작업. UAS는
   정책에 따라 요청을 수락할지 여부를 결정하려는 경우



Rosenberg, et. al. 표준 트랙 [46 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   헤더 필드는 UAS의 신원이 아닙니다. 그러나 그것은
   UAS가 인식하지 못하더라도 요청을 수락 할 것을 권장합니다.
   To 헤더 필드의 URI 스킴 (예 : tel : URI) 또는
   To 헤더 필드가 알려진 또는 현재 사용자를 주소 지정하지 않는 경우
   이 UAS. 반면에, UAS가
   요청하면, 403 (금지됨) 상태의 응답을 생성해야합니다 (SHOULD).
   코드를 생성하고 전송을 위해 서버 트랜잭션에 전달합니다.

   그러나 Request-URI는 해당 URI를 처리 할 UAS를 식별합니다.
   의뢰. Request-URI가 UAS에서 지원하지 않는 스키마를 사용하는 경우,
   416 (지원되지 않는 URI 스킴)으로 요청을 거절해야한다 (SHOULD)
   응답. Request-URI가 주소를 식별하지 못하면
   UAS는 요청을 기꺼이 받아들이므로 요청을 거절해야합니다
   404 (찾을 수 없음) 응답. 일반적으로 UA는
   REGISTER 메서드를 사용하여 해당 주소 레코드를 특정 연락처에 바인딩합니다.
   주소는 Request-URI가 해당 연락처와 동일한 요청을 볼 것입니다
   주소. 수신 된 Request-URI의 다른 잠재적 소스는 다음을 포함합니다.
   UA가 보낸 요청 및 응답의 Contact 헤더 필드
   대화 상자를 설정하거나 새로 고칩니다.

8.2.2.2 병합 된 요청

   요청에 To 헤더 필드에 태그가 없으면 UAS 코어가 반드시 MUST
   진행중인 트랜잭션에 대해 요청을 확인하십시오. From 태그,
   Call-ID 및 CSeq는 진행중인
   거래를 요청했지만 해당 요청이 해당 거래와 일치하지 않습니다 (기반
   17.2.3 절의 매칭 규칙에 따라), UAS 코어는
   482 (Loop Detected) 응답을 생성하여 서버에 전달하십시오.
   트랜잭션.

      동일한 요청이 UAS에 두 번 이상 도착했습니다.
      다른 경로, 대부분 포크로 인해 발생합니다. UAS 과정
      첫 번째 요청은 수신되어 482 (루프
      Detected)를 나머지 부분에 적용합니다.

8.2.2.3 요구 사항

   UAS가 해당 요소를 처리하기위한 적절한 요소라고 판단한다고 가정합니다.
   요청 인 경우 Require 헤더 필드가 있으면이를 검사합니다.

   요구 헤더 필드는 UAC가 SIP에 대해 UAS에 알리기 위해 사용됩니다
   UAC가 UAS에서 다음을 지원하기를 기대하는 확장
   요청을 올바르게 처리하십시오. 형식은 섹션에 설명되어 있습니다.
   20.32. UAS가 목록에있는 옵션 태그를 이해하지 못하는 경우
   요구 헤더 필드는 응답을 생성함으로써 응답해야합니다.
   상태 코드 420 (잘못된 확장). UAS는 지원되지 않는 항목을 추가해야합니다
   헤더 필드를 추가하고 이해할 수없는 옵션을 나열합니다.
   요청의 Require 헤더 필드에있는 요청들 사이.



Rosenberg, et. al. 표준 트랙 [47 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   Require와 Proxy-Require는 SIP 취소에서 사용되어서는 안된다.
   요청 또는 비 -xxxx 응답을 위해 전송 된 ACK 요청에서. 이들
   헤더 필드는 이러한 요청에 존재할 경우 무시되어야한다.

   2xx 응답을위한 ACK 요청은 오직 Require와
   프록시 - 초기 요청에 있었던 값을 필요로합니다.

   예:

      UAC-> UAS : INVITE sip : watson@bell-telephone.com SIP / 2.0
                  요구 사항 : 100rel

      UAS -> UAC : SIP / 2.0 420 잘못된 확장
                  지원되지 않음 : 100rel

      이 동작은 클라이언트 - 서버 상호 작용이
      모든 옵션이 양쪽 모두에 의해 이해 될 때 지체없이 진행하십시오.
      옵션을 이해하지 못하면 속도가 느려집니다 (
      예). 잘 일치하는 클라이언트 - 서버 쌍의 경우
      상호 작용이 신속하게 진행되어 종종 왕복을 필요로하지 않습니다.
      협상 메커니즘에 의해. 또한 모호성을 제거합니다.
      클라이언트가 서버가 지원하지 않는 기능을 요구할 때
      알다. 통화 처리 필드와 같은 일부 기능은
      최종 시스템에 대한 관심

8.2.3 내용 가공

   UAS가 클라이언트가 요구하는 확장을 이해한다고 가정하면,
   UAS는 메시지 본문과 헤더 필드를 검사합니다.
   그것을 설명하십시오. 유형이있는 본문이있는 경우 (
   Content-Type), 언어 (Content-Language로 표시) 또는
   인코딩 (Content-Encoding으로 표시)은 이해할 수 없으며,
   해당 본문 부분은 선택 사항이 아닙니다 (Content-
   Disposition header field), UAS는 요청을 415 거부해야한다.
   (지원되지 않는 미디어 유형) 응답. 응답에는 반드시
   이해할 수있는 모든 본문의 유형을 나열하는 헤더 필드를 수락하고,
   요청에 의해 지원되지 않는 유형의 본문이 포함 된 경우
   UAS. 요청에 이해할 수없는 콘텐츠 인코딩이 포함 된 경우
   UAS에 의해 응답은 Accept-Encoding 헤더 필드
   UAS가 이해하는 인코딩을 나열합니다. 요청이있는 경우
   UAS가 이해할 수없는 언어로 된
   응답은 반드시 Accept-Language 헤더 필드를 포함해야한다.
   UAS가 이해할 수있는 언어 이러한 점검 이외에도, 바디 핸들링
   방법과 유형에 따라 다릅니다. 더 자세한 정보는
   내용 - 특정 헤더 필드의 처리, 7.4 절 참조
   20.11 절부터 20.15 절까지.





Rosenberg, et. al. 표준 트랙 [52 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


8.2.4 확장 기능 적용

   생성시 확장을 적용하려는 UAS
   응답은 해당 확장에 대한 지원이
   요청의 Supported 헤더 필드에 표시됩니다. 만약
   원하는 확장자가 지원되지 않으면 서버는에 의존해야합니다
   기본 SIP 및 클라이언트가 지원하는 다른 모든 확장이 포함됩니다. 에서
   서버가 요청을 처리 할 수없는 드문 경우
   확장자가 없으면 서버는 421 (내선 번호 필요)
   응답. 이 응답은 적절한 응답이 될 수 없음을 나타냅니다.
   특정 확장 기능을 지원하지 않고 생성됩니다. 필요한 것
   확장 (들)은 요구 사항 헤더 필드에 반드시 포함되어야한다.
   응답. 이 동작은 일반적으로 권장되지 않으므로 권장하지 않습니다.
   상호 운용성을 파괴하십시오.

   421이 아닌 응답에 적용되는 확장은 반드시
   응답에 헤더 필드가 필요합니다. 물론, 서버
   지원되는 헤더 필드에 나열되지 않은 확장을
   요청. 그 결과로, Require 헤더 필드는
   응답에는 표준에 정의 된 옵션 태그 만 포함됩니다.
   RFC를 추적합니다.

8.2.5 요청 처리

   이전 소절의 모든 수표가 통과되었다고 가정하면,
   UAS 처리는 메소드에 따라 달라집니다. 섹션 10에서는
   REGISTER 요청, 섹션 11은 OPTIONS 요청, 섹션 13
   INVITE 요청을 다루고, 15 절은 BYE 요청을 다룹니다.

8.2.6 응답 생성

   UAS가 요청에 대한 응답을 구성하고자 할 때,
   일반적인 절차는 다음 하위 절에서 자세히 설명합니다.
   문제의 응답 코드와 관련된 추가 동작
   이 섹션에 상세히 설명되어 있지 않은 경우도 필요할 수 있습니다.

   응답 생성과 관련된 모든 절차가
   완료되면 UAS는 응답을 서버에 다시 전달합니다
   요청을받은 트랜잭션.

8.2.6.1 잠정 응답 보내기

   생성을위한 비 방법 별 가이드 라인
   응답은 UAS가 a에 대해 임시 응답을 발행해서는 안되며
   비 초대 요청. 오히려, UAS는 다음에 대한 최종 응답을 생성해야합니다.
   가능한 한 빨리 비 초대 요청입니다.





Rosenberg, et. al. 표준 트랙 [49 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   100 (Trying) 응답이 생성되면 모든 Timestamp 헤더 필드
   요청에있는이 항목을이 100으로 복사해야합니다 (시도 중)
   응답. 응답 생성에 지연이있는 경우 UAS
   응답의 Timestamp 값에 지연 값을 추가해야합니다 (SHOULD).
   이 값은 전송 시간과 전송 시간 사이의 차이를 포함해야합니다.
   초 단위로 측정 된 요청의 응답 및 수신.

8.2.6.2 헤더 및 태그

   응답의 보낸 사람 필드는 보낸 사람 헤더 필드와 같아야합니다.
   요청. 응답의 Call-ID 헤더 필드는
   요청의 Call-ID 헤더 필드. CSeq 헤더 필드
   응답은 요청의 CSeq 필드와 같아야합니다. 비아 헤더
   응답의 필드 값은 Via 헤더 필드 값과 동일해야합니다 (MUST).
   요청에 포함되어 있어야하며 동일한 주문을 유지해야합니다.

   요청에 요청의 To 태그가 포함 된 경우 To 헤더 필드
   응답의 요청은 요청의 응답과 동일해야합니다. 그러나 To
   요청의 헤더 필드에 태그가 없으므로 To의 URI
   응답의 헤더 필드는 To 헤더의 URI와 같아야합니다 (MUST).
   들; 또한 UAS는 To 헤더 필드에 태그를 추가해야한다.
   응답 (100 (Trying) 응답 제외)에서
   태그가 존재할 수도 있음). 이것은 UAS를 식별하는 역할을합니다.
   응답하여 대화 ID의 구성 요소가 될 수 있습니다. 그만큼
   그 요청에 대한 모든 응답에 대해 동일한 태그를 사용해야한다.
   과 임시 (다시 100 (Trying) 제외). 절차
   태그 생성은 19.3 절에 정의되어 있습니다.

8.2.7 Stateless UAS Behavior

   Stateless UAS는 트랜잭션 상태를 유지하지 않는 UAS입니다.
   그것은 요청에 정상적으로 응답하지만,
   일반적으로 응답이 전송 된 후 UAS가 보유합니다. 만약
   상태 비 저장 UAS는 요청의 재전송을 받으면 재생성합니다.
   응답을 마치 첫 번째 응답에 응답하는 것처럼 다시 보냅니다.
   요청의 인스턴스. UAS는 요청이없는 한 stateless가 될 수 없습니다.
   해당 메소드에 대한 처리는 항상 동일한 응답을 가져옵니다.
   요청이 동일하면 이는 무국적 등록자를 배제하고,
   예를 들면. Stateless UAS는 트랜잭션 계층을 사용하지 않습니다. 그들
   전송 계층에서 직접 요청을 수신하고 응답을 보냅니다.
   전송 계층에 직접 연결됩니다.

   상태 비 저장 UAS 역할은 주로 인증되지 않은
   챌린지 응답이 발행 된 요청. 만약
   인증되지 않은 요청이 상태 적으로 처리 된 다음 악의적이었습니다.
   인증되지 않은 요청의 홍수로 인해 엄청난 양의





Rosenberg, et. al. 표준은 궤도 [50 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   통화 처리를 느리게하거나 완전히 중단시킬 수있는 트랜잭션 상태
   UAS에서 효과적으로 서비스 거부 조건을 생성합니다. ...에 대한
   자세한 내용은 섹션 26.1.5를 참조하십시오.

   상태없는 UAS의 가장 중요한 동작은 다음과 같습니다.

      o 무국적자 UAS는 잠정적 (1xx) 응답을 보내면 안됩니다.

      o 무국적자 UAS는 응답을 재전송해서는 안됩니다.

      o stateless UAS는 ACK 요청을 무시해야합니다 (MUST).

      o stateless UAS는 CANCEL 요청을 무시해야합니다 (MUST).

      o 헤더 태그는 무국적 상태의 응답에 대해 생성되어야합니다
         방식으로 - 동일한 태그를 생성하는 방식으로
         일관된 동일한 요청. 태그 구성에 대한 정보는
         19.3 절을 보라.

   다른 모든 측면에서, 상태 비 저장 UAS는 다음과 같은 방식으로 작동합니다.
   상태 유지 UAS. UAS는 상태 저장 또는 상태 비 저장 방식으로 작동 할 수 있습니다.
   모드로 전환됩니다.

8.3 리디렉션 서버

   일부 아키텍처에서는 처리를 줄이는 것이 바람직 할 수 있습니다
   라우팅 요청을 담당하는 프록시 서버에로드
   리디렉션을 사용하여 신호 경로 견고성을 향상시킵니다.

   리디렉션을 통해 서버는 요청에 대한 라우팅 정보를 푸시 할 수 있습니다.
   클라이언트에 대한 응답으로 되돌아 간다.
   여전히이 트랜잭션에 대한 추가 메시징 루프
   요청의 대상을 찾습니다. 창안자가
   요청이 리다이렉션을 받으면, 리디렉션을 기반으로 새로운 요청을 보냅니다.
   수신 한 URI. 의 핵심에서 URI를 전파함으로써
   리디렉션을 통해 상당한 네트워크를 확보 할 수 있습니다.
   확장 성.

   리디렉션 서버는 논리적으로 서버 트랜잭션으로 구성됩니다.
   계층 및 위치 서비스에 대한 액세스 권한이있는 트랜잭션 사용자
   어떤 종류의 (등록 기관 및 위치에 대한 자세한 내용은 섹션 10 참조)
   서비스). 이 위치 서비스는 사실상 데이터베이스입니다
   하나의 URI와 하나 이상의 URI 집합 사이에 포함 된 매핑
   해당 URI의 대상을 찾을 수있는 대체 위치.

   리디렉션 서버는 자체 SIP 요청을 발행하지 않습니다. 후
   CANCEL 이외의 요청을 수신하면 서버는
   에서 대체 위치 목록을 요청하거나 수집합니다.



Rosenberg, et. al. 표준 트랙 [51 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   위치 서비스를 제공하고 클래스 3xx의 최종 응답을 반환합니다. 에 대한
   well-formed CANCEL 요청이면 2xx 응답을 리턴해야한다. 이
   응답은 SIP 트랜잭션을 종료합니다. 리디렉션 서버는
   전체 SIP 트랜잭션에 대한 트랜잭션 상태. 그것은
   리다이렉트간에 포워딩 루프를 탐지하는 클라이언트의 책임
   서버.

   리디렉션 서버가 요청에 대한 3xx 응답을 반환하면
   (하나 이상의) 대체 위치 목록을
   헤더 필드에 문의하십시오. 연락처 헤더에 "만료"매개 변수
   필드 값은 또한 필드의 수명을 나타 내기 위해 제공 될 수 있습니다.
   연락처 데이터.

   Contact 헤더 필드는 새로운 위치를 제공하는 URI를 포함하거나
   사용자 이름을 시도하거나 단순히 추가 전송을 지정할 수 있습니다.
   매개 변수. A 301 (영구 이사) 또는 302 (임시 이사)
   응답을 통해 동일한 위치와 사용자 이름을 제공 할 수도 있습니다.
   최초 요청을 목표로하지만 추가 전송을 지정합니다.
   시도 할 다른 서버 또는 멀티 캐스트 주소와 같은 매개 변수 또는
   UDP에서 TCP로 또는 그 반대로 SIP 전송이 변경되었습니다.

   그러나 리디렉션 서버는 요청을 URI와 동일한 것으로 리디렉션해서는 안됩니다
   Request-URI의 URI로; 대신에 URI가 제공한다면
   자체를 가리 키지 않는다면, 서버는 요청을
   목적지 URI를 사용하거나 404와 함께 거부 할 수있다.

      클라이언트가 아웃 바운드 프록시를 사용하고 해당 프록시를 실제로 사용하는 경우
      요청을 리디렉션합니다. 무한 리디렉션의 잠재 성이 있습니다.
      루프.

   Contact 헤더 필드 값은 다른
   리소스가 원래 호출 된 것보다 큽니다. 예를 들어, SIP 호출
   PSTN 게이트웨이에 연결하면 특별한 정보를 제공해야 할 수도 있습니다
   "당신이 다이얼 한 번호가 바뀌 었습니다."와 같은 발표.

   연락처 응답 헤더 필드는 적절한 URI를 포함 할 수 있습니다
   SIP에 국한되지 않고 수신자가 도달 할 수있는 위치를 나타냅니다.
   URI. 예를 들어, 전화, 팩스 또는 irc에 대한 URI를 포함 할 수 있습니다 (if
   그들은 정의되었다) 또는 mailto : (RFC 2368 [32]) URL. 섹션 26.4.4
   SIPS URI를 SIP로 리디렉션 할 때의 영향과 제한 사항에 대해 설명합니다.
   non-SIPS URI.

   Contact 헤더 필드 값의 "expires"매개 변수는
   URI가 유효한 지 오래입니다. 매개 변수의 값은 숫자입니다.
   초를 나타냅니다. 이 매개 변수를 제공하지 않으면
   Expires 헤더 필드는 URI의 유효 기간을 결정합니다.
   조작 된 값은 3600과 동일하게 취급되어야합니다 (SHOULD).




Rosenberg, et. al. 표준 트랙 [52 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      이것은 RFC와의 하위 호환성을 제공합니다
      2543,이 헤더 필드에서 절대 시간을 허용했습니다. 만약
      절대 시간이 수신되면 형식이 잘못된 것으로 처리되고
      기본값은 3600입니다.

   리디렉션 서버는 이해할 수없는 기능을 무시해야합니다 (MUST).
   (알 수없는 헤더 필드, 알 수없는 옵션 태그 포함
   Require 또는 심지어 메소드 이름)을 리디렉션하고
   문제의 요청.

9 요청 취소

   이전 섹션에서는 생성을위한 일반적인 UA 동작에 대해 논의했습니다.
   모든 메소드의 요청에 대한 응답 및 요청을 처리합니다. 에서
   이 섹션에서는 CANCEL이라는 범용 메서드에 대해 설명합니다.

   CANCEL 요청은 이름에서 알 수 있듯이 이전의
   요청을 클라이언트가 보냈습니다. 특히 UAS에 중단을 요청합니다.
   요청을 처리하고 그 요청에 대한 오류 응답을 생성합니다.
   의뢰. CANCEL은 UAS가 요청한 요청에 영향을 미치지 않습니다.
   이미 최종 응답을 받았다. 이 때문에 가장 유용합니다.
   서버를 오래 동안 사용할 수있는 CANCEL 요청
   응창 성가. 이러한 이유로 CANCEL은 INVITE 요청에 가장 적합합니다.
   응답을 생성하는 데 오랜 시간이 걸릴 수 있습니다. 그 사용법에서, UAS
   INVITE에 대한 CANCEL 요청을 받았지만 아직 INVITE 요청을 보내지 않은
   최종 응답, "벨소리 중지"및 다음 INVITE에 응답합니다.
   특정 오류 응답 (a 487).

   CANCEL 요청은 프록시와 사용자 모두에 의해 생성되고 전송 될 수 있습니다.
   에이전트 클라이언트. 섹션 15에서는 어떤 조건에서 UAC
   INVITE 요청을 취소하고, 16.10 절에서 프록시
   CANCEL 사용.

   상태 저장 프록시는 단순히 전달하는 대신 CANCEL에 응답합니다.
   다운 스트림 요소로부터 수신 할 응답. 그에 대한
   이유는 CANCEL을 "hop-by-hop"요청이라고합니다.
   각 상태 별 프록시 홉에서 응답했습니다.

9.1 클라이언트 행동

   CANCEL 요청은 다른 요청을 취소하기 위해 전송되어서는 안된다 (SHOULD NOT).
   초대.

      INVITE 이외의 요청은 즉시 응답되므로,
      비 호출 요청에 대한 CANCEL을 보내면 항상
      경쟁 조건.





Rosenberg, et. al. 표준 트랙 [53 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   다음 절차는 CANCEL 요청을 구성하는 데 사용됩니다. 그만큼
   Request-URI, Call-ID, To, CSeq의 숫자 부분 및 From 헤더
   CANCEL 요청의 필드는 반드시 해당 필드의 필드와 동일해야합니다.
   태그를 포함하여 취소 요청. 에 의해 생성 된 취소
   클라이언트는 반드시 하나의 Via 헤더 필드 값과 일치해야합니다.
   top 취소되는 요청의 값을 통해. 동일한 값 사용
   이 헤더 필드에 대해 CANCEL을
   취소 요청 (9.2 절은 그러한 일치가 어떻게 발생하는지 나타냅니다).
   그러나 CSeq 헤더 필드의 메소드 부분은 반드시 값을 가져야한다.
   CANCEL의 이를 통해 식별되고 처리 될 수 있습니다.
   (17 절 참조).

   취소 된 요청에 Route 헤더 필드가 포함되어 있으면
   CANCEL 요청은 해당 Route 헤더 필드의 값을 포함해야합니다.

      상태없는 프록시가 CANCEL을 라우트 할 수 있도록하려면이 작업이 필요합니다.
      요청이 올바로 처리됩니다.

   CANCEL 요청에는 Require 또는 Proxy-Require를 포함해서는 안됩니다
   헤더 필드.

   CANCEL이 구성되면, 클라이언트는 그것을 취소해야하는지
   요청에 대한 응답 (임시 또는 최종)을 받았습니다.
   (이하 "원본 요청"이라고 함).

   잠정적 인 응답이 수신되지 않은 경우 CANCEL 요청은 반드시
   보내지 마라. 오히려 클라이언트는 클라이언트의 도착을 기다려야합니다.
   요청을 보내기 전에 임시 응답. 원본
   요청이 최종 응답을 생성하면 CANCEL NOT NOT
   CANCEL은 아무런 효과가 없으므로 효과가없는 no-op이므로 전송됩니다.
   이미 최종 응답을 생성 한 요청 때
   클라이언트가 CANCEL을 전송하기로 결정하면 클라이언트 트랜잭션이 생성됩니다.
   CANCEL은 CANCEL 요청과 함께 CANCEL 요청을 전달합니다.
   목적지 주소, 포트 및 전송. 목적지 주소,
   포트 및 운송은 CANCEL의 용도와 동일해야합니다.
   원래 요청을 보냅니다.

      응답을 받기 전에 CANCEL을 전송하도록 허용 된 경우
      이전 요청에 대해 서버는 CANCEL을 수신 할 수 있습니다
      원래 요청 전에

   원래 요청에 해당하는 트랜잭션
   CANCEL 트랜잭션은 독립적으로 완료됩니다. 그러나,
   요청을 취소하는 UAC는 487 (요청
   Terminated) 응답을 RFC 2543-
   호환 UAS는 그러한 응답을 생성하지 않습니다. 없다면
   64 * T1 초 (T1은 원래 요청에 대한 최종 응답)




Rosenberg, et. al. 표준 트랙 [54 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   17.1.1.1 절에서 정의 된) 클라이언트는 다음을 고려해야한다.
   원래 거래가 취소되었으며 클라이언트를 파기해야합니다.
   원래 요청을 처리하는 트랜잭션.

9.2 서버 동작

   CANCEL 메소드는 서버 측의 TU가
   보류중인 거래. TU는 거래를 결정합니다.
   CANCEL 요청을 취하여 취소 한 다음
   요청 방법은 CANCEL 또는 ACK 이외의 것이고
   17.2.3 절의 트랜잭션 매칭 절차. 일치하는
   거래가 취소됩니다.

   서버에서 CANCEL 요청 처리는 다음 유형에 따라 다릅니다.
   섬기는 사람. 상태없는 프록시가 전달할 것이고, 상태 저장 프록시는
   그것에 응답하고 자체 CANCEL 요청을 생성하고, UAS
   그것에 응답 할 것이다. CANCEL의 대리 처리에 대해서는 16.10 절을 참조하십시오.

   UAS는 먼저 일반적인 UAS에 따라 CANCEL 요청을 처리합니다
   처리는 섹션 8.2에서 설명합니다. 그러나 CANCEL 요청
   홉 - 바이 - 홉 (hop-by-hop)이고 다시 제출할 수 없으며, 도전을받을 수 없다.
   Authorization에서 적절한 자격 증명을 얻기 위해 서버에서
   헤더 필드. CANCEL 요청에는
   헤더 필드 필요.

   UAS가 CANCEL에 대해 일치하는 트랜잭션을 찾지 못한 경우
   위의 절차에 따라, 그것은 CANCEL에 응답해야한다.
   481 (콜 레그 / 거래가 존재하지 않음). 거래가
   원래 요청이 여전히 존재하기 때문에 UAS의 동작은
   CANCEL 요청 수신은 이미 CANCEL 요청을 보냈는지 여부에 달려 있습니다.
   원래 요청에 대한 최종 응답. 있는 경우 CANCEL
   요청은 원래 요청 처리에 영향을주지 않습니다.
   모든 세션 상태에 영향을 미치고 생성 된 응답에는 영향을 미치지 않습니다.
   원래 요청에 대해. UAS가 최종 응답을 발행하지 않은 경우
   원래 요청의 경우 해당 동작은
   원래 요청. 원래 요청이 INVITE 인 경우 UAS
   INVITE에 487 (요청
   종료 됨). CANCEL 요청은 처리에 영향을 미치지 않습니다.
   이 명세서에 정의 된 다른 방법과의 거래.

   원래 요청 방법에 관계없이
   CANCEL이 기존 트랜잭션과 일치하면 UAS가 CANCEL에 응답합니다.
   200 (OK) 응답으로 자체 요청. 이 응답은
   8.2.6 절에 설명 된 절차에 따라 구축
   CANCEL 및 To 태그에 대한 응답의 To 태그
   원래 요청에 대한 응답으로 동일해야합니다. 그만큼
   CANCEL에 대한 응답이 다음에 대한 서버 트랜잭션으로 전달됩니다.
   전달.



Rosenberg, et. al. 표준 트랙 [55 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


10 등록

10.1 개요

   SIP는 검색 기능을 제공합니다. 사용자가
   세션을 다른 사용자와 공유하려면 SIP는에서 현재 호스트를 발견해야합니다.
   대상 사용자에게 도달 할 수 있습니다. 이 발견 프로세스는
   프록시 서버와 같은 SIP 네트워크 요소에 의해 자주 수행됩니다.
   요청 수신을 담당하는 서버를 리디렉션하고,
   위치 정보를 기반으로 어디로 보낼지 결정
   사용자에게 보낸 다음 거기에 보내십시오. 이렇게하려면 SIP 네트워크
   요소는 위치 서비스라고 알려진 추상적 인 서비스를 참조하며,
   특정 도메인에 대한 주소 바인딩을 제공합니다. 이들
   주소 바인딩은 들어오는 SIP 또는 SIPS URI (sip : bob@biloxi.com)를 매핑합니다.
   예를 들어 URI에 "가까이"있는 하나 이상의 URI
   원하는 사용자, 모금 : bob@engineering.biloxi.com.
   궁극적으로 프록시는 위치 서비스를 참조하여
   원하는 수신자가있는 사용자 에이전트 (들)에게 수신 된 URI
   현재 거주하고 있습니다.

   등록은 특정 위치 서비스의 바인딩을 만듭니다.
   주소 레코드 URI를 하나 이상의 URI와 연관시키는 도메인
   연락처 주소. 따라서 해당 도메인의 프록시가
   Request-URI가 address-of-record와 일치하는 요청, proxy
   등록 된 연락처 주소로 요청을 전달합니다.
   주소 기록. 일반적으로,
   에 대한 요청이있을 때 도메인의 위치 서비스에서 레코드 주소
   해당 주소 기록은 해당 도메인으로 라우팅됩니다. 대부분
   이 경우 등록의 도메인이
   주소 레코드의 URI에있는 도메인과 일치해야합니다.

   위치 서비스의 내용이 여러 가지 방법으로
   설립된다. 한 가지 방법은 관리 차원입니다. 위의 예에서,
   Bob은 엔지니어링 부서의 구성원으로 알려져 있습니다.
   기업 데이터베이스에 대한 액세스. 그러나 SIP는 메커니즘을 제공합니다.
   UA가 명시 적으로 바인딩을 생성합니다. 이 메커니즘은 다음과 같이 알려져있다.
   기재.

   등록은 특별한 유형의 REGISTER 요청을 보내는 것을 수반한다.
   등록 기관으로 알려진 UAS. 레지스트라는 프런트 엔드 역할을합니다.
   도메인에 대한 위치 서비스, 다음에 기반한 매핑 읽기 및 쓰기
   REGISTER 요청의 내용 이 위치 서비스는
   일반적으로 라우팅을 담당하는 프록시 서버가 참조합니다.
   해당 도메인에 대한 요청

   전반적인 등록 절차에 대한 설명은
   그림 2. 레지스트라 및 프록시 서버는 논리적 인 역할입니다.
   네트워크에서 단일 장치로 재생할 수 있습니다. 목적을 위해



Rosenberg, et. al. 표준 트랙 [52 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   명확성 두 그림은이 그림에서 분리되어 있습니다. 또한 유의하십시오.
   UA는 프록시 서버를 통해 요청을 보내서
   레지스트라가 두 요소가 분리 된 요소 인 경우

   SIP는 특정 기능을 구현하기위한 특정 메커니즘을 요구하지 않습니다.
   위치 서비스. 유일한 요구 사항은 일부의 등록 기관
   도메인은 위치 서비스에 데이터를 읽고 쓸 수 있어야하며,
   해당 도메인에 대한 프록시 또는 리디렉션 서버는 다음을 수행 할 수 있어야합니다.
   그 같은 데이터를 읽는 것. 등록 기관은
   동일한 도메인의 특정 SIP 프록시 서버

10.2 REGISTER 요청 생성하기

   REGISTER 요청은 바인딩을 추가, 제거 및 쿼리합니다. 등록기
   요청은 주소 레코드와 하나 이상의 레코드 사이에 새로운 바인딩을 추가 할 수 있습니다.
   더 많은 연락처. 특정 업체를 대신하여 등록
   기록 주소는 적절하게 승인 된 제 3 자에 의해 수행 될 수있다.
   파티. 클라이언트는 이전 바인딩 또는 쿼리를 제거 할 수도 있습니다.
   현재 어떤 바인딩이 Address-of-
   기록.

   명시된 경우를 제외하고는 REGISTER 요청 및
   REGISTER 요청을 보내는 클라이언트의 동작은
   섹션 8.1과 섹션 17.1에서 설명 된 일반적인 UAC 동작.

   REGISTER 요청은 대화 상자를 설정하지 않습니다. UAC는
   선재에 기반한 REGISTER 요청의 Route 헤더 필드
   경로 설정은 섹션 8.1에서 설명합니다. Record-Route 헤더 필드
   REGISTER 요청이나 응답에 의미가 없으므로 무시해야합니다.
   있을 경우. 특히 UAC는 새로운 라우트 집합을 생성해서는 안됩니다
   에서 Record-Route 헤더 필드의 유무에 기반하여
   REGISTER 요청에 대한 응답.

   연락처를 제외한 다음 헤더 입력란은
   REGISTER 요청. 연락처 헤더 필드가 포함될 수 있습니다 (MAY) :

      Request-URI : Request-URI는 위치의 도메인 이름을 지정합니다.
           서비스가 등록을 의미합니다 (예 :
           "sip : chicago.com"). 의 "userinfo"및 "@"구성 요소는
           SIP URI가 없어야합니다 (MUST NOT).

      To : To 헤더 필드는 레코드의 주소를 포함합니다.
           등록을 작성하거나 질의하거나 수정할 수 있습니다. 받는 사람
           헤더 필드와 Request-URI 필드는 일반적으로 다음과 같이 다릅니다.
           전자는 사용자 이름을 포함합니다. 이 주소 기록은 반드시
           SIP URI 또는 ​​SIPS URI 여야합니다.





Rosenberg, et. al. 표준 트랙 [57 페이지]

RFC 3261
SIP : 세션 개시 프로토콜 2002 년 6 월


      보낸 사람 : 보낸 사람 머리글 필드에는
           등록 책임자. 값은
           요청이 제 3 자 요청이 아니면 To 헤더 필드와 동일
           정당 등록.

      Call-ID : UAC의 모든 등록은 동일한 Call-ID를 사용해야한다.
           특정의 것에 송신 된 등록에 대한 헤더 필드 치
           기록 사무관.

           동일한 클라이언트가 다른 Call-ID 값을 사용한다면,
           레지스트라는 지연된 REGISTER 요청의 여부를 감지 할 수 없습니다.
           순서가 맞지 않을 수 있습니다.

      CSeq : CSeq 값은 REGISTER의 적절한 순서를 보장합니다.
           요청. UA는 각각에 대해 CSeq 값을 1 씩 증가시켜야한다.
           같은 Call-ID를 가진 REGISTER 요청.

      연락처 : REGISTER 요청에 Contact 헤더 필드가 포함될 수 있습니다.
           주소 바인딩을 포함하는 0 개 이상의 값.

   UA는 새 등록을 보내지 않아야합니다 (즉, 새 연락처를 포함해야 함)
   헤더 필드 값, 재전송과 반대)
   이전 등록 기관의 등록 기관으로부터 최종 응답을 받거나
   이전 REGISTER 요청 시간이 초과되었습니다.



























Rosenberg, et. al. 표준은 궤도 [58 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


                                                 단발
                                               + ---- +
                                               | UA |
                                               | |
                                               + ---- +
                                                  |
                                                  | 3) 초대
                                                  | carol@chicago.com
         chicago.com + -------- + V
         + --------- + 2) 상점 | 위치 | 4) Query + ----- +
         | 등록 기관 | =======> | 서비스 | <======= | 프록시 | sip.chicago.com
         + --------- + + -------- + =======> + ----- +
               A 5) Resp |
               | |
               | |
     1) 등록 | |
               | |
            + ---- + |
            | UA | <------------------------------- +
   cube2214a | | 6) 초대
            + ---- + carol@cube2214a.chicago.com
             축가

                      그림 2 : REGISTER 예제

      다음 Contact 헤더 매개 변수는
           REGISTER 요청 :

      조치 : RFC 2543의 "조치"매개 변수가 사용되지 않습니다.
           UAC는 "action"매개 변수를 사용하지 않아야합니다 (SHAULD).

      만료 : "만료"매개 변수는 UA가
           바인딩은 유효합니다. 값은 숫자입니다.
           초를 나타냅니다. 이 매개 변수가 제공되지 않으면
           Expires 헤더 필드의 값이 대신 사용됩니다.
           구현은 2 ** 32-1보다 큰 값을 처리 할 수있다.
           (4294967295 초 또는 136 년)를 2 ** 32-1과 동일하게 계산합니다.
           조작 된 값은 3600과 동일하게 취급되어야합니다 (SHOULD).

10.2.1 바인딩 추가

   레지스트라에 전송 된 REGISTER 요청에는 연락처가 포함됩니다.
   address-of-record에 대한 SIP 요청이 있어야하는 주소
   전달. 주소 레코드는 To 헤더 필드에 포함됩니다.
   REGISTER 요청의






Rosenberg, et. al. 표준 트랙 [59 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   요청의 Contact 헤더 필드 값은 일반적으로
   특정 SIP 끝점을 식별하는 SIP 또는 SIPS URI (예 :
   "sip : carol@cube2214a.chicago.com"), URI 스키마를 사용할 수 있습니다.
   SIP UA는 전화 번호를 등록하도록 선택할 수 있습니다 (tel URL,
   RFC 2806 [9]) 또는 전자 메일 주소 (mailto URL, RFC 2368 [32] 포함)
   예를 들어, 주소 레코드의 연락처.

   예를 들어 캐롤은 주소 레코드 "sip : carol@chicago.com"과 함께,
   도메인 chicago.com의 SIP 등록 기관에 등록합니다. 그녀
   등록은 chicago.com의 프록시 서버에서 사용됩니다.
   도메인에서 Carol의 주소 레코드 요청을 SIP로 라우팅합니다.
   엔드 포인트.

   일단 클라이언트가 등록 기관에서 바인딩을 설정하면,
   새로운 바인딩 또는 수정 사항이 포함 된 후속 등록
   기존 바인딩을 필요에 따라 REGISTER에 대한 2xx 응답
   요청은 Contact 헤더 필드에 다음의 전체 목록을 포함합니다.
   이 주소 레코드에 대해이 위치에 등록 된 바인딩
   기록 사무관.

   REGISTER 요청의 To 헤더 필드에있는 레코드의 주소
   SIPS URI이면 요청의 모든 Contact 헤더 필드 값
   또한 SIPS URI이어야한다. 클라이언트는 비 SIPS URI 만 등록해야합니다.
   SIPS 주소 레코드 (address-of-record) 하에서 자원의 보안
   연락처 주소로 표시된 다른 주소는 다른 방법으로 보장됩니다.
   이것은 SIP 이외의 프로토콜을 호출하는 URI에 적용 할 수 있습니다.
   또는 TLS 이외의 프로토콜로 보호되는 SIP 장치.

   등록은 모든 바인딩을 업데이트 할 필요가 없습니다. 일반적으로 UA
   자체 연락처 주소 만 업데이트합니다.

10.2.1.1 연락처 주소의 만료 간격 설정

   클라이언트가 REGISTER 요청을 보내면 만료를 제안 할 수있다.
   클라이언트가 원하는 기간을 나타내는 간격
   유효한 등록. (10.3 절에서 설명했듯이,
   레지스트라는 지역에 따라 실제 시간 간격을 선택합니다.
   정책.)

   클라이언트가 만료를 제안 할 수있는 두 가지 방법이 있습니다.
   바인딩을위한 간격 : Expires 헤더 필드 또는
   "만료"연락처 헤더 매개 변수. 후자는 만료를 허용합니다.
   하나 이상의 바인딩이있을 때 바인딩 기준으로 제안되는 간격
   바인딩은 단일 REGISTER 요청에 제공되는 반면, 전자
   모든 연락처 헤더 필드 값의 만료 간격을 제안합니다.
   "만료"매개 변수를 포함하지 않습니다.





Rosenberg, et. al. 표준 Track [Page 60]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   제안 된 만료 시간을 나타내는 메커니즘이
   REGISTER에있는 현재 클라이언트는
   선택할 서버.

10.2.1.2 연락처 주소 간의 환경 설정

   하나 이상의 연락처가 REGISTER 요청으로 전송되면
   UA를 등록하면이 연락처에있는 모든 URI를 연관 시키려합니다.
   받는 사람 필드에있는 레코드 주소가있는 머리글 필드 값
   들. 이 목록의 우선 순위는 "q"매개 변수로 지정할 수 있습니다.
   헤더 필드에 문의하십시오. "q"매개 변수는 상대를 나타냅니다.
   특정 Contact 헤더 필드 값에 대한 우선 순위
   이 주소 레코드에 대한 다른 바인딩. 16.6 절
   프록시 서버가이 기본 설정 표시를 사용하는 방법.

10.2.2 바인딩 제거

   등록은 소프트 상태이며 새로 고침하지 않으면 만료됩니다.
   또한 명시 적으로 제거 할 수 있습니다. 클라이언트는
   섹션에서 설명한대로 레지스트라가 선택한 만료 간격
   10.2.1. UA는 다음에 의한 바인딩의 즉각적인 제거를 요구한다.
   해당 연락처 주소의 만료 간격을 "0"으로 지정
   REGISTER 요청. UA는이 메커니즘을 지원해야한다.
   만료 간격이 경과되기 전에 바인딩을 제거 할 수 있습니다.

   REGISTER 특정 Contact 헤더 필드 값 "*"는 다음에 적용됩니다.
   모든 등록은 유효하지만 Expires 헤더가 사용되지 않으면 절대로 사용해서는 안된다.
   필드의 값은 "0"입니다.

      "*"Contact 헤더 필드 값을 사용하면 UA를 등록 할 수 있습니다
      주소 레코드와 관련된 모든 바인딩을 제거하는 방법
      그들의 정확한 가치를 모른 채.

10.2.3 바인딩 가져 오기

   REGISTER 요청에 대한 성공 응답은 전체 목록을 포함합니다.
   기존 바인딩의
   헤더 필드에 문의하십시오. Contact 헤더 필드가없는 경우
   REGISTER 요청의 경우 바인딩 목록은 변경되지 않습니다.

10.2.4 바인딩 새로 고침

   각 UA는 자신이 가지고있는 바인딩을 새로 고침 할 책임이 있습니다.
   이전에 설립되었습니다. UA는 다음에 의해 설정된 바인딩을 새로 고쳐서는 안된다.
   다른 UA.






Rosenberg, et. al. 표준 트랙 [쪽 61]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   등록 기관의 200 (OK) 응답에는 연락처 목록이 들어 있습니다.
   모든 현재 바인딩을 열거하는 필드 UA는 각
   연락처 주소를 생성했는지 확인하려면
   19.1.4 절의 비교 규칙 그렇다면 만료를 갱신합니다.
   expires 매개 변수에 따라 시간 간격을 지정하거나, 없으면
   필드 값을 만료시킵니다. 그런 다음 UA는 각각에 대해 REGISTER 요청을 발행합니다
   만료 간격이 경과하기 전에 바인딩의 그것은 5 월
   여러 개의 업데이트를 하나의 REGISTER 요청으로 결합합니다.

   UA는 a 동안 모든 등록에 동일한 Call-ID를 사용해야한다.
   단일 부팅주기. 등록 새로 고침은 동일한 것으로 보내 져야합니다 (SHOULD).
   리디렉션되지 않는 한 원래 등록으로 네트워크 주소.

10.2.5 내부 클럭 설정

   REGISTER 요청에 대한 응답에 Date 헤더 필드가 포함 된 경우,
   클라이언트는이 헤더 필드를 사용하여 현재 시간을 알 수있다.
   내부 클럭을 설정하십시오.

10.2.6 등록 기관 발견

   UA는 세 가지 방법을 사용하여 보낼 주소를 결정할 수 있습니다
   등록 : 구성 별, 주소 레코드 사용 및
   멀티 캐스트. UA는이 범위를 벗어나는 방법으로 구성 할 수 있습니다.
   사양을 등록자 주소와 함께 사용합니다. 구성된 구성이없는 경우
   레지스트라 주소 인 경우, UA는 주소 -
   Request-URI로 레코드 중 하나를 선택하고
   일반적인 SIP 서버 위치 결정 메커니즘 [4]. 예를 들어, UA는
   사용자 "sip : carol@chicago.com"은 (는) REGISTER 요청을 처리합니다.
   "sip : chicago.com".

   마지막으로 멀티 캐스트를 사용하도록 UA를 구성 할 수 있습니다. 멀티 캐스트
   등록은 잘 알려진 "모든 SIP 서버"
   멀티 캐스트 주소 "sip.mcast.net"(IPv4의 경우 224.0.1.75). 아니,
   알려진 IPv6 멀티 캐스트 주소가 할당되었습니다. 그러한 할당
   필요한 경우 별도로 문서화됩니다. SIP UA는들을 수 있습니다.
   그 주소와 그것을 사용하여 다른 사람의 위치를 ​​알게된다.
   로컬 사용자 ([33] 참조); 그러나 요청에 응답하지 않습니다.

      멀티 캐스트 등록은 일부 환경에서는 부적절 할 수 있습니다.
      예를 들어 여러 비즈니스가 동일한 지역을 공유하는 경우
      네트워크.

10.2.7 요청 전송

   일단 REGISTER 메소드가 구축되고
   식별 된 메시지, UAC는 다음에 설명 된 절차를 따릅니다.
   거래 계층에 REGISTER를 넘기기 위해 섹션 8.1.2.



Rosenberg, et. al. 표준은 궤 [62 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   REGISTER 때문에 트랜잭션 계층이 시간 초과 오류를 반환하면
   응답을하지 않았 으면, UAC는 즉시 a를 재 시도하지 않아야한다.
   동일한 등록 기관에 등록해야합니다.

      즉각적인 재 시도가 또한 타임 아웃 될 가능성이 있습니다. 약간 기다리는 중이다.
      제한 시간을 초래하는 조건에 대한 합리적인 시간 간격
      네트워크상의 불필요한로드를 줄입니다. 특정 없음
      간격은 필수입니다.

10.2.8 오류 응답

   UA가 423 (Interval Too Brief) 응답을 받으면 재 시도 할 수있다.
   모든 연락처의 만료 간격을두고 등록
   REGISTER 요청의 주소가
   423의 최소 만료 헤더 필드 내의 만료 간격
   (Interval Too Brief) 응답.

10.3 REGISTER 요청 처리

   레지스트라는 REGISTER 요청에 응답하고 유지 관리하는 UAS입니다.
   프록시 서버에 액세스 할 수 있고 리디렉션하는 바인딩 목록
   관리 도메인 내의 서버. 등록 기관이 처리한다.
   섹션 8.2 및 섹션 17.2에 따라 요청하지만 받아들입니다.
   REGISTER 요청 만. 등록 기관은 6xx 응답을 생성해서는 안됩니다 (MUST NOT).

   레지스트라는 적절한 REGISTER 요청을 재전송 할 수있다. 하나
   일반적인 사용법은 멀티 캐스트를 수신하는 등록자를위한 것입니다.
   멀티 캐스트 REGISTER 요청을 자체 유니 캐스트로 리디렉션하는 인터페이스
   302 (Moved Temporarily) 응답과의 인터페이스

   레지스트라는 Record-Route 헤더 필드를 무시해야합니다 (MUST).
   REGISTER 요청에 포함됩니다. 등록 기관은
   Record-Route 헤더 필드는 REGISTER 요청에 대한 모든 응답에 포함됩니다.

      레지스트라는 프록시를 통과 한 요청을 수신 할 수 있습니다.
      REGISTER를 알 수없는 요청으로 처리하고 Record-
      라우트 헤더 필드 값.

   레지스트라는 설정을 통해 (예를 들어 구성을 통해) 세트를 알아야합니다
   도메인이 바인딩을 유지 관리합니다. 등록 요청은 반드시
   등록 기관이 접수 한 순서대로 처리해야합니다.
   REGISTER 요청은 반드시 원자 적으로 처리되어야합니다. 즉,
   특정 REGISTER 요청이 완전히 처리되었거나 처리되지 않았습니다.
   모든. 각 REGISTER 메시지는 반드시 독립적으로 처리되어야한다.
   기타 등록 또는 바인딩 변경.






Rosenberg, et. al. 표준은 궤 [69 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   REGISTER 요청을 수신하면 등록 기관은 다음 단계를 수행합니다.

      1. 등록 기관은 Request-URI를 검사하여 요청 URI가
         에서 식별 된 도메인의 바인딩에 액세스 할 수 있습니다.
         요청 URI. 그렇지 않은 경우 및 서버가 프록시 역할도하는 경우
         서버는 요청 된 주소로 요청을 전달해야한다.
         도메인, 메시지 프록 싱의 일반적인 동작에 따라
         16 절에서 설명했다.

      2. 등록 기관이 필요한 모든 것을 지원하는지 확인하십시오.
         등록 기관은 Require 헤더 필드를 처리해야합니다 (MUST).
         8.2.2 절의 UAS에 설명 된 값.

      3. 레지스트라는 UAC를 인증해야합니다 (SHOULD). 의 메커니즘
         SIP 사용자 에이전트의 인증은 22 절에서 설명한다.
         등록 동작이 제네릭보다 우선 적용되지 않음
         SIP 용 인증 프레임 워크. 인증이없는 경우
         메커니즘이 사용 가능하다면, 등록 기관은 보낸 사람 주소
         요청의 발신자의 주장 된 신원으로

      4. 등록자는 인증 된 사용자가 있는지 결정해야합니다 (SHOULD).
         이 주소 기록에 대한 등록을 수정할 권한이 있습니다.
         예를 들어, 등록 기관이 승인을 참조 할 수 있습니다.
         사용자 이름을 레코드 주소 목록에 매핑하는 데이터베이스
         그 사용자는 바인딩을 수정할 권한이 있습니다. 만약
         인증 된 사용자는 바인딩을 수정할 권한이 없으며,
         등록 기관은 403 (금지됨)을 반환하고
         나머지 단계.

         타사 등록을 지원하는 아키텍처에서
         엔티티는 등록을 업데이트 할 책임이 있습니다.
         여러 개의 주소 레코드와 연관됩니다.

      5. 레지스트라가 To 헤더에서 레코드 주소를 추출합니다
         필드. 주소 레코드가 유효하지 않은 경우
         Request-URI의 도메인에 대해 레지스트라는
         404 (찾을 수 없음) 응답을 보내고 나머지 단계는 건너 뜁니다. URI
         그 다음 표준 형식으로 변환해야합니다. 그렇게하기 위해, 모두
         URI 매개 변수는 (사용자 매개 변수를 포함하여) 제거되어야하며,
         이스케이프 된 문자는 이스케이프 처리되지 않은 문자로 변환되어야합니다.
         형태. 결과는 바인딩 목록에 대한 인덱스 역할을합니다.










Rosenberg, et. al. 표준은 궤도 [64 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      6. 등록 기관이 요청에 Contact가 포함되어 있는지 확인합니다
         헤더 필드. 그렇지 않으면 마지막 단계로 건너 뜁니다. 만약
         연락처 헤더 필드가 존재하면 레지스트라는
         특수 값 "*"을 포함하는 하나의 연락처 필드 값입니다.
         만료 필드가 있습니다. 요청에 추가 연락처가있는 경우
         필드 또는 만료 시간이 0이 아닌 경우 요청은 다음과 같습니다.
         유효하지 않으며 서버는 400 (잘못된 요청)을 반환해야하며
         나머지 단계는 건너 뜁니다. 그렇지 않은 경우 등록 기관은
         Call-ID는 각 바인딩에 대해 저장된 값과 일치합니다. 만약
         그렇지 않으면 바인딩을 제거해야합니다. 그것이 동의하면 반드시 동의해야한다.
         요청의 CSeq가 더 높은 경우에만 바인딩을 제거합니다.
         해당 바인딩에 대해 저장된 값보다 그렇지 않으면 업데이트
         반드시 중단되어야하며 요청은 실패합니다.

      7. 레지스트라가 이제 연락처의 각 연락처 주소를 처리합니다.
         헤더 필드. 각 주소에 대해
         만료 간격은 다음과 같습니다.

         - 필드 값에 "expires"매개 변수가 있으면 해당 값
            요청 된 만료 값으로 받아 들여야합니다.

         - 그러한 매개 변수가 없지만 요청에
            Expires 헤더 필드는 그 값을
            만료를 요청했습니다.

         - 둘 다 없으면 로컬로 구성된 기본값을 사용해야합니다 (MUST).
            요청 된 만료 날짜로 간주됩니다.

         등록 기관은 요청한 것보다 적은 만기를 선택할 수있다 (MAY)
         만료 간격. 요청 된 만료일 인 경우에만
         간격이 0보다 크고 1 시간보다 작음 AND
         등록 기관이 구성한 최소 금액보다 적은 경우, 등록 기관 MAY
         423의 응답으로 등록을 거부하십시오 (Interval Too
         간결한). 이 응답은 최소 만료 헤더 필드를 포함해야합니다
         레지스트라가 만료되는 최소 만료 간격
         기꺼이 기꺼이 그런 다음 나머지 단계를 건너 뜁니다.

         레지스트라가 등록 간격을 설정하도록 허용
         지나치게 자주 등록 새로 고침으로부터 보호
         유지할 필요가있는 상태를 제한하고
         등록이 고갈 될 가능성을 줄입니다. 그만큼
         등록의 만료 간격은
         서비스 창출. 예를 들어 Follow-me 서비스가 있습니다.
         사용자는 브리핑을 위해 터미널에서만 사용할 수 있습니다.
         기간. 따라서 등록 기관은 브리핑
         등록; 요청이 거부 된 경우에만 요청을 거부해야합니다.
         간격이 너무 짧아서 새로 고침이 레지스트라를 저하시킵니다.
         공연.



Rosenberg, et. al. 표준 트랙 [65 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         각 주소에 대해 레지스트라는 다음 목록을 검색합니다.
         현재의 바인딩은 URI 비교 규칙을 사용합니다. 만약
         바인딩이 존재하지 않으면 임시로 추가됩니다. 만약
         바인딩이 존재하면 레지스트라는 Call-ID 값을 확인합니다. 만약
         기존 바인딩의 Call-ID 값은
         요청에서 호출 ID 값, 바인딩은 반드시 제거되어야합니다.
         만기 시간은 0이고 그렇지 않으면 갱신됩니다. 그들이
         레지스트리 관리자는 CSeq 값을 비교합니다. 값
         기존 바인딩의 것보다 높으면 업데이트 또는
         위와 같이 바인딩을 제거하십시오. 그렇지 않은 경우 업데이트는
         중단되고 요청이 실패합니다.

         이 알고리즘은 동일한
         UA는 무시됩니다.

         각 바인딩 레코드는 Call-ID 및 CSeq 값을 기록합니다.
         요청.

         바인딩 업데이트는 커밋되어야한다 (즉,
         프록시 또는 리디렉션 서버) 모든 바인딩이 필요한 경우에만
         업데이트 및 추가가 성공합니다. 그 중 하나라도 실패하면 (
         예를 들어, 백 엔드 데이터베이스 커밋이 실패했기 때문에),
         요청은 500 (서버 오류) 응답으로 모두 실패해야하며 모든
         임시 바인딩 업데이트를 반드시 제거해야합니다.

      8. 등록자가 200 (OK) 응답을 리턴합니다. 응답은 반드시
         모든 현재를 열거하는 Contact 헤더 필드 값을 포함합니다.
         바인딩. 각 연락처 값에는 "만료"
         매개 변수로 선택한 만료 간격을 나타내는 매개 변수
         기록 사무관. 응답은 날짜 헤더 필드를 포함해야한다.

11 기능 쿼리

   SIP 방법 OPTIONS는 UA가 다른 UA 또는 프록시를 질의하는 것을 허용한다
   서버의 기능에 대해 설명합니다. 이를 통해 클라이언트는
   지원되는 메소드, 컨텐츠 유형, 확장자,
   코덱 등을 상대방에게 "울리지"않게합니다. 예를 들어, 전에
   클라이언트는 Require 헤더 필드를 INVITE에 삽입하여
   UAS가 지원하는 대상이 확실하지 않은 옵션,
   클라이언트는 OPTIONS를 사용하여 목적지 UAS에 질의 할 수 있습니다.
   옵션이 Supported 헤더 필드에 반환됩니다. 모든 UA는 반드시 지원해야한다.
   OPTIONS 메소드.

   OPTIONS 요청의 대상은 Request-URI에 의해 식별되며,
   다른 UA 또는 SIP 서버를 식별 할 수 있습니다. 옵션이
   프록시 서버로 보내지는 요청 URI는 사용자없이 설정됩니다.
   부분은 REGISTER 요청에 대해 Request-URI가 설정되는 방식과 유사합니다.




Rosenberg, et. al. 표준 트랙 [66 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   대안으로, 서버는 Max-
   전달 헤더 필드 값 0은 요청에 응답 할 수 있습니다
   요청 URI에 관계없이

      이 동작은 HTTP / 1.1에서 일반적입니다. 이 동작을 사용할 수 있습니다.
      의 기능을 검사하는 "traceroute"기능으로
      일련의 OPTIONS 요청을 보내 개별 홉 서버
      증분 된 최대 - 포워드 값.

   일반적인 UA 동작의 경우와 마찬가지로 트랜잭션 계층은
   OPTIONS가 응답을 내지 않으면 시간 종료 오류를 리턴하십시오. 이것은
   타겟이 도달 할 수 없으므로 사용할 수 없음을 나타냅니다.

   OPTIONS 요청은 설정된 대화 상자의 일부로 보내질 수 있습니다.
   나중에 사용할 수있는 기능에 대해 피어에게 질의
   대화.

11.1 OPTIONS 요청의 구성

   OPTIONS 요청은 SIP에 대한 표준 규칙을 사용하여 구성됩니다
   8.1.1 절에서 논의 된 요청.

   연락처 헤더 필드는 OPTIONS에있을 수 있습니다 (MAY).

   수락 헤더 필드는 유형을 나타 내기 위해 포함되어야한다 (SHOULD).
   UAC가 응답에서 수신하고자하는 메시지 본문. 일반적으로,
   이것은 미디어를 설명하는 데 사용되는 형식으로 설정됩니다.
   SDP (application / sdp)와 같은 UA의 기능

   OPTIONS 요청에 대한 응답은
   원래 요청의 Request-URI. 그러나 OPTIONS
   확립 된 대화의 일부로 보내지는 것은 미래가
   OPTIONS를 생성 한 서버가 요청을 수신합니다.
   응답.

   예제 OPTIONS 요청 :

      옵션 sip : carol@chicago.com SIP / 2.0
      경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKhjhs8ass877
      최대 전진 : 70
      받는 사람 : <sip : carol@chicago.com>
      보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
      통화 ID : a84b4c76e66710
      CSeq : 63104 옵션
      연락처 : <sip : alice@pc33.atlanta.com>
      수락 : application / sdp
      콘텐츠 길이 : 0




Rosenberg, et. al. 표준은 궤 [69 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


11.2 OPTIONS 요청 처리

   OPTIONS에 대한 응답은 표준 규칙을 사용하여 구성됩니다.
   8.2.6 절에서 논의 된 SIP 응답 응답 코드
   요청이있을 때 선택한 것과 동일해야합니다.
   초대되었습니다. 즉, UAS가 200 인 경우 200 (OK)이 반환됩니다.
   전화를받을 준비가되면 486 (Busy Here)이 반환됩니다.
   UAS가 사용 중입니다. OPTIONS 요청을 사용하여
   UAS의 기본 상태를 결정한다.
   UAS가 INVITE 요청을 수락할지 여부.

   대화 상자에서받은 OPTIONS 요청은 200 (OK)
   다이얼로그 밖에서 생성 된 응답과 동일한 응답
   대화에 영향을주지 않습니다.

   이 OPTIONS의 사용에는 프록시의 차이로 인해 제한이 있습니다.
   OPTIONS 및 INVITE 요청 처리. 분기 된 초대자가
   복수의 200 (OK) 응답이 반환되고, 분기 된
   OPTIONS는 단 하나의 200 (OK) 응답 만 가져옵니다.
   비 -INITE 처리를 사용하여 프록시에 의해 처리됩니다. 16.7 절 참조
   규범적인 세부 사항을 위해.

   OPTIONS에 대한 응답이 프록시 서버에 의해 생성 된 경우
   프록시는 서버 기능을 나열하는 200 (OK)을 리턴합니다.
   응답에 메시지 본문이 없습니다.

   허용, 수락, 수락 - 인코딩, 수락 언어 및 지원 헤더
   필드는 OPTIONS에 대한 200 (OK) 응답으로 표시되어야합니다 (SHOULD).
   의뢰. 응답이 프록시에 의해 생성되면 Allow 헤더
   필드는 프록시가 메소드이기 때문에 애매하므로 생략해야합니다
   불가지론 자. 연락처 헤더 필드는 200 (OK)
   응답과 3xx 응답에서와 동일한 의미를가집니다. 그건,
   그들은 대체 이름과 그것들에 도달하는 방법의 집합을 나열 할 수있다.
   사용자. 경고 헤더 필드가있을 수 있습니다 (MAY).

   메시지 본문이 전송 될 수 있으며, 그 유형은
   OPTIONS 요청의 헤더 필드를 수락합니다 (application / sdp는
   Accept 헤더 필드가없는 경우 기본값). 유형이
   미디어 기능을 설명 할 수있는 것을 포함하면, UAS는
   그 목적을 위해 응답에 몸을 포함 시키십시오. 세부 정보
   application / sdp의 경우 그러한 바디의 생성은
   [13]에 설명되어있다.









Rosenberg, et. al. 표준 트랙 [68 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   UAS에 의해 생성 된 OPTIONS 응답의 예 (
   섹션 11.1의 요청) :

      SIP / 2.0 200 OK
      경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKhjhs8ass877
       수신 = 192.0.2.4
      받는 사람 : <sip : carol@chicago.com>; tag = 93810874
      보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
      통화 ID : a84b4c76e66710
      CSeq : 63104 옵션
      연락처 : <sip : carol@chicago.com>
      연락처 : <mailto : carol@chicago.com>
      허용 : INVITE, ACK, CANCEL, OPTIONS, BYE
      수락 : application / sdp
      수락 - 인코딩 : gzip
      수락 언어 : ko
      지원 : foo
      콘텐츠 유형 : application / sdp
      콘텐츠 길이 : 274

      (SDP는 표시되지 않음)

12 대화 상자

   사용자 에이전트의 핵심 개념은 대화 상자의 개념입니다. 대화 상자
   두 사용자 에이전트 간의 피어 - 투 - 피어 SIP 관계를 나타냅니다.
   그것은 얼마 동안 지속됩니다. 이 대화 상자는
   사용자 에이전트 간의 메시지와 적절한 요청 라우팅
   두 사람 사이. 이 대화 상자는
   SIP 메시지를 해석한다. 8 절에서는 방법에 독립적 인 UA
   대화 상자 외부의 요청 및 응답 처리. 이
   섹션에서는 이러한 요청 및 응답을 사용하여
   대화 상자를 구성한 다음 후속 요청 및 응답을 작성하는 방법
   대화 상자 내에서 전송됩니다.

   대화 상자 ID로 각 UA에서 대화 상자가 식별됩니다.
   Call-ID 값, 로컬 태그 및 원격 태그를 포함 할 수있다. 각 대화 ID
   대화에 관련된 UA는 동일하지 않습니다. 특히, 지역
   하나의 UA에서의 태그는 피어 UA에서의 원격 태그와 동일하다. 그만큼
   태그는 고유 한 생성을 용이하게하는 불투명 한 토큰입니다.
   대화 ID

   대화 ID는 모든 응답 및 모든 응답과 연관됩니다.
   받는 사람 필드에 태그가 포함 된 요청. 컴퓨팅 규칙
   메시지의 대화 ID는 SIP 요소가 UAC인지 여부에 따라 달라집니다
   또는 UAS. UAC의 경우 대화 ID의 Call-ID 값은
   메시지의 Call-ID, 원격 태그는 To의 태그로 설정됩니다.
   필드의 태그로 설정되고 로컬 태그는 보낸 사람의 태그로 설정됩니다.



Rosenberg, et. al. 표준 트랙 [69 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   필드 (이 규칙은 요청 및
   응답). UAS를 기대할 때, UAS의 Call-ID 값은
   대화 ID가 메시지의 Call-ID로 설정되고 원격 태그가 설정됩니다.
   메시지의 보낸 사람 필드에있는 태그에 추가하면 로컬 태그가 설정됩니다.
   메시지의받는 사람 필드에있는 태그로 이동하십시오.

   대화 상자에는 추가 메시지에 필요한 상태의 특정 부분이 포함되어 있습니다.
   다이얼로그 내에서의 전송. 이 상태는 대화 상자로 구성됩니다.
   ID, 로컬 시퀀스 번호 (UA에서 UA로 요청을
   피어), 원격 순차 번호 (요청에 대한 주문에 사용됨)
   UA에 피어), 로컬 URI, 원격 URI, 원격 대상, 부울
   플래그는 "secure"로, 경로 집합은 순서가 지정된 목록입니다.
   URI. 라우트 집합은 통과해야하는 서버 목록입니다.
   피어에게 요청을 보냅니다. 대화 상자는 "초기"
   상태는 일시적인 응답으로 생성 될 때 발생하며,
   2xx 결승전이 끝나면 "확인 된"상태로 전환하십시오.
   응답이 도착합니다. 다른 응답의 경우 또는 응답이 도착하지 않은 경우
   모든 대화 상자에서 초기 대화 상자가 종료됩니다.

12.1 대화 상자의 생성

   대화 상자는 비 실패 응답 생성을 통해 생성됩니다.
   특정 메소드를 가진 요청. 이 사양 내에서
   2xx 및 101-199 응답에 요청이있는 To 태그
   INVITE, 대화 상자를 설정합니다. 비 최종 결정 회의
   요청에 대한 응답은 "초기"상태에 있으며 요청은
   초기 대화. 확장은 생성을위한 다른 수단을 정의 할 수있다.
   대화 상자. 13 장에서는
   INVITE 메소드. 여기서는 대화 상자 생성 프로세스를 설명합니다.
   상태는 메소드에 종속되지 않습니다.

   UA는 설명 된대로 대화 ID 구성 요소에 값을 할당해야합니다.
   이하.

12.1.1 UAS 비헤이비어

   UAS가 요청에 응답 할 때
   대화 상자 (INVITE에 2xx와 같은)를 보내면 UAS는 모든 Record-
노선
   요청에서 응답으로의 헤더 필드 값 (
   URI, URI 매개 변수 및 모든 Record-Route 헤더 필드 매개 변수,
   UAS가 알고 있거나 알지는 못하던)
   그 값들의 순서. UAS는 Contact 헤더 필드를
   응답. 연락처 헤더 필드에는
   UAS는 대화 상자에서 후속 요청에 대해 연락하기를 원합니다.
   (이는 INVITE의 경우 2xx 응답에 대한 ACK를 포함 함).
   일반적으로이 URI의 호스트 부분은 다음의 IP 주소 또는 FQDN입니다.
   주인. Contact 헤더 필드에 제공된 URI는 반드시 SIP이어야한다.
   또는 SIPS URI. 대화 상자를 시작한 요청에



Rosenberg, et. al. 표준은 표준화 [69 쪽]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   Request-URI 또는 ​​최상위 Record-Route 헤더 필드의 SIPS URI
   값 (있는 경우) 또는 Contact 헤더 필드 (없는 경우)
   Record-Route 헤더 필드, 응답의 Contact 헤더 필드
   SIPS URI 여야합니다. URI는 전체 범위를 가져야한다 (즉,
   이 대화 상자 외부의 메시지에서 동일한 URI를 사용할 수 있음). 같은 방식으로,
   INVITE의 Contact 헤더 필드에있는 URI의 범위는
   이 대화 상자로 제한됩니다. 따라서 메시지에서 사용할 수 있습니다.
   이 대화 상자 밖에서도 UAC에 연결하십시오.

   그런 다음 UAS는 대화 상자의 상태를 구성합니다. 이 상태는 반드시
   대화 상자의 지속 기간 동안 유지됩니다.

   TLS를 통해 요청이 도착하고 Request-URI에 SIPS가 포함 된 경우
   URI이면 "secure"플래그가 TRUE로 설정됩니다.

   라우트 집합은 Record-Route의 URI 목록으로 설정되어야한다 (MUST)
   헤더 필드는 요청에서 가져온 것으로 모든 URI를 보존합니다.
   매개 변수. Record-Route 헤더 필드가
   요청을 받으면 경로 집합을 빈 집합으로 설정해야합니다 (MUST). 이 경로 집합,
   비어있는 경우에도 미래에 설정된 모든 기존 경로를 무시합니다.
   이 대화 상자의 요청. 원격 대상은 URI로 설정되어야합니다.
   요청의 연락처 헤더 필드에서.

   원격 순서 번호는 순서 값으로 설정해야합니다 (MUST).
   요청의 CSeq 헤더 필드에있는 번호. 로컬 시퀀스
   번호는 반드시 비어 있어야합니다. 대화 ID의 호출 식별자 구성 요소
   요청의 Call-ID 값으로 설정해야합니다. 지역
   대화 ID의 태그 구성 요소는 수신인 필드의 태그로 설정되어야합니다.
   (항상 태그를 포함하는) 요청에 대한 응답에서
   대화 ID의 원격 태그 구성 요소는에서 태그로 설정되어야합니다.
   요청의 필드에서. UAS는 반드시
   보낸 사람 필드에 태그가없는 요청.이 경우 태그는
   값이 null로 간주됩니다.

      이것은 RFC 2543과의 하위 호환성을 유지하기위한 것입니다.
      태그를 통해 위임하지 않았습니다.

   원격 URI는 From 필드의 URI로 설정되어야하며,
   로컬 URI는 수신인 필드의 URI로 설정되어야합니다.

12.1.2 UAC 동작

   UAC가 대화 상자를 설정할 수있는 요청을 보낼 때 (예 :
   INVITE) 전역 범위를 가진 SIP 또는 SIPS URI를 제공해야합니다 (즉,
   이 대화 상자 외부의 메시지에서 동일한 SIP URI를 사용할 수 있음)
   요청의 헤더 필드를 문의하십시오. 요청에 Request-
   URI 또는 ​​SIPS URI가있는 최상위 Route 헤더 필드 값
   연락처 헤더 필드는 반드시 SIPS URI를 포함해야합니다.



Rosenberg, et. al. 표준 트랙 [71 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   UAC가 대화를 설정하는 응답을 받으면
   대화 상자의 상태를 구성합니다. 이 상태는 반드시 유지되어야한다.
   대화 상자의 지속 기간 동안.

   요청이 TLS를 통해 전송되었고 Request-URI에
   SIPS URI이면 "보안"플래그가 TRUE로 설정됩니다.

   라우트 집합은 Record-Route의 URI 목록으로 설정되어야한다 (MUST)
   응답에서 헤더 필드를 역순으로 저장하고 보존합니다.
   모든 URI 매개 변수. Record-Route 헤더 필드가없는 경우
   응답의 경우, 라우트 세트는 빈 세트로 설정되어야합니다 (MUST). 이 경로
   비어있는 경우에도 설정하면 앞으로 기존 경로를 무시합니다.
   이 대화 상자의 요청. 원격 대상은 URI로 설정되어야합니다.
   응답의 연락처 헤더 필드에서.

   로컬 시퀀스 번호는 시퀀스 값으로 설정되어야합니다 (MUST)
   요청의 CSeq 헤더 필드에있는 번호. 원격 순서
   번호는 비어 있어야합니다 (원격 UA가
   대화 상자 내에서 요청). 호출 식별자 구성 요소는
   대화 ID는 요청의 Call-ID 값으로 설정되어야합니다.
   대화 ID의 로컬 태그 구성 요소는에서 태그로 설정되어야합니다.
   요청의 보낸 사람 필드 및
   대화 ID는 응답의받는 사람 필드에있는 태그로 설정되어야합니다. 에이
   UAC는 To에 태그가없는 응답을 수신 할 수 있도록 준비해야합니다 (MUST).
   이 경우 태그는 null 값을 가진 것으로 간주됩니다.

      이것은 RFC 2543과의 하위 호환성을 유지하기위한 것입니다.
      태그에 위임하지 않았습니다.

   원격 URI는받는 사람 필드의 URI로 설정되어야하며, 로컬 URI는
   URI는 발신인 필드의 URI로 설정되어야합니다.

12.2 대화 상자 내 요청

   두 개의 UA 사이에 대화 상자가 설정되면
   대화 상자 내에서 필요에 따라 새 트랜잭션을 시작할 수 있습니다. UA
   요청을 보내면 트랜잭션에 대한 UAC 역할을 수행합니다. 그만큼
   요청을 수신 한 UA는 UAS 역할을 수행합니다. 이것들은
   거래 중에 사용되는 UA와 다른 역할을해야한다.
   대화 상자를 만들었습니다.

   다이얼로그 내의 요청은 Record-Route와 Contact 헤더를 포함 할 수있다.
   전지. 그러나 이러한 요청으로 인해 대화 상자의 경로 집합이 생성되지는 않습니다
   그들은 변경 될 수 있지만 원격 대상 URI를 수정할 수 있습니다.
   특히 대상 새로 고침 요청이 아닌 요청은
   대화 상자의 원격 대상 URI 수정 및 대상 요청
   새로 고침 요청이 수행합니다. 함께 설정된 대화 상자의 경우




Rosenberg, et. al. 표준 트랙 [72 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   INVITE, 정의 된 유일한 대상 새로 고침 요청은 re-INVITE입니다 (
   섹션 14). 다른 확장 기능은 다른 타겟 새로 고침을 정의 할 수 있습니다.
   다른 방법으로 설정된 대화 상자에 대한 요청.

      ACK는 대상 새로 고침 요청이 아닙니다.

   대상 새로 고침 요청은 대화 상자의 원격 대상 URI 만 업데이트합니다.
   Record-Route에서 형성된 경로 세트가 아닙니다. 업데이트 중
   후자는 심각한 하위 호환성 문제를
   RFC 2543 준수 시스템.

12.2.1 UAC 동작

12.2.1.1 요청 생성

   대화 상자 내의 요청은
   대화 상자의 일부로 저장된 상태의 구성 요소.

   요청의받는 사람 필드에있는 URI는 원격 URI로 설정되어야합니다 (MUST).
   대화 상태에서. 요청의 To 헤더 필드에있는 태그
   반드시 대화 ID의 원격 태그로 설정해야합니다. From URI
   요청은 대화 상태에서 로컬 URI로 설정되어야합니다. 태그
   요청의 From 헤더 필드에 로컬 태그로 설정되어야합니다 (MUST).
   대화 ID의 리모트 태그 또는 로컬 태그의 값이 null의 경우,
   To 또는 From 헤더 필드에서 태그 매개 변수를 생략해야하며,
   각기.

      원본의받는 사람 및 보낸 사람 필드에서 URI 사용
      후속 요청 내의 요청은 거꾸로 수행됩니다.
      대화 상자에 URI를 사용하는 RFC 2543과의 호환성
      신분증. 이 사양에서는 태그 만 사용됩니다.
      대화 상자 식별. 의무적 인 반성이 예상된다.
      대화 상대 요청의 원본 To 및 From URI가
      이 사양의 후속 개정에서 더 이상 사용되지 않습니다.

   요청의 Call-ID는 대화 상자의 Call-ID로 설정되어야합니다 (MUST).
   대화 상자 내의 요청은 엄격하게 단조롭게 포함되어야합니다
   증가하고 인접한 CSeq 시퀀스 번호 (하나씩 증가)
   각 방향으로 (물론 ACK와 CANCEL을 제외하고, 숫자
   요청이 승인 또는 취소 된 것과 동일). 따라서,
   로컬 순서 번호는 하늘이 아니고, 로컬 순서 번호
   시퀀스 번호는 1 씩 증가해야하며,이 값은 반드시 1이어야합니다.
   CSeq 헤더 필드에 배치됩니다. 로컬 순서 번호가
   비어있는 경우 초기 값은 다음의 지침을 사용하여 선택해야합니다.
   섹션 8.1.1.5. CSeq 헤더 필드 치의 메소드 필드
   요청 방법과 일치해야합니다.





Rosenberg, et. al. 표준 트랙 [73 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      길이가 32 비트 인 클라이언트는 단일
      요청하기 전에 약 136 년 동안 한 번씩 요청하라.
      줄 바꿈. 시퀀스 번호의 초기 값이 선택됩니다.
      동일한 호출 내에서 후속 요청이 랩핑되지 않습니다.
      약. 0이 아닌 초기 값을 사용하면 클라이언트가 시간 -
      기반 초기 시퀀스 번호. 클라이언트는 예를 들어,
      32 비트 두 번째 클럭의 31 개의 최상위 비트를
      초기 시퀀스 번호.

   UAC는 원격 대상 및 경로 집합을 사용하여 Request-URI를 작성합니다.
   및 요청의 Route 헤더 필드.

   라우트 집합이 비어 있으면 UAC는 원격 대상 URI를 배치해야합니다 (MUST)
   Request-URI에 추가합니다. UAC는 Route 헤더 필드를
   요청.

   경로 집합이 비어 있지 않고 경로 집합의 첫 번째 URI가
   lr 매개 변수 (19.1.1 절 참조)가 포함되어 있으면 UAC는 반드시
   원격 대상 URI를 요청 URI로 변환하고 반드시 경로를 포함해야합니다
   모든 경로를 포함한 경로 설정 값을 포함하는 헤더 필드
   매개 변수.

   라우트 집합이 비어 있지 않고 첫 번째 URI에
   lr 매개 변수 인 경우 UAC는 라우트 집합의 첫 번째 URI를 배치해야합니다 (MUST)
   Request-URI에 허용되지 않는 매개 변수를 제거합니다.
   Request-URI에서. UAC는 다음을 포함하는 Route 헤더 필드를 추가해야합니다 (MUST).
   나머지 경로는 모두를 포함하여 순서대로 값을 설정합니다.
   매개 변수. 그런 다음 UAC는 원격 대상 URI를
   헤더 필드를 마지막 값으로 라우팅하십시오.

   예를 들어 원격 대상이 sip : user @ remoteua이고 경로가
   세트 내용 :

      <sip : proxy1>, <sip : proxy2>, <sip : proxy3; lr>, <sip : proxy4>

   요청은 다음 Request-URI 및 Route로 구성됩니다.
   헤더 필드 :

   메소드 sip : proxy1
   경로 : <sip : proxy2>, <sip : proxy3; lr>, <sip : proxy4>, <sip : user @ remoteua>

      라우트 집합의 첫 번째 URI에 lr이 포함되지 않은 경우
      매개 변수가 지정된 프록시가 라우팅을 이해하지 못했습니다.
      메커니즘은이 문서에서 설명하고 다음에서 지정된대로 작동합니다.
      Request-URI를 첫 번째 Route 헤더로 대체하는 RFC 2543
      필드 값은 메시지를 전달하는 동안 수신됩니다. 배치
      Route 헤더 필드의 끝에있는 Request-URI는




Rosenberg, et. al. 표준 트랙 [74 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      엄격한 라우터를 통한 Request-URI의 정보
      요구가 느슨한 요청에 도달 할 때 Request-URI로 리턴 될 수있다.
      라우터).

   UAC는 임의의 타겟 리프레시에 Contact 헤더 필드를 포함해야한다.
   대화 상자 내에서 요청을 변경하고 변경해야 할 필요가없는 경우,
   URI는 이전의 요청에서 사용 된 URI와 같아야한다.
   대화. "secure"플래그가 참이면 해당 URI는 SIPS URI 여야합니다 (MUST).
   섹션 12.2.2에서 논의 된 것처럼, 대상의 Contact 헤더 필드
   새로 고침 요청은 원격 대상 URI를 업데이트합니다. 이것은 UA가
   주소가 변경되는 동안 새 연락처 주소를 제공하십시오.
   대화 상자의 지속 시간.

   그러나 대상 새로 고침 요청이 아닌 요청은 영향을받지 않습니다
   대화 상자의 원격 대상 URI

   나머지 요청은 8.1.1 절에 설명 된대로 구성됩니다.

   요청이 구성되면 서버의 주소는 다음과 같습니다.
   계산 된 요청은 동일한 절차를 사용하여 전송됩니다.
   대화 상자 밖의 요청 (8.1.2 절).

      8.1.2 절의 절차는 일반적으로
      최상위 경로가 나타내는 주소로 요청이 전송됩니다.
      헤더 필드 값이 없으면 Request-URI 또는 ​​헤더 필드 값
      선물. 특정 제한 사항에 따라 요청을 허용합니다.
      대체 주소 (예 : 기본 아웃 바운드
      프록시가 라우트 집합에 표시되지 않음).

12.2.1.2 응답 처리

   UAC는 거래 요청에 대한 응답을받습니다.
   층. 클라이언트 트랜잭션이 시간 초과를 반환하면 처리됩니다.
   408 (Request Timeout) 응답으로.

   요청에 대해 3xx 응답을받는 UAC의 동작
   대화 상자 내에서 요청이 외부로 전송 된 경우와 같습니다.
   대화. 이 문제는 8.1.3.4 절에 설명되어 있습니다.

      그러나 UAC가 대체 위치를 시도하면
      대화 상자에 설정된 경로를 사용하여 Route 헤더를 만듭니다.
      요청의

   UAC가 대상 새로 고침 요청에 대한 2xx 응답을 받으면
   대화 상자의 원격 대상 URI를
   해당 응답의 헤더 필드를 문의하십시오 (있는 경우).





Rosenberg, et. al. 표준 트랙 [74 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   대화 상자 내의 요청에 대한 응답이 481
   (호출 / 트랜잭션이 존재하지 않음) 또는 408 (요청 시간 초과)이면 UAC
   대화 상자를 종료해야합니다 (SHOULD). UAC는 다음과 같은 경우에도 대화 상자를 종료해야합니다.
   요청에 대해 전혀 응답이 수신되지 않습니다 (클라이언트
   트랜잭션은 TU에 타임 아웃을 알립니다.)

      INVITE 시작 대화 상자의 경우 대화 상자를 종료하는 작업은
      BYE를 보냈다.

12.2.2 UAS 동작

   다른 요청과 마찬가지로 대화 상자 내에서 전송 된 요청은 원 자성입니다. 만약
   특정 요구가 UAS에 의해 수락되면, 모든 주 변경
   그것과 관련된. 요청이 거절 된 경우
   상태 변화가 수행됩니다.

      INVITE와 같은 일부 요청은
      상태.

   UAS는 트랜잭션 계층으로부터 요청을 수신합니다. 만약
   요청에 To 헤더 필드에 태그가 있으면 UAS 코어는
   요청에 해당하는 대화 상대 식별자를
   기존 대화 상자 일치하는 항목이 있으면 대화 상자 중간 요청입니다.
   이 경우 UAS는 먼저 동일한 처리 규칙을 적용합니다.
   8.2 절에 설명 된 대화 상자 외부의 요청.

   요청에 To 헤더 필드에 태그가 있지만 대화 상자
   식별자가 기존 대화 상자와 일치하지 않으면 UAS에
   크래시되고 다시 시작되었거나 요청을 받았을 수 있습니다.
   다른 (아마도 실패한) UAS (UAS는 To 태그를 구성 할 수 있습니다.)
   UAS는 그 태그가 그것이있는 UAS를위한 것인지를 식별 할 수있다.
   복구 제공). 또 다른 가능성은 들어오는
   요청이 잘못 라우트되었습니다. To 태그를 기반으로 UAS MAY
   요청을 수락하거나 거절하십시오. 요청 접수
   acceptable 태그는 견고성을 제공하므로 대화 상자가 지속될 수 있습니다.
   심지어 충돌을 통해. 이 기능을 지원하고자하는 UA는
   단조롭게 선택하는 것과 같은 몇 가지 문제를 고려하십시오.
   재부팅시에도 CSeq 시퀀스 번호가 증가하고 재구성
   경로 설정, 범위를 벗어난 RTP 타임 스탬프 및 시퀀스 수용
   번호.

   UAS가 원하지 않기 때문에 요청을 거절하고자한다면
   대화 상자를 다시 만들려면 481과 함께 요청에 응답해야합니다.
   (전화 / 거래가 존재하지 않음) 상태 코드를 전달하고
   서버 트랜잭션.






Rosenberg, et. al. 표준 트랙 [74 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   어떤 방식 으로든 대화 상자의 상태가 변경되지 않는 요청
   대화 상자 (예 : OPTIONS 요청)에서 받았습니다. 그들은
   대화 상자 밖에서 수신 된 것처럼 처리됩니다.

   원격 순서 번호가 비어 있으면 값으로 설정해야합니다 (MUST).
   요청에있는 CSeq 헤더 필드 값의 시퀀스 번호.
   리모트 순서 번호가 하늘이 아니고 순서 번호
   요청이 원격 순서 번호보다 낮은 경우 요청
   순서가 잘못되어 500 (서버 내부)으로 거부되어야합니다.
   오류) 응답. 원격 순서 번호가 비어 있지 않으면
   요청 시퀀스 번호가 원격보다 큼
   시퀀스 번호가 있으면 요청이 순서대로 처리됩니다. 가능하면
   CSeq 시퀀스 번호가 원격 시퀀스 번호보다
   하나 이상. 이것은 오류 조건이 아니며 UAS가되어야합니다.
   CSeq 값이보다 큰 요청을 수신하고 처리 할 준비가되었습니다.
   이전 수신 요청보다 하나 더 높습니다. UAS는 다음을 설정해야합니다
   리모트의 시퀸스 번호를
   요청의 CSeq 헤더 필드 값.

      프록시가 UAC에 의해 생성 된 요청에 도전하면 UAC는
      자격증 명으로 요청을 다시 제출하십시오. 다시 제출 된 요청
      새로운 CSeq 번호가 생깁니다. UAS는 첫 번째
      요청을 처리하므로 CSeq 번호 공간에 차이가 있음을 알 수 있습니다.
      이러한 갭은 오류 조건을 나타내지 않습니다.

   UAS가 목표 새로 고침 요청을 수신하면 UAS는
   대화 상대의 원격 대상 URI와 Contact 헤더 필드의 URI
   해당 요청이있는 경우

12.3 대화 상자의 종료

   이 메소드와는 별도로, 대화 상자 외부의 요청이 생성되면
   비 2xx 최종 응답, 초기 대화 상자
   해당 요청에 대한 잠정적 응답은 종료됩니다. 메커니즘
   확인 된 대화 상자를 종료하는 방법은 특정 방법입니다. 이
   BYE 메서드는 세션을 종료하고 대화 상자
   그것과 관련된. 자세한 내용은 15 항을 참조하십시오.

13 세션 시작하기

13.1 개요

   사용자 에이전트 클라이언트가 세션을 시작하기를 원할 때 (예를 들어,
   오디오, 비디오 또는 게임), 그것은 INVITE 요청을 공식화합니다. 그만큼
   INVITE 요청은 서버에 세션을 설정하도록 요청합니다. 이 요청
   프록시에 의해 전달 될 수 있으며 결국 하나 이상의 UAS에 도착합니다.
   잠재적으로 초대를 수락 할 수 있습니다. 이 UAS는
   수락할지 여부를 사용자에게 묻는 것이 자주 필요합니다.



Rosenberg, et. al. 표준 트랙 [Page 77]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   초대. 얼마 후 UAS는 초대를 수락 할 수 있습니다.
   (세션이 수립됨을 의미 함) 2xx 응답을 보냅니다.
   초대가 수락되지 않으면 3xx, 4xx, 5xx 또는 6xx 응답이
   거절 이유에 따라 보냈습니다. 보내기 전에
   최종 응답 인 경우 UAS는 임시 응답 (1xx)을
   호출 된 사용자에게 연락하는 과정이 UAC에 조언하십시오.

   가능하면 하나 이상의 임시 응답을받은 후 UAC
   하나 이상의 2xx 응답 또는 하나의 비 2xx 최종 응답을 가져옵니다.
   마지막 시간을 받기까지 걸릴 수있는 시간이 오래 걸리기 때문에
   INVITE에 대한 응답, INVITE에 대한 신뢰성 메커니즘
   거래는 다른 요청 (OPTIONS 등)의 거래와 다릅니다.
   최종 응답을 받으면 UAC는 다음에 대한 ACK를 보내야합니다.
   그것이받는 모든 최종 응답. 이 ACK를 보내는 절차
   응답 유형에 따라 다릅니다. 최종 응답은 300 ~
   699에서, ACK 처리는 트랜잭션 계층에서 수행되고 뒤이어 계속된다
   한 세트의 규칙 (17 조 참조). 2xx 응답의 경우 ACK는 다음과 같습니다.
   UAC 코어에 의해 생성됩니다.

   INVITE에 대한 2xx 응답은 세션을 설정하고
   INVITE를 발행 한 UA와 UA간에 다이얼로그를 생성한다
   2xx 응답을 생성했습니다. 따라서 복수의 2xx
   응답은 다른 원격 UA로부터 수신됩니다 (INVITE
   fork), 각 2xx는 다른 대화 상자를 설정합니다. 이 모든 대화 상자
   동일한 호출의 일부입니다.

   이 섹션에서는 다음을 사용하여 세션 설정에 대한 세부 정보를 제공합니다.
   초대. INVITE를 지원하는 UA는 또한 ACK, CANCEL 및
   안녕.

13.2 UAC 처리

13.2.1 초기 INVITE 만들기

   초기 INVITE는 대화 외부의 요청을 나타내므로,
   그 구성은 8.1.1 절의 절차를 따른다. 추가
   INVITE의 특정 경우에는 처리가 필요합니다.

   Allow 헤더 필드 (20.5 절)는 INVITE에 있어야한다.
   UA에서 대화 상자 내에서 호출 할 수있는 메소드를 나타냅니다.
   대화 상자의 지속 기간 동안 INVITE를 보냅니다. 예를 들어, a
   대화 내에서 INFO 요청을 수신 할 수있는 UA [34]
   INFO 메소드를 나열하는 Allow 헤더 필드를 포함하십시오.

   지원 헤더 필드 (20.37 절)는
   초대. UAC가 이해하는 모든 확장을 나열합니다.





Rosenberg, et. al. 표준품 [74 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   Accept (20.1 절) 헤더 필드는 INVITE에 존재할 수있다.
   이것은 UA가 수용 할 수있는 Content-Type을 나타냅니다.
   그것에 의해 수신 된 응답 및 다음에 전송 된 요청에서
   INVITE에 의해 설정된 대화 내에서. Accept 헤더 필드
   다양한 세션의 지원을 나타내는 데 특히 유용합니다.
   설명 형식

   UAC는 Expires 헤더 필드 (20.19 절)를 추가하여
   초대장의 유효 기간. 만료일에 표시된 시간
   헤더 입력란에 도달했으며 INVITE에 대한 최종 답변이 없습니다.
   수신 된 UAC 코어는 다음에 대한 CANCEL 요청을 생성해야한다 (SHOULD).
   제 9 항에 따라 INVITE.

   UAC는 또한 Subject (Section
   20.36), 조직 (20.25 절) 및 사용자 에이전트 (20.41 절)
   헤더 필드. 그것들은 모두 INVITE와 관련된 정보를 포함합니다.

   UAC는 INVITE에 메시지 본문을 추가하기로 선택할 수 있습니다 (MAY). 섹션
   8.1.1.10 헤더 필드를 구성하는 방법을 다룬다. - Content-
   다른 유형들 - 메시지 본문을 설명하는 데 필요합니다.

   세션이 포함 된 메시지 본문에 대한 특별 규칙이 있습니다.
   description - 해당 Content-Disposition은 "session"입니다.
   SIP는 하나의 UA가 세션을 전송하는 제안 / 응답 모델을 사용합니다.
   제안서에 설명이 포함 된 설명
   세션의 오퍼는 원하는 통신 수단을 나타냅니다.
   (오디오, 비디오, 게임), 해당 수단의 매개 변수 (코덱
   유형) 및 응답자로부터 미디어를 수신하기위한 주소. 그만큼
   다른 UA는 다른 세션 설명으로 응답합니다.
   어떤 통신 수단이 수락되는지를 나타내는 대답
   해당 수단에 적용되는 매개 변수 및 수신을위한 주소
   오퍼 러의 미디어. 오퍼 / 답변 교환은
   대화 상자의 컨텍스트를 사용하여 SIP INVITE가 다중
   대화 상자는 각각 별도의 오퍼 / 대답 교환입니다. 제안 / 대답
   모델은 쿠폰 및 답변 생성시기에 대한 제한을 정의합니다.
   (예를 들어, 진행 중에 새로운 제안을 할 수는 없습니다).
   이로 인해 쿠폰 및 답변의 위치가 제한 될 수 있습니다.
   SIP 메시지에 나타납니다. 이 명세서에서 제안 및 답변
   INVITE 요청 및 응답 및 ACK에만 나타날 수 있습니다. 사용법
   제안 및 답변이 더 제한됩니다. 초기 INVITE의 경우
   거래의 규칙은 다음과 같습니다.

      o 초기 제안은 INVITE에 있어야하며 그렇지 않은 경우,
         UAS로부터의 최초의 신뢰할 수있는 비 고장 메시지에서
         UAC 이 사양에서는 최종 2xx입니다.
         응답.





Rosenberg, et. al. 표준 트랙 [79 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      o 초기 제안이 INVITE에있는 경우 응답은 반드시 INVITE에 있어야합니다.
         UAS에서 UAC 로의 신뢰할 수있는 비 고장 메시지
         INVITE와 상관 관계가 있습니다. 이 사양의 경우
         그 INVITE에 대한 최종 2xx 응답 만. 그 똑같은 정확한
         대답은 보낸 잠정적 인 응답에 배치 될 수도있다.
         답에 앞서. UAC는 첫 번째 세션을 처리해야합니다 (MUST)
         응답으로받은 설명을 무시하고
         이후의 초기 응답에 대한 세션 설명
         초대.

      o 초기 제안이 첫 번째 신뢰할 수있는 비 장애가있는 경우
         UAS에서 UAC로 되돌아 오는 메시지는 답변에 포함되어야합니다.
         그 메시지에 대한 확인 응답 (본 명세서에서는 ACK
         2xx 응답의 경우).

      o 첫 번째 오퍼를 보내거나받은 후,
         UAC는 규칙에 따라 요청에 대한 후속 제안을 생성 할 수 있습니다 (MAY)
         해당 메소드에 대해 지정되었지만 응답을받은 경우에만
         이전 쿠폰으로 이전했으며 쿠폰을 제공하지 않았습니다.
         아직 답을 얻지 못했습니다.

      o UAS가 초기에 답을 보내거나 받으면
         제안서, 어떤 응답에서도 후속 제안을 생성해서는 안됩니다
         초기 초대에. 즉,이를 기반으로 한 UAS
         사양만으로는
         초기 거래 완료

   구체적으로 위의 규칙은 UA 규격
   이 사양만으로는 - 제안은 INVITE에 있고,
   2xx에서 대답하고 (아마도 1xx에서도 마찬가지 일 것입니다.
   값) 또는 오퍼가 2xx에 있고 응답이 ACK에 있습니다.
   INVITE를 지원하는 모든 사용자 에이전트는이 두 교환을 지원해야합니다.

   세션 설명 프로토콜 (SDP) (RFC 2327 [1])은 반드시
   모든 사용자 에이전트가 세션을 설명하는 수단으로 지원하고
   제안 및 답변 작성을위한 사용법은 절차를 따라야합니다
   [13]에 정의되어있다.

   방금 설명한 제안 응답 모델의 제한 사항이 적용됩니다
   Content-Disposition 헤더 필드 값이 "session"인 본문에 적용됩니다.
   그러므로, INVITE와 ACK 모두가
   본문 메시지 (예 : INVITE는 사진 (Content-
   처리 : 렌더링) 및 ACK 세션 설명 (Content-
   처분 : 세션)).

   Content-Disposition 헤더 필드가 누락 된 경우
   Content-type application / sdp는 "세션"처분을 암시하며,
   다른 콘텐츠 유형은 "렌더링"을 의미합니다.



Rosenberg, et. al. 표준 트랙 [Page 80]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   초대가 생성되면 UAC는 절차를 따릅니다.
   대화 상자 밖에서 요청을 보내기 위해 정의됩니다 (8 절). 이
   결과적으로 클라이언트 트랜잭션이 생성됩니다.
   궁극적으로 요청을 보내고 응답을 UAC에 전달합니다.

13.2.2 INVITE 응답 처리

   INVITE가 INVITE 클라이언트 트랜잭션으로 전달되면
   UAC는 INVITE에 대한 응답을 기다립니다. INVITE 클라이언트
   트랜잭션은 TU가 응답으로 응답하는 대신 타임 아웃을 반환합니다.
   설명 된대로 408 (Request Timeout) 응답이 수신 된 경우
   섹션 8.1.3.

13.2.2.1 1xx 응답

   0 개, 하나 또는 여러 개의 임시 응답이 하나 또는
   더 많은 최종 응답이 수신됩니다. 임시 응답
   초대 요청은 "초기 대화 상자"를 만들 수 있습니다. 잠정적 인 응답
   받는 사람 필드에 태그가 있고 응답의 대화 ID가
   기존 대화 상자와 일치하지 않는 경우, 하나는 절차를 사용하여 생성됩니다.
   12.1.2 절에 정의되어 있습니다.

   초기 대화 상자는 UAC가
   초기 INVITE 전에 다이얼로그 내에서 피어에게 요청
   트랜잭션이 완료됩니다. 임시 필드에있는 머리글 필드
   응답은 대화 상자가 초기 상태 인 한 적용 가능합니다.
   (예 : 잠정적 응답의 Allow 헤더 필드
   대화 상자에서 사용할 수있는 메소드가 들어 있습니다.
   초기 상태).

13.2.2.2 3xx 응답

   3xx 응답은 하나 이상의 Contact 헤더 필드 값을 포함 할 수 있습니다
   피 호출자가 도달 할 수있는 새 주소를 제공합니다.
   3xx 응답의 상태 코드 (21.3 절 참조)에 따라,
   UAC는 새로운 주소를 시도 할 수도 있습니다 (MAY).

13.2.2.3 4xx, 5xx 및 6xx 응답

   INVITE에 대해 2xx가 아닌 최종 응답이 수신 될 수 있습니다. 4xx,
   5xx 및 6xx 응답에는 Contact 헤더 필드 값이 포함될 수 있습니다.
   오류에 대한 추가 정보가있는 위치를 나타냅니다.
   찾을수있다. 후속 최종 응답 (오직 도착할 것입니다.
   오류 조건 하에서) 반드시 무시되어야한다.

   모든 초기 대화 상자는
   비 2xx 최종 응답.




Rosenberg, et. al. 표준 트랙 [81 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   2xx가 아닌 최종 응답을받은 후 UAC 코어
   INVITE 트랜잭션이 완료된 것으로 간주합니다. INVITE 클라이언트
   트랜잭션은 응답에 대한 ACK 생성을 처리합니다 (
   섹션 17).

13.2.2.4 2xx 응답

   여러 2xx 응답이 단일 INVITE에 대해 UAC에 도착할 수 있습니다.
   포크 프록시로 인한 요청 각 응답은 다음과 같이 구분됩니다.
   To 헤더 필드의 태그 매개 변수는 각각
   고유 한 대화 상자 식별자로 구분 된 대화 상자.

   2xx 응답의 대화 상자 식별자가 대화 상자와 일치하면
   기존 대화 상자의 식별자. 대화 상자는로 전환되어야합니다.
   "확인 된"상태이고 대화 상자에 설정된 라우트는 반드시
   섹션 2의 절차를 사용하여 2xx 응답을 기반으로 재 계산
   12.2.1.2. 그렇지 않으면 "확인 된"상태의 새 대화 상자가 있어야합니다.
   12.1.2 절의 절차를 사용하여 건설되었다.

      재 계산되는 상태의 유일한 부분은 경로입니다.
      세트. 가장 높은 순차 번호와 같은 상태의 다른 부분
      (원격 및 로컬) 대화 상자 내에서 보내지는 것은 다시 계산되지 않습니다. 그만큼
      라우트 세트는 이전 버전과의 호환성을 위해 다시 계산됩니다. RFC
      2543은에서 Record-Route 헤더 필드의 미러링을 요구하지 않았다.
      1xx, 2xx. 그러나 우리는

전체 상태를 업데이트하다
      대화 상자 요청은 중간 대화 요청이
      예를 들어 시퀀스 번호를 수정하는 초기 대화 상자.

   UAC 코어는 수신 된 각 2xx에 대한 ACK 요청을 생성해야한다 (MUST)
   트랜잭션 계층. ACK의 헤더 필드가 구성됩니다.
   대화 상자 내에서 전송 된 요청과 동일한 방식으로
   12)와 관련된 CSeq 및 헤더 필드를 제외하고는
   입증. CSeq 헤더 필드의 시퀀스 번호는 반드시
   INVITE가 인정되는 것과 같지만 CSeq 방법은 반드시
   ACK 여야합니다. ACK는 INVITE와 동일한 자격증 명을 포함해야합니다 (MUST). 만약
   2xx는 오퍼 (위의 규칙에 기반 함)를 포함하고, ACK는
   그 시체에서 대답을 나른다. 2xx 응답의 제안이
   허용 가능한 경우, UAC 코어는 ACK에서 유효한 응답을 생성해야하며,
   즉시 BYE를 보냅니다.

   일단 ACK가 구성되면, [4]의 절차는
   대상 주소, 포트 및 전송을 결정합니다. 그러나
   요청은 전송을 위해 전송 계층으로 직접 전달되고,
   클라이언트 트랜잭션이 아닌 이는 UAC 코어
   트랜잭션 계층이 아닌 ACK의 재전송을 처리합니다. 그만큼
   ACK는 매번 클라이언트 전송에 전달되어야합니다.
   ACK를 트리거 한 2xx 최종 응답의 재전송
   도착합니다.



Rosenberg, et. al. 표준 트랙 [82 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   UAC 코어는 64 * T1 초 동안 완료된 INVITE 트랜잭션을 고려합니다.
   첫 번째 2xx 응답 수신 후 이 시점에서 모든
   설정된 대화 상자로 전환되지 않은 초기 대화 상자는 다음과 같습니다.
   종료 됨. INVITE 트랜잭션이 완료되면
   UAC 코어, 새로운 2xx 응답은 더 이상 도착하지 않을 것으로 예상됩니다.

   INVITE에 대한 2xx 응답을 승인 한 후 UAC가
   해당 대화 상자를 계속 사용하지 않으려면 UAC가 종료해야합니다.
   BYE 요청을 제 15 절에서 설명한대로 전송하여 대화 상자를 작성하십시오.

13.3 UAS 처리

13.3.1 INVITE 처리

   UAS 코어는 트랜잭션 계층으로부터 INVITE 요청을 수신합니다.
   먼저 8.2 절의 요청 처리 절차를 수행하고,
   대화 상자의 내부 및 외부 요청 모두에 적용됩니다.

   이러한 처리 상태가
   응답을 수신하면 UAS 코어는 추가 처리 단계를 수행합니다.

      1. 요청이 Expires 헤더를 포함하는 INVITE 인 경우
         필드에서 UAS 코어는 초 단위의 타이머를 설정합니다
         헤더 필드 값에 표시됩니다. 타이머가 작동하면
         초대장이 만료 된 것으로 간주됩니다. 초대장
         UAS가 최종 응답을 생성하기 전에 만료되며, 487
         (Request Terminated) 응답이 생성되어야한다.

      2. 요청이 중간 대화 요청 인 경우, 메소드 독립적
         먼저 12.2.2 절에 설명 된 처리가 적용됩니다. 이것
         세션을 수정할 수도 있습니다. 14 절에서 자세한 내용을 제공합니다.

      3. 요청에 To 헤더 필드에 태그가 있지만 대화 상자
         식별자가 기존 대화 상자와 일치하지 않으면 UAS
         오류가 발생하여 다시 시작되었거나 요청을 받았을 수 있습니다.
         다른 (아마도 실패한) UAS의 경우. 12.2.2 절
         그러한 상황에서 강력한 행동을 달성하기위한 지침.

   여기에서 처리하는 것은 INVITE가
   따라서 새로운 세션을 수립 할 목적으로 사용됩니다.

   INVITE는 세션 설명을 포함 할 수 있으며,이 경우 UAS
   해당 세션에 대한 제안이 제시됩니다. 것이 가능하다
   사용자가 이미 해당 세션에 참여하고 있음을
   INVITE는 대화 상자 외부에 있습니다. 이 문제는 사용자가
   여러 다른 사람이 같은 멀티 캐스트 회의에 초대했습니다.
   참가자. 원하는 경우, UAS는
   이 중복을 감지하는 세션 설명 예를 들어 SDP



Rosenberg, et. al. 표준은 궤 [83 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   원본 (o) 필드에 세션 ID와 버전 번호가 들어 있습니다. 만약
   사용자가 이미 세션의 구성원이고 세션
   세션 설명에 포함 된 매개 변수가 변경되지 않은 경우
   UAS는 자동으로 INVITE를 수락 할 수 있습니다 (즉, 2xx 응답을 보냅니다
   사용자에게 메시지를 표시하지 않음).

   INVITE에 세션 설명이 없으면 UAS는
   세션에 참여하도록 요청 받았으며 UAC는
   UAS는 세션의 제안을 제공합니다. 반드시 제안을 제공해야합니다.
   UAC로 되돌아 오는 최초의 실패없는 신뢰할 수있는 메시지. 이
   사양, 즉 INVITE에 대한 2xx 응답입니다.

   UAS는 진행 상황을 나타내거나, 수락하거나, 리디렉션하거나, 거부 할 수 있습니다.
   초대. 이 모든 경우에있어 다음을 사용하여 응답을 공식화합니다.
   섹션 8.2.6에 설명 된 절차.

13.3.1.1 진행 상황

   UAS가 초대장에 즉시 응답 할 수없는 경우
   UAC에 어떤 종류의 진행 상황을 나타내도록 선택하십시오 (예를 들어,
   전화가 울리는 표시). 이것은
   임시 응답은 101과 199 사이입니다.
   응답은 초기 대화를 설정하므로 절차를 따르십시오.
   섹션 8.2.1의 섹션 12.1.1. UAS MAY
   많은 잠정적 인 응답을 좋아하는만큼 보냅니다. 이들 각각은 반드시
   동일한 대화 ID를 나타냅니다. 그러나 이것들은 배달되지 않을 것입니다.
   안정적으로

   UAS가 INVITE에 대답하기 위해 연장 된 시간을 원하면,
   프록시를 방지하려면 "확장"을 요청해야합니다.
   거래 취소에서. 프록시에는 취소 옵션이 있습니다.
   응답 사이에 3 분의 간격이있을 때 트랜잭션
   트랜잭션. 취소를 방지하기 위해 UAS는 비 100
   가능성을 다루기 위해 매 순간 임시 응답
   임시 응답을 잃었습니다.

      INVITE 트랜잭션은 확장 된 기간 동안 계속 될 수 있습니다.
      사용자가 보류 상태에 있거나 PSTN 시스템과 연동 할 때
      응답 없이도 통신이 가능합니다.
      요구. 후자는 대화 형 음성 응답 (IVR)
      시스템.

13.3.1.2 INVITE가 재전송됩니다.

   UAS가 통화를 재전송하기로 결정하면 3xx 응답이 전송됩니다. 에이
   300 (복수 선택), 301 (영구 이사) 또는 302 (이사
   임시 응답) 응답은 Contact 헤더 필드를 포함해야한다 (SHOULD).




Rosenberg, et. al. 표준 트랙 [Page 84]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   시도 할 새 주소의 URI를 하나 이상 포함합니다. 그만큼
   응답은 INVITE 서버 트랜잭션으로 전달되어 트랜잭션을 처리합니다.
   재전송과 함께.

13.3.1.3 INVITE가 거절 됨

   일반적인 시나리오는 피 호출자가 현재 기꺼이하지 않거나
   이 최종 시스템에서 추가 통화를 할 수 있습니다. A 486 (여기에서 바쁜)
   그러한 시나리오에서 리턴되어야한다. UAS가
   다른 최종 시스템에서이 호출을 수락 할 수 있습니다. 600 (통화 중
   Everywhere) 응답이 대신 보내 져야합니다 (SHOULD). 그러나, 그것은있을 법하지 않습니다.
   UAS가 일반적으로이 사실을 알 수 있기 때문에
   응답은 일반적으로 사용되지 않습니다. 응답은
   INVITE 서버 트랜잭션으로 재전송을 처리합니다.

   INVITE에 포함 된 제안을 거부하는 UAS는 488
   (여기에 수용 할 수 없음) 응답. 그러한 응답에는 a를 포함해야한다.
   쿠폰이 거부 된 이유를 설명하는 경고 헤더 필드 값입니다.

13.3.1.4 INVITE가 수락 됨

   UAS 코어는 2xx 응답을 생성합니다. 이 응답은
   대화 상자이므로 12.1.1 절의 절차를 따르십시오.
   8.2.6 절에 추가 된 것.

   INVITE에 대한 2xx 응답은 Allow 헤더 필드와
   지원되는 헤더 필드를 포함하고, Accept 헤더 필드를 포함 할 수있다.
   이러한 헤더 필드를 포함 시키면 UAC가
   UAS가 지원하는 기능 및 확장 기능은
   전화하지 않고.

   INVITE 요청에 오퍼가 포함되어 있고 UAS가 아직 제공하지 않은 경우
   대답을 보낸 2xx는 대답을 포함해야합니다. 초대가 한 경우
   오퍼를 포함하고 있지 않은 경우, 2xx는 UAS가
   제안을 아직 보내지 않았다.

   응답이 구성되면 INVITE로 전달됩니다.
   서버 트랜잭션. 그러나 INVITE 서버
   거래가 최종 결정을받는대로 즉시 파기됩니다.
   응답을 전송에 전달합니다. 그러므로, 그것은 필요하다.
   때까지 주기적으로 응답을 전송에 직접 전달합니다.
   ACK가 도착합니다. 2xx 응답은
   T1 초에서 시작하여 각각에 대해 두 배의 간격
   T2 초가 될 때까지 재전송 (T1과 T2는
   섹션 17). 응답 재전송은
   응답이 수신됩니다. 이것은 어떤 운송 수단과도 독립적입니다.
   프로토콜은 응답을 보내는 데 사용됩니다.




Rosenberg, et. al. 표준 트랙 [85 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      2xx는 종단 간에서 재전송되므로 홉이있을 수 있습니다.
      UDP 인 UAS 및 UAC 전반적으로 안정적인 배송을 보장하려면
      이러한 홉, 응답은 정기적으로 재전송됩니다 비록
      UAS에서의 운송은 신뢰성이 있습니다.

   서버가 64 * T1 초 동안 2xx 응답을 재전송하면
   ACK를 받으면 대화 상자는 확인되지만 세션이 있어야합니다.
   종료 됨. 이 작업은 BYE를 사용하여 수행 할 수 있습니다.
   15.

14 기존 세션 수정

   성공적인 INVITE 요청 (섹션 13 참조)은
   두 사용자 에이전트 간의 대화 및 제안 응답을 사용하는 세션
   모델. 섹션 12에서는 a를 사용하여 기존 대화 상자를 수정하는 방법을 설명합니다.
   대상 새로 고침 요청 (예 : 원격 대상 URI 변경
   대화 상자의). 이 섹션에서는 실제
   세션. 이 수정은 주소 또는 포트 변경,
   미디어 스트림 추가, 미디어 스트림 삭제 등이 포함됩니다. 이것은
   같은 다이얼로그 내에서 새로운 INVITE 요청을 전송함으로써 달성된다.
   그 세션을 수립했다. 내부에서 보낸 INVITE 요청
   기존 대화를 re-INVITE라고합니다.

      단일 re-INVITE는 대화 상자와 대화 상자를 수정할 수 있습니다.
      같은 시간에 세션의 매개 변수.

   발신자 또는 수신자가 기존 세션을 수정할 수 있습니다.

   미디어 장애 탐지에 대한 UA의 동작은
   지역 정책. 그러나 re-INVITE 또는 BYE의 자동화 된 생성은 다음과 같습니다.
   네트워크에 트래픽이 넘치지 않도록 권장하지 않습니다.
   혼잡입니다. 어떤 경우이 메시지가 전송되면
   자동적으로, 그들은 어떤 무작위 간격 후에 보내야한다.

      위의 단락은 자동으로 생성 된 것을 나타냅니다.
      BYEs 및 re-INVITE. 사용자가 미디어 장애시 전화를 끊으면
      UA는 평소와 같이 BYE 요청을 보냅니다.

14.1 UAC 동작

   다음과 같은 세션 설명에 적용되는 동일한 제안 응답 모델
   INVITE (13.2.1 절)는 re-INVITE에 적용됩니다. 결과적으로, UAC
   예를 들어 미디어 스트림을 추가하려는 사용자는 새로운
   이 미디어 스트림이 포함 된 쿠폰을 보내고 INVITE로 보냅니다.
   요청을 피어에게 보냅니다. 전체 내용이
   변경 사항뿐만 아니라 세션에 대한 설명이 전송됩니다. 이
   다양한 요소에서 스테이트리스 세션 처리를 지원하며
   장애 복구 및 복구 기능을 지원합니다. 물론, UAC MAY



Rosenberg, et. al. 표준 트랙 [86 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   세션 설명이없는 re-INVITE를 보냅니다.이 경우 첫 번째
   re-INVITE에 대한 신뢰할 수있는 실패하지 않은 응답은 제안을 포함합니다.
   (이 사양에서는 2xx 응답).

   세션 설명 형식에 버전 기능이있는 경우
   오퍼 레 커는 세션의 버전을 표시해야합니다 (SHOULD)
   설명이 변경되었습니다.

   re-INVITE의 To, From, Call-ID, CSeq 및 Request-URI가 설정됩니다.
   기존 규칙과 동일한 규칙에 따라
   대화 상자에서 설명합니다.

   UAC는 Alert-Info 헤더 필드 또는 다음과 같은 본문을 추가하지 않을 수도 있습니다 (MAY).
   UAS가 제공하지 않기 때문에 다시 보내려는 내용 - 처분 "경고"
   일반적으로 re-INVITE의 수신시 사용자에게 경고합니다.

   포크 할 수있는 INVITE와는 달리 re-INVITE는 결코 포크를 실행하지 않습니다.
   따라서 단 하나의 최종 응답 만 생성합니다. 이유는
   re-INVITE는 결코 Request-URI가
   UA 인스턴스로 대상을 지정하는 대신 대화 상자를 설정합니다.
   상기 사용자에 대한 레코드 - 주소를 식별하는 단계를 포함하는 방법.

   UAC는 a에서 새로운 INVITE 트랜잭션을 시작해서는 안된다.
   대화 상자에서 다른 INVITE 트랜잭션이 진행 중일 때
   방향.

      1. 진행중인 INVITE 클라이언트 트랜잭션이있는 경우, TU는
         트랜잭션이 완료되거나 종료 될 때까지 기다린다.
         새로운 INVITE를 시작하기 전에

      2. 진행중인 INVITE 서버 트랜잭션이있는 경우, TU는
         거래가 확인되거나 종료 될 때까지 기다린다.
         새 INVITE를 시작하기 전에

   그러나 UA는 INVITE 동안 정규 거래를 시작할 수있다.
   거래가 진행 중입니다. UA는 또한 초대를 시작할 수있다.
   통상 거래가 진행되는 동안

   UA가 re-INVITE에 대해 2xx가 아닌 최종 응답을 수신하면 세션
   re-INVITE가 발행되지 않은 것처럼 매개 변수는 변경되지 않고 유지되어야합니다.
   12.2.1.2 절에서 언급했듯이 2xx가 아닌 최종본
   응답은 481 (Call / Transaction Does Not Exist)이거나 408
   (Request Timeout), 또는 전혀 응답이 없으면,
   INVITE (즉, INVITE 클라이언트가 시간 초과를 반환합니다.
   트랜잭션), UAC는 대화 상자를 종료합니다.






Rosenberg, et. al. 표준 트랙 [87 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   UAC가 re-INVITE에 대한 491 응답을 수신하면 UAC는
   다음과 같이 선택된 T 값을 갖는 타이머 :

      1. UAC가 대화 ID의 Call-ID 소유자 인 경우
         (그것이 값을 생성한다는 의미), T는 무작위로 선택된 값을가집니다.
         2.1 초에서 4 초 사이에 10ms 단위로 표시됩니다.

      2. UAC가 다이얼로그 ID의 Call-ID의 소유자가 아닌 경우, T
         0에서 2 초 사이의 임의로 선택된 값을 단위로가집니다.
         10ms.

   타이머가 작동하면 UAC는 re-INVITE를 다시 시도해야하며,
   세션 수정이 여전히 필요하다면 에 대한
   예를 들어, 호출이 BYE로 이미 중단 된 경우 re-INVITE
   일어나지 않을거야.

   re-INVITE를 전송하고 ACK를 생성하기위한 규칙
   re-INVITE에 대한 2xx 응답은 초기 INVITE에 대한 응답과 동일합니다
   (13.2.1 절).

14.2 UAS 동작

   13.3.1 절에서는 들어오는 것을 구분하는 절차를 설명합니다.
   들어오는 초기 INVITE에서 re-INVITE하고 re-INVITE를 처리합니다.
   기존 대화 상자.

   두 번째 초대를받는 UAS가 최종을 보냅니다.
   에 낮은 CSeq 시퀀스 번호가있는 첫 번째 INVITE에 대한 응답
   동일한 대화 상자는 반드시 500 (서버 내부 오류) 응답을
   두 번째 INVITE와 함께 Retry-After 헤더 필드를 포함해야한다.
   임의로 선택한 값은 0에서 10 초 사이입니다.

   대화 상대가 INVITE를 보낸 동안 INVITE를받는 UAS
   진행중인 대화 상자에서 491 (Request Pending)
   수신 된 INVITE에 대한 응답.

   UA가 기존 대화 상자에 대해 re-INVITE를 수신하면 UA는
   세션 설명에있는 모든 버전 식별자 또는 존재하는 경우
   버전 식별자 없음, 볼 세션 설명의 내용
   변경된 경우. 세션 설명이 변경된 경우 UAS
   가능하면 요청한 후에 세션 매개 변수를 적절하게 조정해야합니다.
   확인을 위해 사용자.

      세션 설명의 버전 관리를 사용하여
      회의에 새로 도착한 사람의 기능, 추가 또는 삭제
      미디어를 변경하거나 유니 캐스트에서 멀티 캐스트 회의로 변경할 수 있습니다.





Rosenberg, et. al. 표준품 [88 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   새로운 세션 설명이 수용 가능하지 않은 경우, UAS는
   재사용을위한 488 (Not Acceptable Here) 응답을 리턴함으로써,
   초대. 이 응답은 Warning 헤더 필드를 포함해야한다.

   UAS가 2xx 응답을 생성하고 ACK를 수신하지 않으면
   BYE를 생성하여 대화 상자를 종료해야합니다 (SHOULD).

   UAS는 재전송을위한 180 (Ringing) 응답을 생성하지 않기로 선택할 수있다.
   INVAC는 UAC가 일반적으로이 정보를
   사용자. 같은 이유로 UAS는 Alert-Info를 사용하지 않기로 선택할 수도있다.
   응답에서 Content-Disposition "alert"가있는 본문 필드 또는 본문
   다시 INVITE하는 것.

   2xx에 오퍼를 제공하는 UAS (INVITE에
   제안)는 마치 UAS가
   새로운 통화, 그 제안을 보내는 제약 조건
   SDP의 경우 [13]에서 설명한대로 기존 세션을 업데이트합니다.
   특히 이것은 많은 미디어 형식을 포함해야 함을 의미합니다
   UA가 지원하고자하는 미디어 유형 등이 있습니다. UAS는 반드시
   세션 설명이 이전 세션과 중복되는지 확인하십시오.
   미디어 형식, 전송 또는 기타 매개 변수의 세션 설명
   피어의 지원이 필요합니다. 이것은 필요성을 피하기위한 것입니다.
   피어는 세션 기술을 거부한다 그러나 그것이
   UAC는 용납 될 수 없으며, UAC는
   유효한 세션 설명을 입력 한 다음 BYE를 전송하여
   세션.

15 세션 종료

   이 절에서는 세션 종료 절차에 대해 설명합니다.
   SIP에 의해 설립되었습니다. 세션의 상태와
   대화는 매우 밀접하게 관련되어 있습니다. 세션이
   INVITE, 고유 한 UAS의 각 1xx 또는 2xx 응답은
   대화 상자를 열고 응답이 제안 / 답변 교환을 완료하면
   또한 세션을 만듭니다. 결과적으로 각 세션은 "연관"
   하나의 대화 상자가 생성되었습니다. 만약
   초기 INVITE는 2xx가 아닌 최종 응답을 생성하며 종료됩니다.
   모든 세션 (있는 경우) 및 작성된 모든 대화 상자 (있는 경우)
   요청에 대한 응답을 통해 완료를 통해
   트랜잭션이 아닌 2xx 최종 응답도 추가 세션을 방지합니다.
   INVITE의 결과로 생성되는 것을 방지합니다. BYE 요청은
   특정 세션 또는 시도한 세션을 종료하는 데 사용됩니다. 이
   특정 세션은 다른 세션에서 피어 UA가있는 세션입니다.
   대화 상자의 BYE가 대화 상자에서 수신되면 모든 세션
   그 다이얼로그와 관련된 SHOULD가 종료되어야한다. UA는
   BYE가 대화 상자 외부에 있습니다. 발신자의 UA는 BYE를
   확정 된 또는 조기 대화, 피 호출자의 UA는 BYE를
   확인 된 대화 상자를 표시하지만 초기 대화 상자에서는 BYE를 보내면 안됩니다.



Rosenberg, et. al. 표준 트랙 [89 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   그러나, 피 호출자의 UA는 확인 된 대화 상자에서 BYE를 전송해서는 안된다
   2xx 응답에 대한 ACK를 수신하거나 서버가 응답 할 때까지
   트랜잭션 시간 초과. 다른 SIP 확장이 정의되지 않은 경우
   대화 상자와 관련된 응용 프로그램 계층 상태, BYE
   대화 상자를 종료합니다.

   대화에 INVITE에 대한 2xx가 아닌 최종 응답의 영향 및
   세션을 사용하면 CANCEL을 매력적으로 사용할 수 있습니다. CANCEL은 다음을 시도합니다.
   INVITE (특히 a 487)에 2xx가 아닌 응답을 강제합니다.
   따라서 UAC가 통화 시도를 완전히 포기하고 싶다면,
   CANCEL을 보낼 수 있습니다. INVITE 결과가 2xx 최종 응답 인 경우,
   INVITE에 UAS가 초대를 수락했다는 것을 의미합니다.
   CANCEL이 진행 중입니다. UAC는 세션을 계속할 수 있습니다
   2xx 응답으로 설정하거나 BYE로 종료 할 수 있습니다.

      "전화 끊기"의 개념은 SIP 내에서 잘 정의되어 있지 않습니다. 그것은
      (일반적이지만 특정 사용자 인터페이스에만 해당).
      일반적으로 사용자가 전화를 끊으면 욕구가 있음을 나타냅니다.
      세션을 설정하려는 시도를 종료하고,
      세션이 이미 생성되었습니다. 발신자의 UA의 경우 이것은
      최초 INVITE가 최종을 생성하지 않은 경우 CANCEL 요청
      응답 및 최종 확인 후 확인 된 대화 상자 모두에 대한 BYE
      응답. 피 호출자의 UA는 일반적으로 BYE를 암시합니다.
      아마도, 사용자가 전화를 받았을 때, 2xx는
      생성 된 후 응답하지 않으면 ACK 이후 BYE가 발생합니다.
      수신되었습니다. 이것은 사용자가 전에 전화를 끊을 수 없다는 것을 의미하지는 않습니다.
      ACK 수신, 그것은 단지 자신의 전화에있는 소프트웨어
      청소를 위해 잠시 동안 상태를 유지할 필요가있다.
      정확히. 특정 UI가 사용자가
      403 (금지됨)은 좋은 방법입니다.
      그것을 표현하십시오. 위의 규칙에 따라 BYE를 보낼 수 없습니다.

15.1 BYE 요청으로 세션 종료

15.1.1 UAC 동작

   BYE 요청은 다른 모든 요청과 마찬가지로 구성됩니다.
   대화 상자를 엽니 다.

   일단 BYE가 구성되면 UAC 코어는 새로운 비 -INITE를 생성합니다
   클라이언트 트랜잭션을 처리하고 BYE 요청을 전달합니다. UAC는 반드시
   세션이 종료 된 것으로 간주하여 전송 또는
   BYE 요청이 요청에 전달되는 즉시 미디어 청취)
   클라이언트 트랜잭션. BYE에 대한 응답이 481
   (호출 / 트랜잭션이 존재하지 않음) 또는 408 (요청 시간 초과) 또는 아니오






Rosenberg, et. al. 표준 트랙 [Page 90]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   BYE에 대한 응답이 모두 수신됩니다 (즉, 제한 시간은
   클라이언트 트랜잭션에 의해 반환 된), UAC는 반드시
   세션이 종료되고 대화 상자가 종료됩니다.

15.1.2 UAS 작동

   UAS는 일반적인 UAS에 따라 BYE 요청을 먼저 처리한다
   처리는 섹션 8.2에서 설명합니다. BYE를 수신하는 UAS 코어
   요청이 기존 대화와 일치하는지 확인합니다. BYE가
   기존 대화 상자와 일치하면 UAS 코어는 481을 생성해야합니다 (SHOULD).
   (Call / Transaction Does Not Exist) 응답을 받고이를
   서버 트랜잭션.

      이 규칙은 UAC에 의해 태그없이 전송 된 BYE가
      거절 당했다. 이는 RFC 2543의 변경 사항으로 BYE
      태그없이.

   기존 대화에 대한 BYE 요청을 수신하는 UAS 코어는 반드시 따라야합니다
   요청을 처리하기 위해 12.2.2 절의 절차. 완료되면,
   UAS는 세션을 종료해야한다.
   미디어 청취). 하지 않을 수있는 유일한 경우
   멀티 캐스트 세션. 다른 세션
   대화의 참가자는
   세션. 세션 참여를 끝내 든 아니든,
   UAS 코어는 BYE에 2xx 응답을 생성해야하며 반드시 통과해야한다.
   서버 트랜잭션에 전송합니다.

   UAS는 그 동안 수신 된 보류중인 요청에 대해 계속해서 응답해야합니다 (MUST).
   대화. 487 (Request Terminated) 응답이 권장됩니다
   보류중인 요청으로 생성 될 수 있습니다.

16 프록시 동작

16.1 개요

   SIP 프록시는 SIP 요청을 사용자 에이전트로 라우팅하는 요소입니다.
   서버 및 사용자 에이전트 클라이언트에 대한 SIP 응답. 요청은
   UAS로가는 도중에 여러 프록시를 통과합니다. 각각은 라우팅을 만들 것입니다.
   의사 결정, 요청을 다음으로 전달하기 전에 수정
   요소. 응답은 동일한 프록시 집합을 통해 라우팅됩니다.
   요청에 의해 역순으로 횡단됩니다.

   프록시 란 SIP 요소의 논리적 역할입니다. 요청이있을 때
   도착하면 프록시의 역할을 할 수있는 요소가 먼저 결정됩니다.
   자체 요청에 응답해야하는 경우 예를 들어,
   요청이 잘못되었거나 요소가
   프록시로 작동하기 전에 클라이언트. 요소는 어떤 것으로도 응답 할 수있다.




Rosenberg, et. al. 표준 트랙 [쪽 91]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   적절한 오류 코드. 요청에 직접 응답 할 때
   엘리먼트가 UAS의 역할을하고 있으며 반드시 다음과 같이 행동해야한다.
   섹션 8.2.

   프록시는 각각에 대해 상태 저장 모드 또는 상태 비 저장 모드로 작동 할 수 있습니다.
   새로운 요청. 무국적자 일 경우, 프록시는 간단한 전달 역할을합니다.
   요소. 각 요청을 단일 요소로 전달합니다
   타겟팅 및 라우팅 결정을 통해 결정됩니다.
   의뢰. 업스트림을받는 모든 응답을 전달합니다. 에이
   stateless proxy는 메시지에 관한 정보를 폐기합니다.
   전달되었습니다. 상태 저장 프록시는 정보를 기억합니다.
   들어오는 각 요청에 대한 트랜잭션 상태 (구체적으로 트랜잭션 상태)
   들어오는 요청을 처리 한 결과로 보내는 요청. 이것
   이 정보를 사용하여 향후 메시지 처리에 영향을줍니다.
   해당 요청과 관련됩니다. 상태 보존 형 프록시는 "fork"
   요청을 여러 목적지로 라우팅합니다. 요청은
   하나 이상의 위치로 전달 된 정보는 반드시 정체되어 처리되어야합니다.

   어떤 상황에서는, 프록시는 상태 저장을 사용하여 요청을 전달할 수있다 (MAY)
   (TCP와 같은) 전송을 트랜잭션 상태를 유지하지 않고 수행 할 수 있습니다. 에 대한
   예를 들어, 프록시는 하나의 TCP 연결에서 요청을
   다른 트랜잭션은 상태가 유지되면 충분하다.
   응답을 전달할 수있는 메시지의 정보
   요청이 도착한 것과 동일한 연결입니다. 전달 된 요청
   프록시의 TU가 취해야하는 다양한 유형의 전송 간
   전송 중 하나에서 안정적인 전달을 보장하는 적극적인 역할
   반드시 statefully 트랜잭션을 전달해야합니다.

   상태 저장 프록시는 언제든지 무국적 운영으로 전환 할 수 있습니다
   요청을 처리하는 동안 아무 것도하지 않는 한
   그렇지 않으면 초기에 상태가 유지되지 않도록합니다.
   (예를 들어, 포크 또는 100 응답 생성). 언제
   이러한 전환을 수행하면 모든 상태가 단순히 삭제됩니다. 그만큼
   프록시는 CANCEL 요청을 시작해서는 안됩니다 (SHOULD NOT).

   무국적으로 또는 정 성적으로 행동 할 때 관련된 많은 처리
   요청은 동일합니다. 다음 몇 개의 하위 섹션이 작성됩니다.
   상태 보존 형 프록시의 관점에서 볼 때 마지막 섹션 호출
   무국적 프록시가 다르게 행동하는 곳.

16.2 상태 유지 프록시

   Stateful 일 때, 프록시는 순전히 SIP 트랜잭션 처리 엔진입니다.
   그 행동은 서버와 클라이언트 측면에서 모델링됩니다.
   트랜잭션은 섹션 17에 정의되어 있습니다. 상태 저장 프록시에는 서버
   하나 이상의 클라이언트 트랜잭션과 연관된 트랜잭션
   상위 계층 프록시 처리 구성 요소 (그림 3 참조)
   프록시 코어. 들어오는 요청은 서버에 의해 처리됩니다.



Rosenberg, et. al. 표준은 궤 [92 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   트랜잭션. 서버 트랜잭션의 요청은
   프록시 코어. 프록시 코어는 요청을 라우팅 할 위치를 결정하고,
   하나 이상의 다음 홉 위치를 선택합니다. 에 대한 나가는 요청
   각 다음 홉 위치는 자체의 연결된 클라이언트에 의해 처리됩니다.
   트랜잭션. 프록시 코어는 클라이언트로부터 응답을 수집합니다.
   트랜잭션을 생성하고이를 사용하여 서버에 응답을 보냅니다.
   트랜잭션.

   상태 저장 프록시는 새로운 각각에 대해 새 서버 트랜잭션을 만듭니다.
   요청을 받았습니다. 그러면 요청의 재전송은
   섹션 17에 따라 해당 서버 트랜잭션에 의해 처리됩니다. 프록시 코어
   즉각적인 provisional을 보내는 것과 관련하여 UAS로서 행동해야한다.
   해당 서버 트랜잭션 (예 : 100 Trying)에서 설명한대로
   8.2.6 절. 따라서 상태 저장 프록시는 100을 생성해서는 안됩니다 (SHOULD NOT).
   (Trying) 비 INVITE 요청에 대한 응답.

   이것은 프록시 동작 모델이며 소프트웨어가 아닙니다. 안
   구현은 자유롭게 복제 할 수 있습니다.
   이 모델이 정의한 외부 행동.

   알 수없는 메소드를 포함하여 모든 새 요청에 대해 요소
   요청을 대변하고자하는 경우 :

      1. 요청 검증 (16.3 절)

      2. 라우팅 정보 사전 처리 (16.4 절)

      3. 요청에 대한 목표 결정 (16.5 절)

            + -------------------- +
            | | + --- +
            | | | C |
            | | | T |
            | | + --- +
      + --- + | 프록시 | + --- + CT = 고객 거래
      | S | | "상위 계층"| | C |
      | T | | | | T | ST = 서버 트랜잭션
      + --- + | | + --- +
            | | + --- +
            | | | C |
            | | | T |
            | | + --- +
            + -------------------- +

               그림 3 : 상태 기반 프록시 모델






Rosenberg, et. al. 표준 트랙 [93 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      4. 각 대상에게 요청 전달 (16.6 절)

      5. 모든 응답 처리 (16.7 절)

16.3 요청 확인

   엘리먼트가 요청을 프록시하기 전에 반드시 엘리먼트의 메시지를 검증해야한다.
   효력. 유효한 메시지는 다음 검사를 통과해야합니다.

      1. 합리적인 구문

      2. URI 스킴

      3. 맥스 - 포워드

      4. (선택 사항) 루프 감지

      5. 프록시 - 요구 사항

      6. 프록시 인증

   이러한 검사 중 하나라도 실패하면 요소는 사용자 에이전트로 작동해야합니다 (MUST).
   서버 (8.2 절 참조)를 사용하고 오류 코드로 응답하십시오.

   병합 된 요청을 검색하는 데 프록시가 필요하지 않으며
   merg을 다루어서는 안됨

ed 요청을 오류 조건으로 간주합니다. 엔드 포인트
   요청을 수신하면 섹션에서 설명한대로 병합이 해결됩니다.
   8.2.2.2.

   1. 적절한 구문 확인

      요청은 서버로 처리 할 수있을만큼 잘 형성되어야합니다 (MUST).
      트랜잭션. 이 구성 요소의 나머지 부분에 관련된 모든 구성 요소
      요청 확인 단계 또는 요청 전달 섹션은 반드시 있어야합니다.
      잘 형성되었다. 잘 형성된 지 아닌지에 관계없이 다른 모든 구성 요소가 있어야한다.
      메시지가 전달되면 무시되고 변경되지 않습니다. 에 대한
      예를 들어 요소는 요청으로 인해 요청을 거부하지 않습니다.
      조작 된 날짜 헤더 필드 마찬가지로 프록시는
      요청을 전달하기 전에 잘못된 날짜 헤더 필드.

      이 프로토콜은 확장되도록 설계되었습니다. 향후 확장은
      언제든지 새로운 메소드와 헤더 필드를 정의 할 수 있습니다. 요소는 반드시
      메소드 또는 메소드가 포함되어 있기 때문에 요청을 프록시 할 수 없습니다.
      헤더 필드는 알 수 없습니다.







Rosenberg, et. al. 표준 트랙 [Page 94]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   2. URI 체계 체크

      Request-URI가 URI에 스키마가 이해되지 않는 URI를 갖는 경우
      프록시는 416 (지원되지 않음)으로 요청을 거부해야합니다 (SHOULD).
      URI Scheme) 응답.

   3. 최대 - 포워드 체크

      Max-Forwards 헤더 필드 (20.22 절)는
      SIP 요청이 통과 할 수있는 요소의 수.

      요청에 Max-Forwards 헤더 필드가 없으면
      확인이 통과됩니다.

      요청에 필드가있는 Max-Forwards 헤더 필드가 포함 된 경우
      값이 0보다 큰 경우 검사가 통과됩니다.

      요청에 필드가있는 Max-Forwards 헤더 필드가 포함 된 경우
      값이 0 인 경우 요소는 요청을 전달해서는 안됩니다 (MUST NOT). 만약
      요청은 OPTIONS에 대한 것이었고, 엘리먼트는 final로 동작 할 수있다.
      수신자가 11 절에 따라 응답해야한다. 그렇지 않으면, 요소는 반드시
      483 (너무 많은 홉 수) 응답을 반환합니다.

   4. 선택적 루프 탐지 확인

      요소는 전달하기 전에 전달 루프를 검사 할 수있다.
      의뢰. 요청에 Via 헤더 필드가 포함되어 있고,
      에 의해 이전 요청에 배치 된 값과 동일한 값으로
      프록시에서이 요소에 의해 요청이 전달되었습니다. 그만큼
      요청이 반복되었거나 합법적으로
      요소. 요청이 반복되었는지를 결정하기 위해, 요소 MAY
      8 단계에서 설명한 분기 매개 변수 계산을 수행하십시오.
      이 메시지에 대해 16.6 절을 읽고 매개 변수와 비교한다.
      Via 헤더 필드에서 수신 됨. 매개 변수가 일치하면
      요청이 반복되었습니다. 서로 다르면 요청이 나선형이됩니다.
      처리가 계속됩니다. 루프가 감지되면, MAY
      482 (Loop Detected) 응답을 리턴하십시오.

   5. 프록시 - 요구 체크

      이 프로토콜의 향후 확장은
      프록시에 의한 특별한 처리가 필요합니다. 끝점에는
      프록시 - 이러한 기능을 사용하는 요청의 헤더 필드 필요,
      기능이없는 한 요청을 처리하지 않도록 프록시에 알립니다.
      이해했다.






Rosenberg, et. al. 표준 트랙 [Page 95]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      요청에 Proxy-Require 헤더 필드가 포함 된 경우 (섹션
      20.29) 하나 이상의 옵션 태그를 사용하면이 요소는
      요소가 420 (잘못된 확장)을 반환해야합니다.
      응답. 응답에는 지원되지 않는 섹션 (섹션
      20.40) 헤더 필드는 요소가 가지지 않은 옵션 태그를 나열한다.
      알다.

   6. 프록시 - 권한 부여 확인

      요청을 전달하기 전에 요소에 자격 증명이 필요한 경우,
      요청은 22.3 절에 설명 된대로 검사해야합니다 (MUST). 그
      섹션에서는 검사가 수행 될 때 요소가 수행해야하는 작업도 정의합니다.
      실패합니다.

16.4 경로 정보 전처리

   프락시는 요청의 Request-URI를 검사해야한다 (MUST). 만약
   요청의 Request-URI에는 이전에이 프록시 값이 포함되어 있습니다.
   Record-Route 헤더 필드 (16.6 항목 4 참조)에 놓고
   프락시는 요청의 Request-URI를 마지막으로 대체해야한다
   Route 헤더 필드의 값을
   라우트 헤더 필드. 그런 다음 프록시는 수신 된 것처럼 처리해야합니다
   이 수정 된 요청.

      이 요청은 요청을 보내는 요소가
      프록시 (엔드 포인트 일 수도 있음)는 엄격한 라우터입니다. 이
      하위 호환성을 가능하게하려면 수신시 다시 쓰기가 필요합니다.
      그 요소들. 또한 다음 요소를 허용합니다.
      엄격한 라우팅을 통해 Request-URI를 보존하는 사양
      프록시 (12.2.1.1 절 참조).

      이 요구 사항은 프록시가 상태를 유지할 것을 요구하지 않습니다.
      이전에 Record-Route 헤더 필드에 배치 된 URI를 감지합니다.
      대신 프록시는 해당 URI에 충분한 정보를 배치해야합니다.
      나중에 나타날 때 제공 한 값으로 인식 할 수 있습니다.

   Request-URI에 maddr 매개 변수가 포함되어 있으면 프록시는 반드시 확인해야합니다
   그 값이 주소 또는 도메인 세트에 있는지 알아보기 위해 프록시
   책임있게 구성됩니다. Request-URI가 maddr
   프록시가 담당하는 값이있는 매개 변수 및 요청
   명시된 항구 및 운송 수단을 사용하여 수신되었다 (명시 적으로 또는
   디폴트)를 요구하면, 프록시는 maddr과 any를 제거해야한다 (MUST).
   기본이 아닌 포트 또는 전송 매개 변수로 처리하고 다음과 같이 처리를 계속합니다.
   그 값들은 요청에 나타나지 않았다.







Rosenberg, et. al. 표준 트랙 [Page 96]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      요청은 프록시와 일치하는 maddr와 함께 도착할 수 있지만
      포트 또는 URI에 표시된 것과 다른 전송. 이러한
      표시된 요청을 사용하여 프록시에 요청을 전달해야합니다.
      포트 및 운송.

   Route 헤더 필드의 첫 번째 값이이 프록시를 나타내는 경우,
   프락시는 요청으로부터 그 값을 제거해야한다.

16.5 요청 대상 결정

   그런 다음 프록시는 요청의 대상을 계산합니다. 세트
   목표는 요청 내용에 따라 사전 결정됩니다
   또는 추상적 인 위치 확인 서비스로부터 얻어진다. 각 타겟
   집합의 URI는 URI로 표현됩니다.

   요청의 Request-URI가 maddr 매개 변수를 포함하면
   요청 URI는 유일한 대상으로 설정된 대상에 배치되어야합니다
   URI를 사용하고 프록시는 16.6 절을 진행해야합니다.

   Request-URI의 도메인이 도메인을 나타내는 경우이 요소는
   책임지지 않는다면, Request-URI는 반드시 표적에 배치되어야한다
   유일한 대상으로 설정되고 요소는 다음 작업으로 진행해야합니다.
   요청 전달 (16.6 절).

      대리인이 여러 가지 상황을 겪을 수 있습니다.
      책임이없는 도메인을 요청하십시오. 방화벽 프록시
      나가는 호출 처리 (HTTP 프록시가 나가는 것을 처리하는 방법)
      요청)이 발생할 가능성이있는 예입니다.

   요청에 대한 타겟 집합이 다음과 같이 미리 결정되지 않은 경우
   이는 위에서 설명한 바와 같이 요소가
   도메인은 Request-URI에 포함될 수 있으며, 요소는 어떤 메커니즘
   요청을 보낼 위치를 결정하려고합니다. 이들 중 어느 것
   메커니즘은 추상 위치 서비스에 액세스하는 것으로 모델링 될 수 있습니다.
   이것은 위치 서비스로부터 정보를 얻는 것으로 구성 될 수있다.
   SIP 등록 기관에서 작성한 데이터베이스 읽기, 현재 상태에 대한 컨설팅
   서버를 사용하거나 다른 프로토콜을 사용하거나 단순히
   Request-URI에 대한 알고리즘 대체. 액세스 할 때
   레지스트라에 의해 구축 된 위치 확인 서비스 (Request-URI MUST)
   먼저 사용되기 전에 10.3 절에 설명 된대로 표준화되어야합니다.
   색인으로. 이러한 메커니즘의 출력은
   대상 집합입니다.

   Request-URI가 해당 URI에 대한 충분한 정보를 제공하지 않으면
   프록시는 목표 세트를 결정하기 위해 485 (모호한)
   응답. 이 응답은 Contact 헤더 필드를 포함해야한다 (SHOULD).
   시도 할 새 주소의 URI가 들어 있습니다. 예를 들어, INVITE




Rosenberg, et. al. 표준 트랙 [페이지 97]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   한모금 : John.Smith@company.com은 프록시에서 모호 할 수 있습니다.
   위치 서비스에는 여러 명의 John Smith가 나열되어 있습니다. 섹션 참조
   자세한 내용은 21.4.23을 참조하십시오.

   요청 또는 현재 환경의 모든 정보
   요소는 표적 집합의 구성에 사용될 수있다 (MAY). 에 대한
   예를 들어 내용에 따라 다른 세트를 구성 할 수도 있고
   헤더 필드와 바디의 존재,
   요청의 도착, 요청이 도착한 인터페이스,
   이전 요청의 실패 또는 심지어 요소의 현재 수준
   이용.

   잠재적 인 대상이 이러한 서비스를 통해 위치하므로 URI
   목표 세트에 추가됩니다. 타겟은
   목표를 한 번 설정하십시오. 대상 URI가 이미 세트에있는 경우
   (URI 유형에 대한 평등의 정의에 기반하여),
   다시 추가하십시오.

   프록시는 대상 집합에 추가 대상을 추가해서는 안됩니다 (MUST NOT).
   요청 - 원래 요청의 URI가 리소스를 나타내지 않습니다.
   프록시가 책임을집니다.

      프록시는 요청의 URI 만 변경할 수 있습니다.
      URI에 대한 책임이있는 경우 전달. 프록시가 아닌 경우
      해당 URI에 대한 책임은 3xx 또는 416에서 재발하지 않습니다.
      다음과 같이 응답합니다.

   원래 요청의 Request-URI가 자원을 나타내는 경우
   프록시가 책임을지고 프록시는 계속해서 대상을 추가 할 수 있습니다.
   Request Forwarding을 시작한 후 세트. 어떤 것도 사용할 수 있습니다.
   새로운 목표를 결정하기 위해 그 과정에서 얻어진 정보.
   예를 들어 프록시는에서 얻은 연락처를 통합하도록 선택할 수 있습니다.
   리디렉션 응답 (3xx)을 대상 집합에 추가합니다. 프록시가
   대상 집합을 구성하는 동안 동적 정보 소스 (
   예를 들어 SIP 등록 기관과 상담하는 경우)
   요청을 처리하는 동안 소스. 새 위치
   타겟 세트가 사용 가능 해지면 타겟 세트에 추가해야합니다. 같이
   위의 경우, 주어진 URI는 두 번 이상 집합에 추가되어서는 안된다.

      URI에 집합에 한 번만 추가되도록 허용하면
      불필요한 네트워크 트래픽 및 통합의 경우
      리디렉션 요청의 연락처가 무한 재귀를 방지합니다.

   예를 들어, 사소한 위치 서비스는 "노 - op"입니다.
   대상 URI는 들어오는 요청 URI와 같습니다. 요청이 전송되었습니다.
   추가 처리를 위해 특정 다음 홉 프록시에 전달할 수 있습니다. 요청시





Rosenberg, et. al. 표준 트랙 [Page 98]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   섹션 16.6, 아이템 6의 전달, 다음 홉의 신원,
   SIP 또는 SIPS URI로 표현 된 최상위 경로가 최상위 경로로 삽입됩니다.
   헤더 필드 값을 요청에 추가합니다.

   Request-URI가이 프록시에서 자원을 나타내지 않는 자원을 나타내는 경우
   프록시는 404 (찾을 수 없음) 응답을 반환해야합니다.

   위의 내용 모두를 적용한 후에 대상 세트가 비어있는 경우,
   프록시는 오류 응답을 반환해야합니다 (480).
   (일시적으로 사용할 수 없음) 응답.

16.6 요청 전달

   목표 집합이 비어 있지 않으면 프록시는 전달을 시작할 수 있습니다 (MAY).
   요청. 상태 유지 프록시는 어떤 순서로든 세트를 처리 할 수있다. 이것
   여러 대상을 순차적으로 처리하여 각 클라이언트가
   다음 트랜잭션을 시작하기 전에 트랜잭션을 완료해야합니다. 시작될 수 있습니다.
   모든 대상과 클라이언트 트랜잭션을 병렬로 처리합니다. 또한 MAY
   임의로 집합을 그룹으로 나누고 그룹을 처리합니다.
   순차적으로 각 그룹의 목표를 병렬로 처리합니다.

   공통적 인 정렬 메커니즘은 대상의 qvalue 매개 변수를 사용하는 것입니다.
   Contact 헤더 필드에서 가져옵니다 (섹션 20.10 참조). 목표는
   가장 높은 q 값에서 가장 낮은 값으로 처리됩니다. 동일한 q 값을 가진 대상
   병렬로 처리 될 수 있습니다.

   상태 보존 형 프록시에는 대상 세트를 다음과 같이 유지해야하는 메커니즘이 있어야합니다.
   응답을 수신하고 각 응답에 응답을 연관시킵니다.
   요청을 원래 요청과 함께. 이 모델의 목적을 위해,
   이 메커니즘은 프록시 계층에 의해 생성 된 "응답 컨텍스트"입니다.
   첫 번째 요청을 전달하기 전에

   각 대상에 대해 프록시는 다음과 같은 요청을 전달합니다.
   단계 :

      1.받은 요청 사본을 만듭니다.

      2. 요청 URI 업데이트

      3. Max-Forwards 헤더 필드 업데이트

      4. 선택적으로 Record-route 헤더 필드 값을 추가하십시오

      5. 선택적으로 추가 헤더 필드를 추가하십시오

      6. 포스트 프로세스 라우팅 정보

      7. 다음 홉 주소, 포트 및 전송 결정



Rosenberg, et. al. 표준 트랙 [Page 99]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      8. Via 헤더 필드 값 추가

      9. 필요한 경우 Content-Length 헤더 필드 추가

      10. 새 요청 전달

      타이머 C 설정

   각 단계는 다음과 같습니다.

      1. 요청 복사

         프록시는 수신 된 요청의 사본으로 시작합니다. 사본
         처음에는 모든 헤더 필드를 포함해야합니다.
         받은 요청. 처리 과정에서 상세하지 않은 필드
         아래에 설명 된 내용은 제거해서는 안됩니다. 사본은 유지해야한다.
         수신 한 요구의 헤더 필드의 순서 붙이고
         프록시는 공통 필드로 필드 값을 재정렬해서는 안된다 (MUST NOT).
         이름 (7.3.1 절 참조). 프록시는 서버에 추가, 변경,
         메시지 본문을 제거하십시오.

         실제 구현에서는 복사를 수행 할 필요가 없습니다. 기본
         요구 사항은 각 다음 홉에 대한 처리가
         동일한 요청.

      2. 요청 URI

         사본의 시작 행에있는 Request-URI는
         이 타겟의 URI URI에 매개 변수가 포함 된 경우
         Request-URI에서 허용되지 않는다면 반드시 제거되어야한다.

         이것이 프록시 역할의 본질입니다. 이것이 바로 메커니즘입니다.
         이를 통해 프록시는 목적지로 요청을 라우팅합니다.

         일부 상황에서는 수신 된 Request-URI가
         타겟은 수정되지 않고 설정된다. 해당 타겟의 경우
         위의 대체는 사실상 아무 작업이 아닙니다.

      3. 맥스 - 포워드

         복사본에 Max-Forwards 헤더 필드가 포함되어 있으면 프록시
         그 값을 1 씩 감소시켜야한다 (MUST).

         복사본에 Max-Forwards 헤더 필드가 없으면
         프락시는 70이어야하는 필드 값을 가진 하나를 반드시 추가해야한다.

         일부 기존 UA는 Max-Forwards 헤더 필드를 제공하지 않습니다.
         요청에.



Rosenberg, et. al. 표준 트랙 [Page 100]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      4. 레코드 경로

         이 프록시가 향후 요청 경로에 남아 있기를 희망하는 경우
         이 요청으로 생성 된 대화 상자에서 (요청시
         대화 상자를 생성), Record-Route 헤더 필드를 삽입해야합니다
         기존 Record-Route 헤더보다 먼저 복사본에 값
         Route 헤더 필드가 이미있는 경우에도 필드 값을 무시합니다.

         대화 상자를 설정하는 요청에는 사전로드 된 경로가 포함될 수 있습니다.
         헤더 필드.

         이 요청이 이미 대화 상자의 일부인 경우 프록시는
         남아 있다면 Record-Route 헤더 필드 값을 삽입하십시오.
         대화 상자의 향후 요청 경로에 표시됩니다. 정상적으로
         섹션 12에서 설명 된 엔드 포인트 작동과 관련하여,
         경로 헤더 필드 값은 경로에 영향을 미치지 않습니다.
         엔드 포인트가 사용하는 세트.

         프록시를 삽입하지 않으면 프록시가 경로에 남아 있습니다.
         레코드 - 이미있는 요청에 헤더 필드 값 전달
         대화 상자의 일부 그러나 경로에서 제거됩니다.
         실패한 엔드 포인트가 대화 상자를 재구성 할 때

         프락시는 Record-Route 헤더 필드 값을
         의뢰. 요청이 대화 상자를 시작하지 않으면
         엔드 포인트는 값을 + 시합니다. 자세한 내용은 12 절을 참조하십시오.
         엔드 포인트가 Record-Route 헤더 필드 값을 사용하여
         Route 헤더 필드를 구성하십시오.

         요청 경로의 각 프록시는
         Record-Route 헤더 필드 값을 독립적으로 - 존재
         요청의 Record-Route 헤더 필드는 이것을 강제하지 않는다.
         프록시를 사용하여 값을 추가하십시오.

         Record-Route 헤더 필드 값에 배치 된 URI는 반드시 a이어야한다.
         SIP 또는 SIPS URI. 이 URI는 lr 매개 변수를 포함해야합니다 (
         섹션 19.1.1). 이 URI는 각각 다를 수있다.
         요청이 전달 된 대상. URI는 사용하지 않아야한다.
         프록시에 지식이없는 한 전송 매개 변수를 포함합니다.
         (예 : 사설 네트워크에서) 다음 다운 스트림 요소
         후속 요청의 경로에있을 것입니다
         수송.

         이 프록시가 제공하는 URI는 다른 요소에 의해 사용됩니다
         라우팅 결정을 내린다. 이 프록시는 일반적으로
         요소의 기능을 아는 것
         SIP의 필수 요소로 자체를 제한한다.
         구현 : SIP URI와 TCP 또는 UDP 전송 중 하나.



Rosenberg, et. al. 표준 트랙 [Page 101]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         Record-Route 헤더 필드에 배치 된 URI는
         그것을 삽입하는 요소 (또는 적절한 스탠드 인)는
         [4]의 서버 위치 결정 절차가 적용되어
         후속 요청은 동일한 SIP 요소에 도달합니다. 만약
         Request-URI는 SIPS URI 또는 ​​최상위 Route 헤더를 포함합니다.
         필드 값 (글 머리 기호 6의 사후 처리 이후)에는
         SIPS URI, Record-Route 헤더 필드에 배치 된 URI
         SIPS URI 여야합니다. 또한, 요청이 그렇지 않은 경우
         TLS를 통해 수신 된 경우 프록시는 Record-Route 헤더를 삽입해야합니다
         들. 비슷한 방식으로 요청을받는 프록시
         TLS를 통해 전달되지만 SIPS URI가없는 요청을
         Request-URI 또는 ​​최상위 Route 헤더 필드 값 (게시물 이후
         글 머리 기호 6)의 처리는 Record-Route 헤더를 삽입해야한다.
         필드는 SIPS URI가 아닙니다.

         보안 경계의 프록시는 주변에 남아 있어야합니다.
         대화 상자에서

         Record-Route 헤더 필드에 배치 된 URI가
         응답에서 다시 통과 할 때 재 작성되는 URI
         그 때 찾을 수있을 정도로 구별되어야합니다. (요청
         이 프록시를 통해 나선형으로 표시되어 둘 이상의 결과가 발생할 수 있습니다.
         Record-Route 헤더 필드 값이 추가됨). 항목 8
         16.7 절은 URI를 만드는 메커니즘을 권고한다.
         충분히 구별된다.

         프락시는 Record-Route 헤더에 매개 변수를 포함 할 수있다 (MAY)
         필드 값. 이것들은 몇몇 응답에
         INVITE에 대한 200 (OK) 응답과 같은 요청. 이러한
         매개 변수는 메시지에 상태를 유지하는 데 유용 할 수 있습니다.
         프록시가 아닌

         프록시가 모든 유형의 대화 상자 경로에 있어야하는 경우 (예 :
         하나는 방화벽에 걸 으면서), 그것은 Record-Route를 추가해야만한다
         헤더 필드 값은 모든 요청에 ​​대해 그렇지 않은 방법으로
         이 메소드는 대화 의미론을 가질 수 있기 때문에 이해하십시오.

         프록시가 Record-Route 헤더 필드에 배치하는 URI는
         트랜잭션에 의해 생성 된 모든 대화 상자의 수명 동안 유효합니다.
         그것이 발생합니다. 대화 상자 상태 저장 프록시 (예 : MAY)
         그 값으로 미래의 요청을 받아들이기를 거부합니다.
         요청 - URI 대화 상자가 종료 된 후. 비 대화 상자 -
         물론 상태 저장 프록시에는 대화 상자의 개념이 없습니다.
         종료되었지만, 그들은 충분한 정보를
         값을 미래의 대화 식별자와 비교
         그 정보와 일치하지 않는 요청을 거부 할 수있다.
         종단점은 Record-Route에서 가져온 URI를 사용해서는 안된다
         헤더 필드는 제공된 대화 상자 외부에 있습니다. 만나다



Rosenberg, et. al. 표준 트랙 [Page 102]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         끝점의 사용에 대한 자세한 내용은 12 절을 참조하십시오.
         Record-Route 헤더 필드.

         레코드 라우팅은 특정 서비스에서 필요할 수 있습니다.
         프록시는 대화 상자의 모든 메시지를 관찰해야합니다. 그러나 그것
         처리 속도가 느려지고 확장 성 및 프록시가 손상됩니다.
         특정 서비스에 필요한 경우에만 레코드 경로를 사용해야합니다.

         Record-Route 프로세스는 모든 SIP
         대화 상자를 시작하는 요청. INVITE만이 그러한
         요청을하지만, 프로토콜 확장
         다른 사람들을 정의 할 수 있습니다.

      5. 추가 헤더 필드 추가

         프록시는 다른 적절한 헤더 필드를
         이 시점에서 복사하십시오.

      6. 포스트 프로세스 라우팅 정보

         프록시는 요청을 요구하는 로컬 정책을 가질 수있다 (MAY)
         특정 프록시 집합을 방문한 후
         목적지. 프락시는 그러한 프락시가 모두
         느슨한 라우터. 일반적으로 이것은
         대리인이 동일한 행정 구역 내에있는 경우 확실성
         도메인. 이 프록시 집합은 일련의 URI로 표현됩니다
         (각각에는 lr 매개 변수가 들어 있습니다). 이 세트는 반드시
         어떤 복사본보다 먼저 복사본의 Route 헤더 필드로 푸시됩니다.
         기존 값 (있는 경우). Route 헤더 필드가
         결석 한 경우 URI의 해당 목록을 포함하는 추가되어야한다.

         프록시에 요청을 요구하는 로컬 정책이있는 경우
         하나의 특정 대리인을 방문하십시오.
         Route 헤더 필드의 값은 전달을 무시하는 것입니다.
         아래 항목 10의 논리를 따르고 대신에 요청을
         특정 프록시에 대한 주소, 포트 및 전송 만약
         요청은 Route 헤더 필드를 가지며,이 대안은
         다음 홉 프록시가 느슨한 것으로 알려진 경우가 아니면 사용하십시오.
         라우터. 그렇지 않으면이 방법을 사용할 수 있지만 Route
         삽입 메커니즘은 견고성 때문에 바람직하지만,
         유연성, 보편성 및 일관성.
         또한 Request-URI에 SIPS URI가 포함되어 있으면 TLS가 필요합니다 (MUST).
         해당 프록시와 통신하는 데 사용됩니다.

         사본에 Route 헤더 필드가 포함되어 있으면 프록시는 반드시
         첫 번째 값에서 URI를 검사하십시오. 해당 URI가
         lr 매개 변수를 포함하면 프록시는 사본을 다음과 같이 수정해야합니다.
         다음과 같습니다 :



Rosenberg, et. al. 표준 트랙 [Page 103]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         - 프락시는 Request-URI를 Route 헤더에 두어야한다
            필드를 마지막 값으로 사용합니다.

         - 그런 다음 프록시는 첫 번째 Route 헤더 필드 값을 배치해야합니다
            Request-URI에 추가하고 그 값을 Route로부터 제거한다.
            헤더 필드.

         Request-URI를 Route 헤더 필드에 추가하는 것은
         해당 Request-URI의 정보를 전달하는 데 사용되는 메커니즘
         엄격한 라우팅 요소를 통해 첫 번째 경로를 '터뜨리기'
         헤더 필드 값을 Request-URI로 변환하면 메시지의 형식이
         엄격한 라우팅 요소가 그것을받을 것으로 기대하는 방식 (
         Request-URI에 자신의 URI와 방문 할 다음 위치
         첫 번째 Route 헤더 필드 값).

      7. 다음 홉 주소, 포트 및 전송 결정

         프록시는 로컬 정책을 사용하여
         특정 IP 주소, 포트 및 전송
         Route 및 Request-URI의 값. 그러한 정책은 절대 안된다.
         프록시가 IP 주소, 포트 및
         전송은 느슨한 라우터 인 서버에 해당합니다.
         그러나이 메커니즘을 통해 요청을 보내는
         특정 다음 홉은 권장되지 않습니다. 대신 Route 헤더
         필드는 위에 설명 된 목적을 위해 사용해야합니다.

         이러한 오버라이드 메커니즘이없는 경우 프록시
         [4]에 열거 된 절차를 다음과 같이 적용하여
         어디로 요청을 보냅니다. 프록시가
         설명 된대로 엄격한 라우팅 요소로 보내도록 요청
         위의 6 단계에서 프록시는 이러한 절차를
         요청 - 요청의 URI입니다. 그렇지 않으면, 프록시는 반드시 적용해야한다.
         Route 헤더 필드의 첫 번째 값에 대한 절차, if
         존재하지 않으면 Request-URI를 반환합니다. 이 절차를 통해
         (주소, 포트, 전송) 튜플의 순서로 된 집합.
         URI에 대한 입력으로 사용되는 URI와는 독립적으로
         Request-URI가 SIPS를 지정하는 경우 [4]의 절차
         자원의 경우, 프록시는 마치 [4]의 절차를 따라야한다.
         입력 URI는 SIPS URI입니다.

         [4]에 설명 된대로 프록시는
         메시지를 해당 집합의 첫 번째 튜플에 추가하고
         전달 시도가 성공할 때까지 순서대로 설정합니다.

         시도 된 각 튜플에 대해 프록시는 다음과 같이 메시지의 형식을 지정해야합니다.
         튜플에 적합하고 새로운 것을 사용하여 요청을 보냅니다.
         8 단계에서 10 단계까지 설명 된대로 클라이언트 트랜잭션.




Rosenberg, et. al. 표준 트랙 [Page 104]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         각각의 시도는 새로운 클라이언트 트랜잭션을 사용하기 때문에,
         새로운 지점. 따라서 Via와 함께 제공되는 분기 매개 변수
         8 단계에서 삽입 된 헤더 필드는 각
         시도.

         클라이언트 트랜잭션이 요청 전송 실패를보고하는 경우
         또는 상태 시스템에서 시간 초과 한 경우 프록시는 계속해서
         해당 주문 세트의 다음 주소. 순서가 설정된 집합이
         요청을이 요소로 전달할 수 없습니다.
         타겟 세트. 프록시는 아무것도 배치 할 필요가 없습니다.
         응답 문맥은 그렇지 않으면 마치이 요소가
         목표 세트는 408 (Request Timeout) 최종 응답을 리턴했습니다.

      8. Via 헤더 필드 값 추가

         프록시는 Via 헤더 필드 값을 사본에 삽입해야합니다 (MUST).
         기존의 Via 헤더 필드 값보다 먼저. 건설
         이 값은 섹션 8.1.1.7과 동일한 지침을 따릅니다.
         이는 프록시가 자체 분기를 계산 함을 의미합니다.
         매개 변수는 해당 분기에 대해 전역으로 고유합니다.
         필수 마법 쿠키가 들어 있습니다. 이 의미는
         분기 매개 변수는 다른 인스턴스에 대해 다를 것입니다.
         나선형 또는 반복 된 요청을 프록시를 통해 전달합니다.

         루프 탐지를 선택하는 프록시에는 추가 제약 조건이 있습니다.
         분기 매개 변수를 구성하는 데 사용하는 값에서.
         루프 탐지를 선택하는 프록시는 분기를 만들어야합니다 (SHOULD).
         매개 변수는 구현에 따라 두 부분으로 분리 가능합니다. 그만큼
         첫 번째 부분은 8.1.1.7 절의 제약 조건을 만족해야한다.
         상기 한 바와 같다. 두 번째는 루프 감지를 수행하는 데 사용됩니다.
         루프를 나선과 구별 할 수 있습니다.

         루프 탐지는 요청이
         프록시로 돌아 가면 해당 필드가
         요청의 처리가 변경되지 않았습니다. 배치 된 값
         가지 매개 변수의이 부분에서
         해당 필드 (Route, Proxy-Require 및 Proxy-
         권한 부여 헤더 필드). 이는 다음과 같은 경우
         요청은 프록시와 해당 필드 중 하나에 다시 라우팅됩니다.
         변경 사항은 루프가 아닌 나선형으로 처리됩니다 (섹션
         16.3). 이 값을 만드는 일반적인 방법은
         To 태그의 암호화 해시, From 태그, Call-ID 헤더
         필드, 수신 된 요청의 Request-URI (이전
         번역), 최상위 비아 헤더 및 시퀀스 번호
         CSeq 헤더 필드로부터, 임의의 Proxy-Require
         및 Proxy-Authorization 헤더 필드가있을 수 있습니다. 그만큼





Rosenberg, et. al. 표준 트랙 [Page 105]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         해시를 계산하기 위해서 사용 된 알고리즘은 구현에 의존 합니다만,
         그러나 MD5 (RFC 1321 [35])는 16 진수로 표현하면 다음과 같습니다.
         합리적인 선택. 토큰에는 Base64가 허용되지 않습니다.

         프록시가 루프를 탐지하고자하면 "branch"매개 변수 it
         소모품은 다음의 가공에 영향을 미치는 모든 정보에 의존해야한다.
         수신 Request-URI 및 임의의 헤더를 포함하는 요청
         요청의 승인 또는 라우팅에 영향을주는 필드 이것은
         요청에서 루프 된 요청을 구별하는 데 필요한
         라우팅 매개 변수가이 값으로 돌아 가기 전에 변경되었습니다.
         섬기는 사람.

         요청 메소드는 다음의 계산에 포함되어서는 안됩니다 (MUST NOT).
         분기 매개 변수 특히 CANCEL 및 ACK 요청
         (2xx가 아닌 응답의 경우)와 동일한 분기 값을 가져야합니다.
         요청을 취소하거나 확인합니다. 지회
         매개 변수는 서버에서 이러한 요청을 상관시키는 데 사용됩니다.
         그것들을 다루어야한다 (17.2.3 절과 9.2 절 참조).

      9. 필요한 경우 Content-Length 헤더 필드 추가

         요청이 스트림 홉을 사용하여 다음 홉으로 보내지면,
         기반 전송 및 사본에 Content-Length 헤더가 없음
         필드에서, 프록시는 반드시 correc와 함께 하나를 삽입해야한다.
t 값
         요청 본문 (20.14 절 참조).

      10. 전달 요청

         상태 저장 프록시는이를 위해 새로운 클라이언트 트랜잭션을 생성해야합니다 (MUST).
         섹션 17.1에 설명 된대로 요청하고
         트랜잭션을 사용하여 주소, 포트 및
         전송은 7 단계에서 결정됩니다.

      타이머 C 설정

         INVITE 요청이 절대로 발생하지 않는 경우를 처리하기 위해
         최종 응답을 생성하면 TU는 호출되는 타이머를 사용합니다.
         타이머 C. 타이머 C는 각 클라이언트 트랜잭션마다 설정되어야합니다.
         INVITE 요청이 프록시됩니다. 타이머는 3보다 커야합니다 (MUST).
         의사록. 16.7 절의 총알 2는이 타이머가 어떻게
         임시 응답으로 업데이트되고, 16.8 절
         발생시 처리합니다.









Rosenberg, et. al. 표준 트랙 [Page 106]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


16.7 응답 처리

   요소가 응답을 수신하면 먼저 요소를 찾습니다.
   클라이언트 트랜잭션 (17.1.3 절)을 참조하십시오. 없는 경우
   요소가 발견되면, 요소는 응답을 처리해야한다 (비록 그것이
   정보 응답)을 무국적 프록시 (아래에 설명 됨)로 제공합니다. 만약
   일치가 있으면 클라이언트 트랜잭션에 응답이 전달됩니다.

      클라이언트 트랜잭션 (또는 그 이상)에 대한 응답 전달
      일반적으로 관련 요청을 보낸 모든 지식)은 다음과 같습니다.
      발견되지 않으면 견고성이 향상됩니다. 특히,
      INVITE 요청에 대한 "늦은"2xx 응답은 제대로 전달됩니다.

   클라이언트 트랜잭션이 프록시 계층에 응답을 전달하면
   다음 처리가 수행되어야합니다.

      1. 적절한 응답 컨텍스트 찾기

      2. 임시 응답을 위해 타이머 C를 업데이트하십시오.

      3. 맨 위의 Via를 제거하십시오.

      4. 응답 컨텍스트에 응답을 추가합니다.

      5.이 응답을 즉시 전달해야하는지 확인하십시오

      6. 필요시, 가장 좋은 최종 답변을 선택하십시오.
          응답 문맥

   모든 클라이언트 이후 최종 응답이 전달되지 않은 경우
   응답 컨텍스트와 연관된 트랜잭션이 종료되었지만,
   프록시는 그것을 선택하여 전달해야합니다.
   지금까지 보았다.

   다음 처리는 각 응답에 대해 수행되어야합니다.
   전달. 각 요청에 대한 둘 이상의 응답
   최소한 잠정적 인 응답과 최종적인 응답이 각각 전달됩니다.

      7. 필요한 경우 권한 부여 헤더 필드 값 집계

      8. 선택적으로 Record-Route 헤더 필드 값 다시 쓰기

      9. 응답 전달

      10. 필요한 CANCEL 요청 생성






Rosenberg, et. al. 표준 트랙 [Page 107]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   위의 각 단계는 다음과 같습니다.

      1. 컨텍스트 찾기

         프록시는 전에 생성 한 "응답 컨텍스트"를 찾습니다.
         설명 된 키를 사용하여 원래 요청을 전달합니다.
         16.6 절. 나머지 처리 단계는
         이 문맥.

      2. 임시 응답을 위해 타이머 C를 업데이트하십시오.

         INVITE 트랜잭션의 경우 응답이 잠정적 인 경우
         상태 코드가 101 ~ 199 인 응답 (즉, 무엇이든
         그러나 100), 프록시는 그 클라이언트에 대해 타이머 C를 리셋해야한다
         트랜잭션. 타이머는 다른 값으로 재설정 될 수 있지만
         이 값은 반드시 3 분보다 커야한다.

      3. 비아

         프록시는 최상위 Via 헤더 필드 값을
         응답.

         Via 헤더 필드 값이 응답에 남아 있지 않으면
         응답은이 요소에 대한 것이므로 전달해서는 안됩니다.
         이 섹션에서 설명하는 나머지 처리 과정은 다음과 같습니다.
         이 메시지에서 수행되지 않은 UAC 처리 규칙
         대신 8.1.3 절에 설명 된대로 (transport
         레이어 처리가 이미 발생했습니다).

         이것은 예를 들어, 요소가 생성 될 때 발생합니다.
         CANCEL 요청은 섹션 10에 설명 된 것과 같습니다.

      4. 문맥에 대한 응답 추가

         최종 응답은 응답 컨텍스트에 저장됩니다.
         서버 트랜잭션에서 최종 응답이 생성 될 때까지
         이 문맥과 관련있다. 응답은 후보가 될 수 있습니다.
         해당 서버에서 반환되는 최상의 최종 응답
         트랜잭션. 이 응답의 정보는에서 필요할 수 있습니다.
         이 응답을 선택하지 않아도 최상의 응답을 형성합니다.

         프록시가 3xx의 모든 연락처에서 재귀를 선택하면
         응답을 대상 세트에 추가하여 응답해야합니다.
         응답에 응답을 추가하기 전에 응답에서
         문맥. 그러나, 프록시는 비 SIPS URI로 재발생해서는 안된다 (SHOULD NOT).
         원래 요청의 Request-URI가 SIPS URI 인 경우 만약





Rosenberg, et. al. 표준 트랙 [Page 108]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         프록시는 3xx 응답의 모든 컨택을 재귀합니다.
         프록시는 결과 비접촉 응답을 다음에 추가해서는 안됩니다 (SHOULD NOT).
         응답 문맥.

         응답에 응답을 추가하기 전에 연락처 제거
         컨텍스트는 다음 요소가 업스트림에서 재 시도하지 못하도록합니다.
         이 프록시가 이미 시도한 위치.

         3xx 응답에는 SIP, SIPS 및 비 -SIP이 혼합되어있을 수 있습니다.
         URI. 프록시는 SIP 및 SIPS URI에서 재귀하도록 선택할 수 있습니다.
         나머지를 응답 컨텍스트에 배치하여
         잠재적으로 최종 응답으로 반환되었습니다.

         프록시가 416 (Unsupported URI Scheme) 응답을 받으면
         Request-URI 스킴이 SIP가 아니지만 스킴
         원래 수신 한 요청에서 SIP 또는 SIPS (즉,
         프록시가 SIP 또는 SIPS에서 다른 방식으로 구성표를 변경했습니다.
         프록시가 요청을 프록시 할 때), 프록시는 새로운 URI를 다음에 추가해야한다 (SHOULD).
         타겟 세트. 이 URI는 SIP URI 버전이어야합니다.
         방금 시도한 비 SIP URI tel URL의 경우,
         이것은 전화 - 가입자 부분
         SIP URL의 사용자 부분에 tel URL을 설정하고,
         이전 요청이 전송 된 도메인의 hostpart.
         tel에서 SIP URI를 형성하는 방법에 대한 자세한 내용은 19.1.6 절을 참조하십시오.
         URL

         3xx 응답과 마찬가지로, 프록시가 416에서 "재귀"하면
         SIP 또는 SIPS URI 대신 416 응답을 시도해야합니다 (SHOULD NOT).
         응답 컨텍스트에 추가됩니다.

      5. 전달 응답 확인

         최종 응답이 서버 트랜잭션에서 전송 될 때까지,
         다음 응답은 즉시 전달되어야합니다.

         - 100 (Trying) 이외의 임시 응답

         - 모든 2xx 응답

         6xx 응답이 수신되면 즉시 응답되지 않고,
         그러나 상태 유지 프록시는 모든 클라이언트 보류중인 것을 취소해야한다.
         섹션 10에 설명 된대로 트랜잭션을 생성하고 생성해서는 안됩니다
         이 컨텍스트에서 새 분기.

         이것은 RFC 2543의 변경 사항입니다.이 RFC 2543은 프록시
         6xx 응답을 즉시 전달하는 것이 었습니다. 초대의 경우
         트랜잭션에서이 접근법은 2xx 응답
         다른 지점에 도착할 수 있습니다.이 경우 프록시는



Rosenberg, et. al. 표준 트랙 [Page 109]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         2xx를 전달해야합니다. 그 결과 UAC는
         6xx 응답과 2xx 응답을 받아야합니다.
         일어날 수 없다. 새로운 규칙에 따라,
         6xx를 수신하면 프록시는 CANCEL 요청을 발행합니다.
         일반적으로 모든 미결제로부터 487 건의 응답을 얻습니다.
         클라이언트 트랜잭션, 그리고 그 시점에서 6xx는
         업스트림으로 전달됩니다.

         서버 트랜잭션에서 최종 응답이 전송 된 후,
         다음 응답은 즉시 전달되어야합니다.

         - INVITE 요청에 대한 2xx 응답

         상태 저장 프록시는 즉시 다른
         응답. 특히 상태 저장 프록시는 전달하지 않아야합니다
         모든 100 (Trying) 응답. 후보자 인 응답
         "최고의"응답이 수집되면 나중에 전달할 수 있습니다.
         "컨텍스트에 응답 추가"단계에서 설명한대로

         즉각적인 전달을 위해 선택된 응답은 반드시 처리되어야합니다
         "권한 부여 헤더 필드 집계
         값 "을 통해"기록 - 경로 ".

         이 단계는 다음 단계와 결합되어 상태 저장
         프록시는 정확히 하나의 최종 응답을 비 -INITE에 전달합니다
         요청 및 정확하게 하나의 2xx가 아닌 응답 또는 하나 이상의
         2xx는 INVITE 요청에 응답합니다.

      6. 최상의 응답 선택

         상태 저장 프록시는 응답에 최종 응답을 보내야합니다 (MUST).
         최종 응답이없는 경우 컨텍스트의 서버 트랜잭션
         위의 규칙과 모든 클라이언트가 즉시 전달
         이 응답 컨텍스트의 트랜잭션이 종료되었습니다.

         상태 보존 형 프록시는 반드시 "최상의"최종 응답을 선택해야합니다.
         응답 컨텍스트에 수신되어 저장됩니다.

         문맥에 최종 응답이 없으면 프록시는 반드시
         서버에 408 (Request Timeout) 응답을 보냅니다.
         트랜잭션.

         그렇지 않으면, 프록시는 반드시 응답으로부터 응답을 전달해야한다.
         응답 컨텍스트에 저장됩니다. 반드시 6xx에서 선택해야합니다.
         클래스 응답이 컨텍스트에 존재하는 경우. 6xx 클래스가없는 경우
         응답은 존재하며, 프록시는 가장 낮은 것에서 선택해야한다.
         응답 클래스는 응답 컨텍스트에 저장됩니다. 대리인 MAY
         선택한 클래스 내에서 응답을 선택하십시오. 프록시는 SHOULD



Rosenberg, et. al. 표준 트랙 [Page 110]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         영향을 미치는 정보를 제공하는 응답을 선호하십시오.
         401, 407, 415, 420 및이 요청의 재전송
         4xx 클래스가 선택되면 484.

         503 (서비스 사용 불가) 응답을받는 프록시
         그것이 업스트림을 결정할 수없는 한 업스트림으로 전달해서는 안된다.
         후속 요청은 프록시가 503을 생성합니다.
         즉, 503을 전달하면 프록시가이를 알고 있음을 의미합니다.
         요청에 대한 서비스뿐만 아니라 모든 요청을 서비스 할 수 없습니다.
         503을 생성 한 요청의 URI.
         수신 된 응답은 503이며, 프록시는 생성해야한다 (SHOULD).
         500 응답 및 앞으로 그 업스트림.

         전달 된 응답은 단계
         "총 권한 부여 헤더 필드 값"부터 "레코드 -
         노선".

         예를 들어 프록시가 4 개 위치로 요청을 전달한 경우
         503, 407, 501 및 404 응답을 수신 한 경우
         407 (프록시 인증 필요) 응답을 전달하십시오.

         1xx 및 2xx 응답은
         대화 상자. 요청에 To 태그가 없으면 To 태그
         응답에서 UAC는 다중을 구별하기 위해
         요청을 생성하는 대화 상자에 응답합니다. 프록시는 안된다.
         1xx 또는 2xx 응답의 To 헤더 필드에 태그 삽입
         요청에 포함되지 않은 경우 프록시는 수정해서는 안됩니다
         1xx 또는 2xx 응답의 To 헤더 필드에있는 태그.

         프록시는 To 헤더 필드에 태그를 삽입 할 수 없기 때문에
         하나가 포함되지 않은 요청에 대한 1xx 응답.
         100 개가 아닌 임시 응답을 자체적으로 발행합니다. 그러나 그것
         동일한 요소를 공유하는 UAS로 요청을 분기 할 수 있습니다.
         프록시. 이 UAS는 자체 임시 응답을 반환 할 수 있지만,
         창안자와 초기 대화를 시작한다.
         의뢰. UAS는 다음과 같은 신중한 프로세스가 될 필요는 없습니다.
         프록시. 같은 UAS에서 구현 된 가상 UAS 일 수 있습니다.
         코드 공간을 프록시로 사용합니다.

         3-6xx 응답은 hop-by-hop으로 전달됩니다. 3-6xx를 발행 할 때
         응답에서 요소는 효과적으로 UAS로 작동하며
         일반적으로받은 응답을 기반으로하는 자체 응답
         다운 스트림 요소. 요소는 To 태그를 보존해야합니다 (SHOULD).
         단순히 요청에 3-6xx 응답을 전달할 때
         To 태그를 포함하지 않습니다.

         프록시는 전달 된 응답에서 To 태그를 수정해서는 안됩니다
         To 태그가 포함 된 요청



Rosenberg, et. al. 표준 트랙 [쪽 111]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         업스트림 요소에는 차이가 없지만
         프록시는 전달 된 3-6xx 응답으로 To 태그를 대체했으며,
         원래의 태그를 유지하면 디버깅을 도울 수 있습니다.

         프록시가 여러 개의 정보를 집계 할 때
         응답 중에서 To 태그를 선택하는 것은 임의적입니다.
         새로운 To 태그를 생성하면 디버깅이 쉬워 질 수 있습니다. 이
         예를 들어, 401 (Unauthorized) 및
         407 (프록시 인증 필요) 챌린지 또는 결합
         암호화되지 않은 3xx의 인증 된 값
         응답.

      7. 총 인증 헤더 필드 값

         선택된 응답이 401 (Unauthorized) 또는 407 (Proxy
         인증 필요) 프록시는 모든 WWW-
         인증 및 프록시 -에서 헤더 필드 값 인증
         기타 모든 401 (인증되지 않음) 및 407 (프록시 인증
         이 응답 컨텍스트에서 지금까지 수신 된 응답
         전에 수정없이이 응답에 추가하십시오.
         전송. 그 결과로 401 (Unauthorized) 또는 407 (Proxy
         Authentication Required) 응답은 여러 개의 WWW-
         Authenticate AND Proxy-Authenticate 헤더 필드 값.

         이는 목적지 중 일부 또는 전부가
         에 전달 된 요청은 자격 증명을 요청했을 수 있습니다. 그만큼
         고객은 이러한 모든 도전 과제를 받아야합니다.
         요청을 다시 시도 할 때 각각에 대한 자격 증명.
         이 행동에 대한 동기 부여는 26 절에서 제공됩니다.

      8. 기록 - 길

         선택된 응답에 Record-Route 헤더 필드가 포함 된 경우
         원래이 프록시가 제공 한 값, 프록시는
         응답을 전달하기 전에 값을 다시 쓰십시오. 이
         프록시는 다른 URI를 자신에게 제공 할 수 있습니다.
         다음 상류 및 하류 요소. 프록시가
         어떤 이유로 든이 메커니즘을 사용하십시오. 예를 들어, 유용하다.
         멀티 홈 호스트의 경우

         프록시가 TLS를 통해 요청을 수신하여 보낸 경우
         TLS가 아닌 연결을 통해, 프록시는 다음을 사용하여 URI를 다시 작성해야합니다.
         Record-Route 헤더 필드는 SIPS URI가됩니다. 프록시
         비 TLS 연결을 통해 요청을 수신하여 보냈습니다.
         TLS에서, 프락시는 반드시 Record-Route의 URI를 다시 써야한다.
         헤더 필드는 SIP URI가된다.





Rosenberg, et. al. 표준 트랙 [112 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         프록시에 의해 제공되는 새로운 URI는 반드시 동일해야한다.
         에서 Record-Route 헤더 필드에 배치 된 URI에 대한 제약
         요청 (16.6 절의 단계 4 참조)과 다음 내용
         수정 :

         URI는 전송 매개 변수를 포함하지 않아야한다 (SHOULD NOT).
         프록시는 다음 업스트림 (
         하류) 요소를 포함 할 수있다.
         요청은 해당 전송을 지원합니다.

         프록시가 Record-Route 헤더를 수정하기로 결정할 때
         필드에서 응답에서 수행하는 작업 중 하나가
         삽입 한 Record-Route 값을 찾습니다. 만약
         요청이 나선형으로 처리되고 프록시가 Record-Route 값을 삽입했습니다.
         나선의 각 반복에서 올바른 값을 찾습니다.
         응답 (역순으로 적절한 반복이어야 함)
         방향) 까다 롭습니다. 위의 규칙은 프록시
         Record-Route 헤더 필드 값을 다시 쓰고 싶습니다. insert
         Record-Route 헤더 필드에 충분히 구별되는 URI
         올바른 것을 재기록하도록 선택할 수있다. 에이
         이를 달성하기위한 권장 메커니즘은 다음과 같은 프록시에 대한 것입니다.
         프록시 인스턴스에 대한 고유 식별자를 사용자에게 추가합니다.
         URI 부분.

         응답이 도착하면 프록시는 첫 번째
         Record - 식별자가 프록시 인스턴스와 일치하는 경로. 그만큼
         이 데이터가없는 URI의 수정 결과
         URI의 사용자 부분에 추가됩니다. 다음에
         반복, 동일한 알고리즘 (최상위 Record-Route 찾기
         매개 변수와 함께 헤더 필드 값) 올바르게 추출합니다
         그 다음에 삽입 된 Record-Route 헤더 필드 값
         프록시.

         프록시 요청에 대한 모든 응답이
         Record-Route 헤더 필드 값에 Record-Route가 포함됩니다.
         헤더 필드. 응답에 Record-Route가 포함 된 경우
         헤더 필드에는 프록시가 추가 한 값이 포함됩니다.

      9. 전달 응답

         "집계"단계에 설명 된 처리를 수행 한 후
         Authorization Header Field Values ​​"를 통해"Record-Route ",
         프록시는 특정 기능 조작을
         선택된 응답. 프록시는 서버에 추가, 수정 또는
         메시지 본문을 제거하십시오. 달리 지정하지 않는 한 프록시
         Via가 아닌 다른 헤더 필드 값을 제거해서는 안됨
         헤더 필드 값은 Section 16.7 Item 3.에서 논의된다.
         특히, 프록시는 "수신 된"매개 변수를 제거해서는 안된다



Rosenberg, et. al. 표준 트랙 [쪽 113]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         다음 Via 헤더 필드 값에 추가되었을 수 있습니다.
         이 응답과 관련된 요청을 처리합니다. 그만큼
         프록시는 반드시 서버 트랜잭션에 응답을 전달해야한다.
         응답 문맥과 관련된다. 이렇게하면
         응답은 현재에 표시된 위치로 전송됩니다.
         맨 위 Via 헤더 필드 값. 서버 트랜잭션이
         더 이상 전송을 처리하기 위해 사용할 수없는 요소
         응답을 무조건적으로 전달해야합니다.
         서버 전송. 서버 트랜잭션은
         응답을 보내지 못하거나 그 상태에서 타임 아웃 신호를 보낸다.
         기계. 이러한 오류는 진단 목적으로 기록됩니다.
         적절하지만 프로토콜에는 교정 조치가 필요하지 않습니다.
         프록시에서.

         프록시는 응답 컨텍스트를 모두 유지할 때까지 응답 컨텍스트를 유지해야합니다 (MUST).
         관련 거래가 종료 된 후에도
         최종 응답 전달.

      10. CANCEL 생성

         전달 된 응답이 최종 응답 인 경우, 프록시는 반드시
         모든 보류중인 클라이언트 트랜잭션에 대한 CANCEL 요청 생성
         이 응답 문맥과 관련있다. 프록시는 또한 SHOULD해야한다.
         모든 보류중인 클라이언트 트랜잭션에 대한 CANCEL 요청 생성
         6xx를 수신하면이 응답 컨텍스트와 연결됩니다.
         응답. 보류중인 고객 트랜잭션은
         잠정적 응답을 받았지만 최종 응답이 없었다.
         진행 상태에 있음), 관련 CANCEL이 없었습니다
         그것을 위해 생성됩니다. CANCEL 요청 생성은
         9.1 절.

         대기중인 고객 거래를 취소해야하는 요건
         최종 응답 전달은 엔드 포인트를 보장하지 않습니다.
         INVITE에 대해 여러 번의 200 (OK) 응답을받지 못합니다. 200
         하나 이상의 브랜치에서 (OK) 응답이 생성 될 수 있습니다.
         CANCEL 요청을 보내고 처리 할 수 ​​있습니다. 또한,
         미래의 확장이 이것을 무시할 것으로 기대하는 것이 합리적이다.
         CANCEL 요청을 발행해야합니다.

16.8 처리 타이머 C

   타이머 C가 작동해야한다면, 프록시는 타이머를
   클라이언트 트랜잭션을 선택하거나 종료합니다. 만약
   클라이언트 트랜잭션이 임시 응답을 수신 한 경우, 프록시
   해당 트랜잭션과 일치하는 CANCEL 요청을 생성해야합니다 (MUST). 만약
   클라이언트 트랜잭션이 잠정적 인 응답을받지 못하면 프록시
   트랜잭션이 408 (Request Timeout)을 수신 한 것처럼 행동해야합니다 (MUST)
   응답.



Rosenberg, et. al. 표준 트랙 [Page 114]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   프록시가 타이머를 재설정하도록 허용하면 프록시가 동적으로 허용됩니다.
   현재 조건에 따라 트랜잭션의 수명을 연장합니다 (예 :
   활용도) 타이머가 작동하면.

16.9 전송 오류 처리

   전송 계층이 시도 할 때 프록시 계층에 오류를 알리는 경우
   요청을 전달 (18.4 절 참조)하면 프록시는 마치 마치
   전달 된 요청이 503 (서비스 사용 불가능) 응답을 받았습니다.

   응답을 전달할 때 프록시에 오류가 통보되면
   응답을 삭제합니다. 프록시는 어떤 미해결 된 것을 취소해서는 안된다.
   이 때문에이 응답 컨텍스트와 연관된 클라이언트 트랜잭션
   공고.

      프록시가 미해결 클라이언트 트랜잭션을 취소하면 단일
      악의적이거나 오작동하는 클라이언트로 인해 모든 트랜잭션이 실패 할 수 있습니다.
      Via 헤더 필드를 통해

16.10 취소 처리

   상태 유지 프록시는 다른 요청에 대해 취소를 생성 할 수 있습니다 (MAY)
   언제든지 생성됩니다. (
   그 요청은 9.1 절에 설명 된대로). 프락시는 어떤 것도 취소해야합니다
   응답 컨텍스트와 연관된 보류중인 클라이언트 트랜잭션
   일치하는 CANCEL 요청을 수신합니다.

   상태있는 프록시가 보류중인 INVITE에 대한 CANCEL 요청을 생성 할 수 있습니다
   INVITE에 지정된 기간을 기준으로 한 고객 거래
   Expires 헤더 필드 경과. 그러나 이것은 일반적으로
   관련 엔드 포인트가 신호 처리를 담당하므로 불필요합니다.
   트랜잭션의 끝.

   CANCEL 요청은 자체적으로 상태 저장 프록시에서 처리되지만
   서버 트랜잭션에서 새 응답 컨텍스트가 만들어지지 않습니다.
   대신 프록시 계층은 다음에 대한 기존 응답 컨텍스트를 검색합니다.
   이것과 관련된 요청을 처리하는 서버 트랜잭션
   취소하다. 일치하는 응답 문맥이 발견되면, 요소는 반드시
   CANCEL 요청에 대해 200 (OK) 응답을 즉시 반환합니다. 에서
   이 경우 요소는 다음에서 정의 된대로 사용자 에이전트 서버로 작동합니다.
   섹션 8.2. 또한 요소는 CANCEL 요청을 생성해야합니다 (MUST).
   컨텍스트에서 보류중인 모든 클라이언트 트랜잭션에 대해
   섹션 16.7 10 단계.

   응답 컨텍스트가 없으면 요소에 아무런 응답이 없습니다.
   CANCEL을 적용하라는 요청에 대한 지식. 상태 비 저장해야한다.
   CANCEL 요청을 전달하십시오 (상태 비 저장 방식으로
   이전에 연관된 요청).



Rosenberg, et. al. 표준 트랙 [쪽 115]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


16.11 Stateless Proxy

   상태없는 행동을 할 때 프록시는 단순한 메시지 전달자입니다. 많은
   상태없이 행동 할 때 수행되는 처리의
   상태에 따라 행동 할 때. 차이점은 여기에 자세히 설명되어 있습니다.

   상태 비 저장 프록시는 트랜잭션의 개념이나
   상태 저장 프록시 동작을 설명하는 데 사용되는 응답 컨텍스트
   대신, 상태 비 저장 프록시는 메시지, 요청 및
   응답을 전송 계층에서 직접 가져옵니다 (18 절 참조). 마찬가지로
   그 결과 무국적 프록시는 자체적으로 메시지를 재전송하지 않습니다.
   그러나 그들은 그들이받는 모든 재전송을 전달합니다 (그들은
   재전송을 구별 할 수있는 능력이 없다.
   원본 메시지). 또한, 요청을 무조건 처리 할 때,
   요소는 자신의 100 (시도 중) 또는 다른 요소를 생성해서는 안된다
   임시 응답.

   상태 비 저장 프락시는 섹션에 설명 된대로 요청을 검증해야합니다 (MUST).
   16.3

   상태 비 저장 프록시는 설명 된 요청 처리 단계를 따라야합니다
   섹션 16.4 ~ 16.5에서 다음 예외가 있습니다.

      o 상태 비 저장 프록시는 하나의 타겟만을 선택해야한다.
         대상 집합입니다. 이 선택 사항은
         메시지 및 시간 불변 속성을 포함합니다. 에서
         특히, 재전송 된 요청은 반드시
         처리 될 때마다 동일한 목적지. 더욱이,
         CANCEL과 non-Routed ACK 요청은 같은 것을 생성해야한다
         선택 사항은 관련 INVITE입니다.

   상태 비 저장 프록시는 설명 된 요청 처리 단계를 따라야합니다
   다음 예외 사항을 제외하고는 16.6 절을 참조하십시오.

      o 공간 및 시간에 따른 고유 한 분기 ID 요구 사항
         무국적 프록시에도 적용됩니다. 그러나 무국적자
         프록시는 단순히 난수 생성기를 사용하여 계산할 수 없습니다.
         섹션 ID에서 설명한대로 분기 ID의 첫 번째 구성 요소
         16.6 글 머리 기호 8. 이것은 요청의 재전송
         같은 가치를 가져야하고, 상태없는 프록시는 말할 수 없다.
         원래 요청으로부터의 재전송. 따라서
         유일하게 만드는 가지 매개 변수의 구성 요소는 반드시
         재전송 된 요청이 전달 될 때마다 동일합니다. 그러므로
         상태없는 프록시의 경우, 분기 매개 변수는 다음과 같이 계산되어야합니다 (MUST).
         메시지 매개 변수들의 결합 기능
         재전송시 불변.





Rosenberg, et. al. 표준 트랙 [쪽 116]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         무국적 프록시는 보증하기를 원하는 어떤 기법을 사용해도된다
         트랜잭션 전반에서 지점 ID의 고유성 그러나
         다음 절차가 권장됩니다. 프록시는
         수신 된 최상위 비아 헤더 필드의 브랜치 ID
         의뢰. 그것이 마술 과자로 시작하면, 첫번째
         발신 요청의 분기 ID의 구성 요소가 계산됩니다.
         수신 된 브랜치 ID의 해시로서. 그렇지 않으면 첫 번째
         분기 ID의 구성 요소는 최상위의 해시로 계산됩니다.
         To 헤더 필드의 태그, From 헤더의 태그
         필드, Call-ID 헤더 필드, CSeq 번호 (그러나
         메소드) 및 수신 된 요청으로부터의 Request-URI를 포함한다. 하나의
         이 입력란은 항상 두 가지 다른
         업무.

      o 16.6 절에 명시된 다른 모든 메시지 변환
         반드시 재전송 된 것과 동일한 변환을 가져야한다.
         의뢰. 특히, 프록시가 Record-Route를 삽입하면
         값을 전달하거나 라우트 헤더 필드에 URI를 푸시해야한다.
         요청의 재전송에서 같은 값. 마찬가지로
         분기 매개 변수를 통해 이것은 변환이
         시간 불변 구성에 기반해야합니다.
         요청의 재전송 불변 속성.

      o 상태 비 저장 프록시는 요청을 전달할 위치를 결정합니다.
         16.6 절 항목 10의 상태 기반 프록시에 대해 설명합니다.
         요청은 대신에 전송 계층으로 직접 전송됩니다.
         클라이언트 트랜잭션을 통해

         Stateless 프록시는 재전송 된 요청을
         동일한 대상을 선택하고 동일한 분기 매개 변수를
         각각은 메시지의 정보 만 사용할 수 있습니다.
         그 자체에 대한 시간 - 불변의 구성 데이터
         계산. 구성 상태가 시간에 영향을주지 않는 경우
         (예 : 라우팅 테이블이 업데이트 된 경우)
         변경으로 인해 영향을받을 수 있음
         트랜잭션 타임 아웃과 같은 간격 동안 비 상태 유지
         변경 전후의 윈도우. 처리 방법
         해당 간격에서 영향을받는 요청은 구현입니다.
         결정. 일반적인 해결책은 트랜잭션을 전달하는 것입니다.
         statefully.

   무국적 프록시는 CANCEL을 위해 특별한 처리를해서는 안된다
   요청. 위의 규칙에 따라 다른 규칙으로 처리됩니다.
   요청. 특히, 상태 비 저장 프록시는 동일한 Route를 적용합니다
   헤더 필드 처리가 CANCEL 요청에 적용됩니다.
   다른 요청.





Rosenberg, et. al. 표준 트랙 [쪽 117]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   16.7 절에 설명 된 응답 처리는
   무의식적으로 행동하는 프록시. 응답이 무국적자에게 도착하면
   프록시는 프록시가 처음에 보낸 사람 값을 검사해야합니다
   (맨 위) 헤더 필드 값을 통해. 해당 주소가 프록시와 일치하는 경우,
   (이 프록시가 이전 요청에 삽입 한 값과 같습니다)
   프록시는 응답에서 해당 헤더 필드 값을 제거해야하며
   결과를 다음 Via 헤더에 표시된 위치로 전달합니다.
   필드 값. 프록시는 서버에 추가, 수정 또는 제거해서는 안됩니다.
   메시지 본문. 별도로 명시되지 않는 한, 프록시는 제거해서는 안된다.
   다른 헤더 필드 값. 주소가
   프록시에서 메시지는 조용히 버려야합니다 (MUST).

16.12 프록시 경로 처리 요약

   반대로 현지 정책이없는 경우,
   프록시는 Route 헤더 필드가 포함 된 요청에 대해 수행 할 수 있습니다.
   다음 단계에 요약되어 있습니다.

      1. 프록시가 Request-URI를 검사합니다. 그것이
          이 프록시가 소유 한 리소스는 프록시가
          위치 실행 결과 se

rvice. 그렇지 않으면,
          프록시는 Request-URI를 변경하지 않습니다.

      2. 프록시는 최상위 Route 헤더의 URI를 검사합니다
          필드 값. 이 프록시가이 프록시를 나타내면 프록시가이를 제거합니다.
          경로 헤더 필드 (이 경로 노드는
          도달).

      3. 프록시는 요청 된 리소스로 요청을 전달합니다.
          최상위 Route 헤더 필드 값의 URI 또는
          Route 헤더 필드가없는 경우 Request-URI. 프록시
          주소, 포트 및 전송을 사용할 때 결정합니다.
          [4]의 절차를 적용하여 요청을 전달
          그 URI.

   엄격한 라우팅 요소가 경로의 경로에서 발견되지 않으면
   요청의 경우 Request-URI는 항상
   의뢰.

16.12.1 예제

16.12.1.1 기본 SIP 사다리꼴

   이 시나리오는 기본 SIP 사다리꼴 인 U1 -> P1 -> P2 -> U2이며
   두 프록시 모두 레코드 라우팅. 여기에 흐름이 있습니다.






Rosenberg, et. al. 표준 트랙 [Page 118]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   U1은 다음을 전송합니다.

      INVITE SIP : callee@domain.com SIP / 2.0
      연락처 : sip : caller@u1.example.com

   P1에. P1은 아웃 바운드 프록시입니다. P1은
   domain.com, 그래서 DNS에서 그것을보고 그것을 보냅니다. 또한
   Record-Route 헤더 필드 값을 추가합니다.

      INVITE SIP : callee@domain.com SIP / 2.0
      연락처 : sip : caller@u1.example.com
      Record-Route : <sip : p1.example.com; lr>

   P2가 이것을 얻습니다. domain.com을 담당하므로 위치를 실행합니다.
   서비스를 만들고 Request-URI를 다시 씁니다. 또한 Record-Route를 추가합니다.
   헤더 필드 값. Route 헤더 필드가 없으므로 해결됩니다.
   새로운 Request-URI는 요청을 보낼 곳을 결정합니다.

      INVITE sip : callee@u2.domain.com SIP / 2.0
      연락 처 : sip : caller@u1.example.com
      Record-Route : <sip : p2.domain.com; lr>
      Record-Route : <sip : p1.example.com; lr>

   u2.domain.com의 수신자가이 메시지를 받고 200 OK를 사용하여 응답합니다.

      SIP / 2.0 200 OK
      연락처 : sip : callee@u2.domain.com
      Record-Route : <sip : p2.domain.com; lr>
      Record-Route : <sip : p1.example.com; lr>

   또한 u2의 호출 수신자는 대화 상태의 원격 대상 URI를로 설정합니다.
   한 모금 : caller@u1.example.com 및 그 경로를 설정 :

      (<sip : p2.domain.com; lr>, <sip : p1.example.com, lr>)

   이것은 P2에 의해 P1에서 U1로 정상적으로 전달됩니다. 이제 U1은
   대화 상태의 원격 대상 URI를 sip : callee@u2.domain.com으로
   경로 설정 :

      (<sip : p1.example.com; lr>, <sip : p2.domain.com, lr>)

   모든 라우트 집합 요소에는 lr 매개 변수가 포함되어 있으므로 U1
   다음 BYE 요청을 구성합니다.

      BYE sip : callee@u2.domain.com SIP / 2.0
      경로 : <sip : p1.example.com; lr>, <sip : p2.domain.com, lr>





Rosenberg, et. al. 표준 트랙 [Page 119]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   다른 모든 요소 (프록시 포함)가 수행 하듯이,
   DNS를 사용하여 최상위 Route 헤더 필드 값의 URI를 결정합니다.
   어디로 요청을 보냅니다. 이것은 P1로 간다. P1은 그것이
   Request-URI에 표시된 자원에 대한 책임이 없으므로
   그것을 바꾸지 않습니다. 그것은 그것의 첫 번째 값인 것을 볼 수 있습니다.
   Route 헤더 필드를 사용하여 해당 값을 제거하고
   P2에 요청 :

      BYE sip : callee@u2.domain.com SIP / 2.0
      경로 : <sip : p2.domain.com; lr>

   P2는 또한에 의해 표시되는 자원에 대해 책임을지지 않습니다.
   요청 URI (domain.com에 대한 책임은 요청 URI가 아닙니다.
   u2.domain.com), 변경하지 않습니다. 그것은 스스로를
   첫 번째 Route 헤더 필드 값이므로 제거하고 전달합니다.
   u2.domain.com에 대한 DNS 조회를 기반으로
   요청 URI :

      BYE sip : callee@u2.domain.com SIP / 2.0

16.12.1.2 엄격 라우팅 프록시 트래버스

   이 시나리오에서는 네 개의 프록시간에 대화 상자가 설정됩니다.
   이 중 Record-Route 헤더 필드 값이 추가됩니다. 세 번째 프록시
   RFC 2543에 명시된 엄격한 라우팅 절차를 구현하고
   많은 작품 진행 중.

      U1-> P1-> P2-> P3-> P4-> U2

   U2에 도착한 INVITE에는 다음이 포함됩니다.

      INVITE sip : callee@u2.domain.com SIP / 2.0
      연락처 : sip : caller@u1.example.com
      Record-Route : <sip : p4.domain.com; lr>
      Record-Route : <sip : p3.middle.com>
      Record-Route : <sip : p2.example.com; lr>
      Record-Route : <sip : p1.example.com; lr>

   어떤 U2가 200 OK로 응답합니다. 나중에 U2가 다음을 보냅니다.
   첫 번째 Route 헤더 필드 값을 기반으로 P4로 BYE 요청

      BYE sip : caller@u1.example.com SIP / 2.0
      경로 : <sip : p4.domain.com; lr>
      경로 : <sip : p3.middle.com>
      경로 : <sip : p2.example.com; lr>
      경로 : <sip : p1.example.com; lr>





Rosenberg, et. al. 표준 트랙 [Page 120]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   P4는 Request-URI에 표시된 자원에 대한 책임이 없다.
   그래서 그것은 그것을 내버려 둘 것입니다. 그것은 그것이
   첫 번째 Route 헤더 필드 값을 제거합니다. 그런 다음
   첫 번째 Route 헤더 필드 값에 따라 요청을 보냅니다.
   sip : p3.middle.com하지만이 URI에는
   lr 매개 변수이므로 보내기 전에 다음과 같은 요청을 다시 형식화합니다.

      BYE sip : p3.middle.com SIP / 2.0
      경로 : <sip : p2.example.com; lr>
      경로 : <sip : p1.example.com; lr>
      경로 : <sip : caller@u1.example.com>

   P3은 엄격한 라우터이므로 P2에 다음을 전달합니다.

      BYE sip : p2.example.com; lr SIP / 2.0
      경로 : <sip : p1.example.com; lr>
      경로 : <sip : caller@u1.example.com>

   P2는 request-URI가 Record-Route에 배치 된 값임을 확인합니다
   헤더 필드를 추가 처리하기 전에 요청을 다시 작성합니다
   되려고:

      BYE sip : caller@u1.example.com SIP / 2.0
      경로 : <sip : p1.example.com; lr>

   P2는 u1.example.com에 대한 책임이 없으므로
   P1은 Route 헤더 필드 값의 해상도를 기반으로합니다.

   P1은 최상위 Route 헤더 필드 값에 자체를 고지하므로
   이를 제거하면 다음과 같이됩니다.

      BYE sip : caller@u1.example.com SIP / 2.0

   P1에는 u1.example.com에 대한 책임이 없으므로 경로가 없습니다.
   헤더 필드에서 P1은 u1.example.com에 요청을 전달합니다.
   요청 URI.

16.12.1.3 레코드 - 경로 헤더 필드 값 재 작성

   이 시나리오에서 U1과 U2는 다른 개인 네임 스페이스에 있고
   그들은 게이트웨이 역할을하는 프록시 P1을 통해 대화 상자에 들어갑니다.
   네임 스페이스 사이.

      U1-> P1-> U2







Rosenberg, et. al. 표준 트랙 [Page 121]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   U1은 다음을 전송합니다.

      INVITE sip : callee@gateway.leftprivatespace.com SIP / 2.0
      연락처 : <sip : caller@u1.leftprivatespace.com>

   P1은 위치 서비스를 사용하고 다음을 U2로 보냅니다.

      INVITE SIP : callee@rightprivatespace.com SIP / 2.0
      연락처 : <sip : caller@u1.leftprivatespace.com>
      Record-Route : <sip : gateway.rightprivatespace.com; lr>

   U2가 200 (OK)을 P1에 다시 보냅니다.

      SIP / 2.0 200 OK
      연락처 : <sip : callee@u2.rightprivatespace.com>
      Record-Route : <sip : gateway.rightprivatespace.com; lr>

   P1은 Record-Route 헤더 매개 변수를 다시 작성하여
   U1은 유용 할 것입니다. U1에 다음을 보냅니다.

      SIP / 2.0 200 OK
      연락처 : <sip : callee@u2.rightprivatespace.com>
      Record-Route : <sip : gateway.leftprivatespace.com; lr>

   나중에 U1이 다음 BYE 요청을 P1에 보냅니다.

      BYE sip : callee@u2.rightprivatespace.com SIP / 2.0
      경로 : <sip : gateway.leftprivatespace.com; lr>

   P1은 U2로 다음과 같이 전달합니다.

      BYE sip : callee@u2.rightprivatespace.com SIP / 2.0

17 거래

   SIP는 트랜잭션 프로토콜입니다. 구성 요소 간의 상호 작용은
   독립적 인 일련의 메시지 교환 장소. 특히, a
   SIP 트랜잭션은 단일 요청과 모든 응답으로 구성됩니다.
   해당 요청에는 0 개 이상의 임시 응답이 포함되며
   하나 이상의 최종 응답. 거래의 경우
   요청은 INVITE (INVITE 트랜잭션),
   트랜잭션은 또한 최종 응답이 아닌 경우에만 ACK를 포함합니다.
   2xx 응답. 응답이 2xx 인 경우 ACK는 고려되지 않습니다.
   거래의 일부.

      이 분리의 이유는
      모든 200 (OK) 응답을 INVITE에 UAC에 전달합니다. 에
      UAC에 모든 것을 제공하고, UAS만이 책임을진다.



Rosenberg, et. al. 표준 트랙 [122 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      재전송 (13.3.1.4 절 참조) 및 UAC 만
      ACK로 ACK에 응답 할 책임이 있습니다 (섹션
      13.2.2.4). 이 ACK는 UAC에 의해서만 재전송되기 때문에
      효과적으로 자체 거래로 간주됩니다.

   트랜잭션에는 클라이언트 측과 서버 측이 있습니다. 클라이언트 측
   클라이언트 트랜잭션 및 서버 측 서버 측으로 알려져 있습니다.
   트랜잭션. 클라이언트 트랜잭션은 요청을 전송하고
   서버 트랜잭션이 응답을 보냅니다. 클라이언트와 서버
   트랜잭션은 여러 개의 논리 함수에 임베드 된 논리 함수입니다.
   집단. 구체적으로 말하자면, 사용자 에이전트와 상태 저장 장치 내에 존재합니다
   프록시 서버. 섹션 4의 예를 고려하십시오.이 예에서,
   UAC는 클라이언트 트랜잭션을 실행하고 해당 아웃 바운드 프록시
   서버 트랜잭션을 실행합니다. 아웃 바운드 프록시는 또한
   요청을 서버 트랜잭션으로 보내는 클라이언트 트랜잭션
   인바운드 프록시 이 프록시는 또한 클라이언트 트랜잭션을 실행합니다.
   그런 다음 요청은 UAS의 서버 트랜잭션으로 전송됩니다.
   이것은 그림 4에 나와 있습니다.

   + --------- + + --------- + + --------- + + --------- +
   | + - + 요청 | + - + + - + | 요청 | + - + + - + | 요청 | + - + |
   | | C || -------> || S | | C || -------> || S | | C || -------> || S | |
   | | l | | || e | | l || || e | | l || || e | |
   | | i || || r | | i || || r | | i || || r | |
   | | e || || v | | e || || v | | e || || v | |
   | | n || || e | | n || || e | | n || || e | |
   | | t || || r | | t || || r | | t || || r | |
   | | || || | | || || | | || || | |
   | | T || || T | | T || || T | | T || || T | |
   | | r || || r | | r || || r | | r || || r | |
   | | a || || a | | a || || a | | a || || a | |
   | | n || || n | | n || || n | | n || || n | |
   | | s || 응답 || s | | s || 응답 || s | | s || 응답 || s | |
   | + - + | <------- | + - + + - + | <------- | + - + + - + | <------- | + - + |
   + --------- + + --------- + + --------- + + --------- +
      UAC 아웃 바운드 인바운드 UAS
                        프록시 프록시

                  그림 4 : 트랜잭션 관계

   상태 비 저장 프록시에는 클라이언트 또는 서버 트랜잭션이 포함되어 있지 않습니다.
   트랜잭션은 한 쪽 UA 또는 상태 유지 프록시간에 존재하며,
   다른쪽에는 UA 또는 상태 기반 프록시가 있습니다. SIP까지
   트랜잭션이 걱정되다 보니 상태없는 프록시가 효과적입니다.
   투명한. 클라이언트 트랜잭션의 목적은
   클라이언트가 내장 된 요소로부터 요청을받습니다 (이것을
   요소 "거래 사용자"또는 TU; 그것은 UA 또는 stateful 일 수 있습니다.
   프록시), 서버 트랜잭션에 대한 요청을 안정적으로 전달할 수 있습니다.



Rosenberg, et. al. 표준 트랙 [Page 123]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   클라이언트 트랜잭션은 응답 수신도 담당합니다.
   모든 응답을 필터링하여 TU로 전달
   재전송 또는 허용되지 않은 응답 (예 : ACK에 대한 응답).
   또한, INVITE 요청의 경우, 클라이언트
   트랜잭션은 모든 사용자에 대한 ACK 요청 생성에 대한 책임이 있습니다.
   최종 응답은 2xx 응답을받습니다.

   마찬가지로, 서버 트랜잭션의 목적은
   요청을 전송 계층에서 가져 와서 TU로 전달합니다. 그만큼
   서버 트랜잭션은 모든 요청 재전송을
   네트워크. 서버 트랜잭션은 TU 및
   이들을 전송 계층으로 전달하여
   네트워크. INVITE 트랜잭션의 경우, ACK를 흡수합니다
   2xx 응답을 제외한 모든 최종 응답을 요청하십시오.

   2xx 응답과 ACK는 특별한 대우를받습니다. 이
   응답은 UAS에 의해서만 재전송되고 ACK는 생성된다
   UAC에 의해. 이러한 엔드 - 투 - 엔드 처리는 호출자
   통화를 수락 한 전체 사용자 집합을 알고 있습니다. 때문에
   이 특수 처리 중 2xx 응답의 재전송은
   트랜잭션 계층이 아니라 UA 코어에서 처리합니다. 비슷하게,
   2xx에 대한 ACK의 생성은 UA 코어에 의해 처리된다. 마다
   경로를 따르는 프록시는 각 2xx 응답을 INVITE에 전달하기 만하고
   해당 ACK.

17.1 고객 거래

   클라이언트 트랜잭션은
   상태 기계 유지 보수.

   TU는 클라이언트 트랜잭션과 간단한
   인터페이스. TU가 새로운 거래를 시작하고자 할 때,
   클라이언트 트랜잭션을 생성하고 전송할 SIP 요청을 전달합니다.
   전송할 IP 주소, 포트 및 전송을 지정합니다. 그만큼
   클라이언트 트랜잭션은 상태 머신의 실행을 시작합니다. 유효한
   응답은 클라이언트 트랜잭션에서 TU로 전달됩니다.

   클라이언트 트랜잭션 상태 시스템에는 두 가지 유형이 있습니다.
   TU가 통과 한 요청 방법 하나는 클라이언트를 처리합니다.
   INVITE 요청에 대한 트랜잭션. 이 유형의 기계는
   to를 INVITE 클라이언트 트랜잭션으로 변환합니다. 다른 유형은 클라이언트를 처리합니다.
   INVITE 및 ACK를 제외한 모든 요청에 ​​대한 트랜잭션. 이것은
   비 -INITE 클라이언트 트랜잭션이라고합니다. 클라이언트가 없습니다.
   ACK를위한 트랜잭션. 만약 TU가 ACK를 보내기를 원하면,
   전송을 위해 전송 레이어에 직접 연결됩니다.






Rosenberg, et. al. 표준 트랙 [Page 124]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   INVITE 트랜잭션은 다른 메소드의 트랜잭션과 다릅니다.
   그 기간이 길기 때문입니다. 일반적으로 사람의 입력이 필요합니다.
   INVITE에 응답하기 위해 예상되는 긴 지연
   3 방향 핸드 셰이크에 대한 응답을 보내는 것. 다른쪽에
   한편, 다른 방법에 대한 요청은 빠르게 완료 될 것으로 예상됩니다.
   비 INVITE 트랜잭션이 양방향 트랜잭션에 의존하기 때문에
   핸드 셰이크, TU는 비 INVITE 요청에 즉시 응답해야합니다.

17.1.1 INVITE 클라이언트 트랜잭션

17.1.1.1 INVITE 트랜잭션 개요

   INVITE 트랜잭션은 3 방향 핸드 셰이크로 구성됩니다. 클라이언트
   트랜잭션은 INVITE를 보내고, 서버 트랜잭션은 응답을 보내고,
   클라이언트 트랜잭션은 ACK를 보냅니다. 신뢰할 수없는 운송 수단
   (예 : UDP), 클라이언트 트랜잭션은 요청을 재전송합니다.
   T1 초에서 시작하여 매회마다 두 배가되는 간격
   재전송. T1은 왕복 시간 (RTT)의 추정치이며,
   기본값은 500ms입니다. 거의 모든 트랜잭션 타이머
   여기에 설명 된 T1은 T1로, T1은 그 값을 조정합니다.
   요청은 신뢰할 수있는 전송을 통해 재전송되지 않습니다. 후
   1xx 응답 수신, 모든 재전송이 모두 중단되며,
   클라이언트는 추가 응답을 기다립니다. 서버 트랜잭션은
   추가 1xx 응답을 보내십시오.
   서버 트랜잭션 결국, 서버 트랜잭션은
   최종 응답을 보냅니다. 신뢰할 수없는 전송의 경우 해당 응답
   주기적으로 재전송되며, 신뢰성있는 전송을 위해
   한 번 보냈습니다. 클라이언트에서 수신 된 각 최종 응답
   트랜잭션에서 클라이언트 트랜잭션은 ACK를 보내고
   응답의 재전송을 끄는 것입니다.

17.1.1.2 형식 설명

   INVITE 클라이언트 트랜잭션의 상태 머신은 다음과 같습니다.
   그림 5. 초기 상태 인 "calling"은 TU
   INVITE 요청으로 새로운 클라이언트 트랜잭션을 시작합니다. 그만큼
   클라이언트 트랜잭션은 요청을 전송 계층에 전달해야한다.
   전송 (섹션 18 참조). 신뢰할 수없는 운송 수단이있는 경우
   사용되면 클라이언트 트랜잭션은 T1 값으로 타이머 A를 시작해야합니다.
   신뢰할 수있는 전송이 사용되면 클라이언트 트랜잭션은
   타이머 A가 시작되지 않음 (타이머 A가 요청 재전송을 제어 함). 에 대한
   어떤 전송이라도, 클라이언트 트랜잭션은 타이머 B를 값으로 시작해야한다
   64 * T1 초 (타이머 B는 트랜잭션 타임 아웃을 제어 함).

   타이머 A가 발생하면 클라이언트 트랜잭션은
   요청을 전송 계층으로 전달하여
   2 * T1의 값을 갖는 타이머. 재전송의 공식 정의




Rosenberg, et. al. 표준 트랙 [Page 125]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   트랜잭션 계층의 컨텍스트 내에서 메시지를 가져 오는 것입니다.
   이전에 전송 계층으로 전송되어 전송 계층으로 전달됩니다.
   한 번 더 레이어.

   타이머 A가 2 * T1 초 후에 발생하면 요청은 반드시
   다시 재전송됩니다 (클라이언트 트랜잭션이 여전히이 상태에 있다고 가정 함).
   상태). 이 프로세스는 요청이 계속되도록 계속 진행해야합니다.
   각 전송 후에 두 배의 간격으로 재전송된다.
   이러한 재전송은 클라이언트
   트랜잭션이 "호출"상태에 있습니다.

   T1의 기본값은 500ms입니다. T1은 RTT의 추정치입니다.
   클라이언트와 서버 트랜잭션 사이. 요소는 (비록
   NOT RECOMMENDED) T1의 더 작은 값을 폐쇄 된, 사적인
   일반 인터넷 연결을 허용하지 않는 네트워크. T1이 될 수 있습니다.
   더 크게 선택하십시오. 사전에 알고 있다면 권장됩니다.
   (높은 대기 시간 액세스 링크에서와 같이) RTT가 더 큽니다.
   T1의 가치가 무엇이든, 재전송에 대한 지수 적 백 오프
   이 절에서 설명 된 내용을 반드시 사용해야합니다.

   타이머가있을 때 클라이언트 트랜잭션이 여전히 "호출 중"상태 인 경우
   B가 발생하면 클라이언트 트랜잭션은 TU에 타임 아웃을 알려야한다.
   발생했습니다. 클라이언트 트랜잭션은 ACK를 발생 시켜서는 안된다. 그만큼
   64 * T1의 값은 7을 보내는 데 필요한 시간과 같습니다.
   신뢰할 수없는 운송의 경우 요청.

   클라이언트 트랜잭션이 잠정적 인 응답을받는 동안
   "통화 중"상태가되면 "진행 중"상태로 전환됩니다. 에서
   "Proceeding"상태, 클라이언트 트랜잭션은
   더 이상 요청하지 마십시오. 또한 임시 응답은 반드시
   TU로 넘어 갔다. 추가 임시 응답은 반드시 통과되어야한다.
   "Proceeding"상태 인 동안 TU까지.

   "통화 중"또는 "진행 중"상태에서
   300-699의 상태 코드를 가진 응답은 클라이언트를 야기해야합니다
   트랜잭션을 "완료"로 전환합니다. 클라이언트 트랜잭션
   수신 된 응답을 TU까지 전달해야하며, 클라이언트
   트랜잭션이 전송 된 경우에도 트랜잭션은 ACK 요청을 생성해야합니다.
   신뢰할 수있는 (응답으로부터 ACK를 구성하기위한 지침은
   17.1.1.3 절에서 주어진다.) 그리고 ACK를 전송에 전달한다.
   레이어. ACK는 반드시 같은 주소로 전송되어야한다.
   포트 및 원래 요청이 전송 된 전송. 그만큼
   클라이언트 트랜잭션은 타이머 D가 시작될 때 타이머 D를 시작해야한다.
   신뢰할 수없는 경우 최소 32 초의 값을 가진 "Completed"상태
   전송 및 신뢰할 수있는 전송을위한 0 초의 값을 제공합니다.
   타이머 D는 서버 트랜잭션이 수행 할 수있는 시간을 반영합니다.
   신뢰할 수없는 전송이 사용될 때 "완료 됨"상태를 유지합니다.
   이것은 INVITE 서버 트랜잭션의 Timer H와 같으며



Rosenberg, et. al. 표준 트랙 [Page 126]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   기본값은 64 * T1입니다. 그러나 클라이언트 트랜잭션은
   서버 트랜잭션에서 사용중인 T1 값이므로 절대 최소값
   T1에서 타이머 D를 사용하는 대신 32 초가 사용됩니다.

   에서 수신되는 최종 응답의 모든 재전송
   "Completed"상태는 반드시 ACK를
   재전송을위한 전송 계층이 아니라 새로 수신 된 응답
   TU로 넘겨서는 안됩니다. 응답의 재전송은 다음과 같습니다.
   동일한 클라이언트 트랜잭션과 일치하는 응답으로 정의됩니다.
   섹션 17.1.3의 규칙을 기반으로합니다.









































Rosenberg, et. al. 표준 트랙 [쪽 127]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


                               | TU에서 초대
             타이머 A가 터집니다. | INVITE가 전송되었습니다.
             리셋 A, V 타이머 B 불
             INVITE + ----------- + 또는 전송 오류.
               + --------- | | --------------- + TU에 알린다.
               | | 전화하기 | |
               + --------> | | --------------> |
                         + ----------- + 2xx |
                            | | 2xx ~ TU |
                            | | 1xx |
    300-699 + --------------- + | 1xx - TU |
   ACK 전송 됨 | | |
resp. TU로 | 1xx V |
            | 1xx ~ TU ----------- + |
            | + --------- | | | |
            | | 진행 | --------------> |
            | + --------> | | 2xx |
            | + ----------- 2xx에서 TU로 |
            | 300-699 | |
            | ACK가 전송 됨, | |
            | resp. TU로 | |
            | | | 노트:
            | 300-699 V |
            | ACK 전송 + ----------- + 전송 오류. | 전환
            | + --------- | | TU에 통보 | 다음으로 분류 된
            | | | 완료 | --------------> | 이벤트
            | + --------> | | | 행동을 넘어서
            | + ----------- + | 가지다
            | ^ | |
            | | | 타이머 D |
            + -------------- + | - |
                               | |
                               V |
                         + ----------- + |
                         | | |
                         | 종료 됨 | <-------------- +
                         | |
                         + ----------- +

                 그림 5 : INVITE 클라이언트 트랜잭션

   클라이언트 트랜잭션이 "Completed"상태 인 동안 타이머 D가 작동하면
   상태에서 클라이언트 트랜잭션은 종료 된 상태로 이동해야합니다 (MUST).

   "통화 중"또는 "진행 중"상태에서
   2xx 응답은 클라이언트 트랜잭션이
   "종료 됨"상태이며 응답은 TU로 전달되어야합니다 (MUST).
   이 응답의 처리는 TU가 프록시인지 여부에 따라 달라집니다



Rosenberg, et. al. 표준 트랙 [쪽 128]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   코어 또는 UAC 코어. UAC 코어는 다음에 대한 ACK 생성을 처리합니다.
   이 응답은 프록시 코어가 항상 200 (OK)
   업스트림 프록시와 UAC 간의 200 (OK) 처리 방식이 다릅니다.
   그것의 취급이 그 곳에서 일어나지 않는 이유입니다.
   트랜잭션 계층.

   클라이언트 트랜잭션은 클라이언트 트랜잭션이 진입 할 때 즉시 파괴되어야합니다.
   "종료 됨"상태. 이것은 실제로 올바른 것을 보장하는 데 필요합니다.
   조작. 그 이유는 INVITE에 대한 2xx 응답이
   다르게; 각각은 프록시에 의해 전달되고, ACK 처리
   UAC에서는 다릅니다. 따라서 각 2xx는 프록시에 전달되어야합니다.
   코어 (포워딩 할 수 있도록)와 UAC 코어 (그래서
   인정했다). 트랜잭션 계층 처리가 수행되지 않습니다.
   응답이 전송에 의해 수신 될 때마다, 전송
   계층은 일치하는 클라이언트 트랜잭션을 찾지 못합니다 (
   섹션 17.1.3), 응답은 직접 코어로 전달됩니다. 이후
   일치하는 클라이언트 트랜잭션은 첫번째 2xx에 의해 파괴되고,
   후속 2xx는 일치하는 항목을 찾을 수 없으므로
   핵심.

17.1.1.3 ACK 요청의 구성

   이 섹션은 내부에서 전송 된 ACK 요청의 구성을 지정합니다.
   클라이언트 트랜잭션 2xx에 대한 ACK를 생성하는 UAC 코어
   대신 13 절에 설명 된 규칙을 따라야합니다.

   클라이언트 트랜잭션에 의해 생성 된 ACK 요청은
   Call-ID, From 및 Request-URI에 대한 값은 다음과 같습니다.
   전송에 전달 된 요청의 헤더 필드 값
   클라이언트 트랜잭션 (이를 "원래 요청"이라고 함)에 의해. 받는 사람
   ACK의 헤더 필드는 반드시 To 헤더 필드와 동일해야한다.
   응답이 인정되므로 일반적으로
   원래 요청의 To 헤더 필드에
   태그 매개 변수. ACK는 하나의 Via 헤더 필드를 포함해야하며,
   이것은 반드시 원래의 Via 헤더 필드와 동일해야한다.
   의뢰. ACK의 CSeq 헤더 필드는 반드시 같아야한다.
   원래 요청에있는 시퀀스 번호의 값
   method 매개 변수는 "ACK"와 같아야한다.













Rosenberg, et. al. 표준 트랙 [129 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   응답이 수신 확인되고있는 INVITE 요청에 Route
   헤더 필드는 ACK에 나타나야한다. 이것은
   ACK가 모든 다운 스트림을 통해 적절히 라우팅 될 수 있도록 보장
   무국적 프록시.

   모든 요청이 본문을 포함 할 수 있지만, ACK의 본문은 특별하다.
   신체가 이해되지 않으면 요청을 거절 할 수 없기 때문입니다.
   그러므로, 2xx가 아닌 사람들을위한 ACK에 몸체를 배치하는 것은 권장되지 않는다.
   하지만 끝나면 신체 유형은 나타난 신체 유형으로 제한됩니다.
   INVITE에 대한 응답이 415가 아닌 것으로 가정하는 INVITE.
   그것은 ACK의 본문이 Accept에 나열된 모든 유형 일 수 있습니다
   415의 헤더 필드.

   예를 들어, 다음 요청을 고려하십시오.

   INVITE SIP : bob@biloxi.com SIP / 2.0
   경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKkjshdyff
   To : Bob <sip : bob@biloxi.com>
   보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 88sja8x
   최대 전진 : 70
   통화 ID : 987asjd97y7atg
   CSeq : 986759 INVITE

   이 요청에 대한 2xx가 아닌 최종 응답에 대한 ACK 요청은
   다음과 같이 보입니다.

   ACK 모금 : bob@biloxi.com SIP / 2.0
   경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKkjshdyff
   받는 사람 : Bob <sip : bob@biloxi.com>; tag = 99sa0xk
   보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 88sja8x
   최대 전진 : 70
   통화 ID : 987asjd97y7atg
   CSeq : 986759 ACK

17.1.2 비 INVITE 클라이언트 트랜잭션

17.1.2.1 비 INVITE 트랜잭션 개요

   비 -INITE 트랜잭션은 ACK를 사용하지 않습니다. 그들은 간단하다.
   요청 - 응답 상호 작용. 신뢰할 수없는 전송의 경우 요청
   T1에서 시작하여 두 배가되는 간격으로 재전송된다.
   그것은 T2를 친다. 임시 응답이 수신되면, 재전송
   신뢰할 수없는 운송은 계속하지만 T2의 간격을 유지하십시오. 그만큼
   서버 트랜잭션은 보낸 마지막 응답을 재전송합니다.
   잠정적 인 또는 최종적인 응답이어야한다.
   요청이 수신되었습니다. 이것이 요청 재전송이
   임시 응답 후에도 계속하라. 그들은
   최종 응답의 신뢰할 수있는 전달.



Rosenberg, et. al. 표준은 궤 [129 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   INVITE 트랜잭션과 달리 INVITE가 아닌 트랜잭션에는 특별한 트랜잭션이 없습니다.
   2xx 응답 처리. 결과는 단 하나의 2xx
   비 -INVITE에 대한 응답은 UAC에 전달됩니다.

17.1.2.2 형식 설명

   비 -INITE 클라이언트 트랜잭션에 대한 상태 시스템은 다음과 같습니다.
   그림 6. INVITE의 상태 시스템과 매우 유사합니다.

   TU가 새로운 클라이언트를 시작할 때 "Trying"상태로 들어감
   요청과 트랜잭션. 이 상태가되면 클라이언트
   트랜잭션은 타이머 F를 64 * T1 초 동안 발사하도록 설정해야합니다 (SHOULD). 요청
   전송을 위해 반드시 전송 계층으로 전달되어야한다. 만약
   신뢰할 수없는 전송이 사용 중이면 클라이언트 트랜잭션은 타이머를 설정해야합니다
   T1 초 후에 E가 발사됩니다. 이 상태에서 타이머 E가 계속 작동하면,
   타이머는 리셋되지만 이번에는 MIN (2 * T1, T2)의 값으로 재설정됩니다.
   타이머가 다시 작동하면 MIN (4 * T1, T2)으로 재설정됩니다. 이
   프로세스가 계속해서 재전송이 기하 급수적으로 발생합니다.
   T2에서 대문자 간격 증가. T2의 기본값은 4s이며,
   비 INVITE 서버 트랜잭션 시간을 나타냅니다
   응답하지 않으면 요청에 응답하는 데 걸릴 것입니다.
   바로. 기본값 T1 및 T2의 경우이 결과는 다음과 같습니다.
   500 ms, 1 s, 2 s, 4 s, 4 s, 4 s 등의 간격

   클라이언트 트랜잭션이 여전히있는 동안 Timer F가 실행되면
   "Trying"상태에서 클라이언트 트랜잭션은 TU에
   타임 아웃 후에 "종결 됨"상태로 들어가야합니다. 만약
   "Trying (시도 중)"상태 인 동안 임시 응답이 수신됩니다.
   응답은 TU로 전달되어야하며, 그런 다음 클라이언트 트랜잭션
   "Proceeding"상태로 옮겨야한다. 최종 응답 (상태
   코드 200-699)가 수신되면 "Trying"상태에서 응답
   반드시 TU로 전달되어야하며 클라이언트 트랜잭션은 반드시 변환되어야합니다
   완료 됨 "상태로 변경됩니다.

   Timer E가 "Proceeding"상태 인 동안 발생하면 요청은 반드시 "
   에 전달 된
재전송을위한 전송 계층, 그리고 타이머 E가 있어야한다.
   값은 T2 초로 재설정됩니다. 타이머 F가
   "Proceeding (진행 중)"상태 인 경우, TU는 타임 아웃을 통보 받아야하며,
   클라이언트 트랜잭션은 종료 된 상태로 천이해야한다. 만약
   최종 응답 (상태 코드 200-699)은
   "Proceeding"상태에서 응답은 TU로 전달되어야하며,
   클라이언트 트랜잭션은 반드시 "Completed"상태로 천이해야한다.

   클라이언트 트랜잭션이 "Completed"상태가되면 반드시 설정해야합니다
   신뢰할 수없는 전송을 위해 T4 초 내에 발사하는 타이머 K 및 0
   신뢰할 수있는 운송을위한 초. '완료 됨'상태는
   수신 된 추가 응답 재전송을 버퍼링한다.
   (클라이언트 트랜잭션이



Rosenberg, et. al. 표준 트랙 [131 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   신뢰할 수없는 전송). T4는 네트워크의 시간 량을 나타냅니다.
   클라이언트와 서버 트랜잭션 사이의 메시지를 지우는 데 걸릴 것입니다.
   T4의 기본값은 5 초입니다. 응답은 다음 경우에 재전송입니다.
   섹션에 지정된 규칙을 사용하여 동일한 트랜잭션과 일치합니다.
   17.1.3. 이 상태에서 Timer K가 실행되면 클라이언트 트랜잭션
   반드시 "Terminated"상태로 천이해야한다.

   트랜잭션이 종료 된 상태에 이르면 반드시 폐기해야합니다.
   바로.

17.1.3 클라이언트 트랜잭션에 대한 응답 대응

   클라이언트의 전송 계층이 응답을 받으면
   응답을 처리 할 클라이언트 트랜잭션을 결정하십시오.
   섹션 17.1.1 및 17.1.2의 처리가 발생할 수 있습니다. 그만큼
   상단 Via 헤더 필드의 분기 매개 변수가이 용도로 사용됩니다.
   목적. 응답이 두 개 미만의 클라이언트 트랜잭션과 일치합니다.
   정황:

      1. 응답의 분기 매개 변수 값이 동일한 경우
          맨 위의 분기 매개 변수로 가기 비아 헤더 필드
          트랜잭션을 생성 한 요청의 헤더 필드를 통해.

      2. CSeq 헤더 필드의 method 매개 변수가
          트랜잭션을 생성 한 요청의 메소드. 그만큼
          CANCEL 요청이 a를 구성하기 때문에 메소드가 필요합니다.
          다른 거래이지만 지점의 동일한 가치를 공유합니다.
          매개 변수.

   요청이 멀티 캐스트를 통해 전송되는 경우
   여러 서버에서 여러 응답을 생성합니다. 이 응답들
   모두가 최상위 비아에 동일한 분기 매개 변수를 갖지만 가변적입니다
   To 태그 규칙을 기반으로받은 첫 번째 응답
   위의 내용이 사용되며 다른 내용은 재전송으로 간주됩니다.
   그것은 오류가 아닙니다. 멀티 캐스트 SIP는 오직 초보자에게만 제공됩니다.
   "단일 홉 발견과 같은"서비스는
   단일 응답. 자세한 내용은 18.1.1 절을 참조하십시오.














Rosenberg, et. al. 표준 트랙 [Page 132]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


17.1.4 전송 오류 처리

                                   | TU로부터의 요청
                                   | 요청 보내기
               타이머 E V
               요청 보내기 + ----------- +
                   + --------- | | ------------------- +
                   | | 시도 | 타이머 F |
                   + --------> | | 또는 운송 오류 |
                             + ----------- + TU에 알린다 |
                200-699 | | |
                resp. TU로 | | 1xx |
                + --------------- + | resp. TU로 |
                | | |
                | 타이머 E V 타이머 F |
                | req + ----------- + 또는 전송 오류를 보냅니다. |
                | + --------- | | TU에게 알린다 |
                | | 진행 | ------------------> |
                | + --------> | | ----- + |
                | + ----------- + | 1xx |
                | | ^ | resp to TU |
                | 200-699 | + -------- + |
                | resp. TU로 | |
                | | |
                | V |
                | + ----------- + |
                | | | |
                | | 완료 | |
                | | | |
                | + ----------- + |
                | ^ | |
                | | | 타이머 K |
                + -------------- + | - |
                                   | |
                                   V |
             참고 : + ----------- + |
                             | | |
         전환 | 종료 됨 | <------------------ +
         | |
         이벤트 + ----------- +
         행동을 넘어서
         가지다

                 그림 6 : 비 INVITE 클라이언트 트랜잭션

   클라이언트 트랜잭션이 전송 계층에 요청을 보낼 때
   전송 될 경우, 다음 절차가 수행된다.
   실패를 나타냅니다.



Rosenberg, et. al. 표준 트랙 [133 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   클라이언트 트랜잭션은 TU에게 전송 실패를 알린다 (SHOULD)
   가 발생했으며 클라이언트 트랜잭션은 직접 전환해야합니다 (SHOULD).
   "종료 됨"상태로 변경됩니다. TU가 장애 조치를 처리합니다.
   메커니즘 [4]에 설명되어 있습니다.

17.2 서버 트랜잭션

   서버 트랜잭션은 요청 전달을 담당합니다.
   TU와 신뢰할 수있는 응답 전달. 그것은 성취한다.
   이 상태 기계를 통해. 서버 트랜잭션은
   요청이 수신되고 트랜잭션 처리가 필요한 경우 코어
   해당 요청에 대해 (항상 그런 것은 아닙니다).

   클라이언트 트랜잭션과 마찬가지로 상태 시스템은
   수신 된 요청은 INVITE 요청입니다.

17.2.1 INVITE 서버 트랜잭션

   INVITE 서버 트랜잭션의 상태 다이어그램은
   그림 7.

   요청에 대해 서버 트랜잭션이 구성되면
   "Proceeding"상태. 서버 트랜잭션은 100을 생성해야한다.
   (Trying) 응답은 TU가
   200 ms 이내에 임시 응답 또는 최종 응답을 할 수 있으며,이 경우 MAY
   100 (Trying) 응답을 생성합니다. 이 임시 응답은 다음과 같습니다.
   회피를 피하기 위해 재전송 요청을 급속히 중단해야했습니다.
   네트워크 정체. 100 (Trying) 응답이 생성됩니다.
   8.2.6 절의 절차에 따라,
   응답의 To 헤더 필드에 태그 삽입 (없는 경우)
   요청에 있음)는 MAY에서 SHOULD NOT으로 다운 그레이드됩니다.
   요청은 TU로 전달되어야합니다 (MUST).

   TU는 임의의 수의 임시 응답을 서버에 전달합니다
   트랜잭션. 서버 트랜잭션이
   "Proceeding"상태, 이들 각각은 반드시 전송으로 전달되어야합니다
   레이어. 그것들은
   트랜잭션 계층 (그것들에 의해 재전송되지 않음)
   서버 트랜잭션 상태의 변경. 요청이있는 경우
   재전송은 "Proceeding"상태에서 가장 많은
   TU로부터받은 최근 잠정 응답은
   재전송을 위해 전송 계층으로 전달된다. 요청은
   동일한 서버 트랜잭션과 일치하는 경우 재전송
   섹션 17.2.3의 규칙.

   "Proceeding"상태에있는 동안, TU는 2xx 응답을
   서버 트랜잭션, 서버 트랜잭션은 이것을 통과해야합니다
   전송을위한 전송 계층에 대한 응답. 그것은 아니다.



Rosenberg, et. al. 표준 트랙 [Page 134]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   서버 트랜잭션에 의해 재전송 됨; 2xx의 재전송
   응답은 TU에 의해 처리됩니다. 그런 다음 서버 트랜잭션은 반드시
   "종결 됨"상태로 전환하십시오.

   "Proceeding"상태에있는 동안, TU가
   상태 코드 300에서 699로 서버 트랜잭션, 응답
   전송을 위해 전송 계층에 전달되어야하며, 상태
   기계는 "Completed"상태에 있어야합니다. 신뢰할 수없는 운송 수단의 경우,
   타이머 G는 T1 초 후에 발사되도록 설정되어 있으며 발사하도록 설정되지 않았습니다.
   신뢰할 수있는 운송 수단.

      이것은 RFC 2543의 변경 사항입니다. 응답은 항상
      신뢰할 수있는 전송 이상의 경우에도 재전송됩니다.

   "Completed (완료)"상태가 입력되면 타이머 H가 반드시 켜져 야합니다 (MUST).
   모든 전송에 대해 64 * T1 초. 타이머 H는 서버가
   트랜잭션은 응답을 다시 전송합니다. 그 가치는
   타이머 B와 같도록 선택한 경우 클라이언트 트랜잭션 시간
   요청 보내기를 계속 재 시도하십시오. 타이머 G가 실행되면 응답
   재전송을 위해 다시 한번 전송 계층으로 전달되고,
   타이머 G는 MIN (2 * T1, T2) 초 동안 점화되도록 설정됩니다. 그때부터 언제
   타이머 G가 실행되면 응답은 다음과 같이 다시 전송 장치로 전달됩니다.
   전송 및 타이머 G는 두 배가되는 값으로 재설정됩니다.
   이 값이 T2를 초과하면이 값은
   T2. 이것은 요청에 대한 재전송 동작과 동일합니다.
   비 INVITE 클라이언트 트랜잭션의 "시도 중"상태. 더욱이,
   "Completed"상태에서 요청 재전송이
   서버는 전송을 위해 응답을 전달해야한다 (SHOULD).
   재전송.

   서버 트랜잭션이 서버 트랜잭션에있는 동안 ACK가 수신되면
   "완료 됨"상태에서 서버 트랜잭션은
   "확인 된"상태. 이 상태에서 타이머 G가 무시되므로
   응답의 재전송이 중단됩니다.

   타이머 H가 "Completed"상태에서 실행되면 이는
   ACK는 절대로받지 못했습니다. 이 경우, 서버 트랜잭션은 반드시
   "Terminated"상태로 천이하고 TU에 표시해야합니다
   트랜잭션 실패가 발생했음을 나타냅니다.












Rosenberg, et. al. 표준 트랙 [쪽 135]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


                               | 초대
                               | INV to TU 패스
            INVITE V는 TU가 200ms 이내에 있지 않으면 100을 보냅니다.
            응답 보내기 + ----------- +
                + -------- | | -------- TU에서 101-199
                | | 진행 | 응답 보내기
                + -------> | | <------- +
                         | | 운송 오류.
                         | | TU에 통보
                         | | ---------------> +
                         + ----------- + |
            TU에서 300-699 | | TU에서 2xx |
            응답 보내기 | | 응답 보내기 |
                            | + ------------------> +
                            | |
            INVITE V 타이머 G 화재 |
            응답 보내기 + ----------- + 응답 보내기 |
                + -------- | | -------- + |
                | | 완료 | | |
                + -------> | | <------- + |
                         + ----------- + |
                            | | |
                        ACK | | |
                        - | + ------------------> +
                            | 타이머 H |
                            V 또는 전송 오류. |
                         + ----------- + Inform TU |
                         | | |
                         | 확인 된 | |
                         | | |
                         + ----------- + |
                               | |
                               타이머 I 발생 |
                               | - |
                               | |
                               V |
                         + ----------- + |
                         | | |
                         | 종료 됨 | <--------------- +
                         | |
                         + ----------- +

              그림 7 : INVITE 서버 트랜잭션








Rosenberg, et. al. 표준 트랙 [Page 136]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   "확인 된"상태의 목적은 추가 ACK를 흡수하는 것입니다
   최종 메시지의 재전송으로 인해 도착한 메시지
   응답. 이 상태가 입력되면 타이머 I는 T4에서 시작되도록 설정됩니다.
   신뢰할 수없는 전송의 경우 초, 신뢰할 수있는 경우는 0 초
   전송합니다. 일단 타이머가 작동하면 서버는 반드시
   "종료 됨"상태.

   트랜잭션이 "종결 됨"상태가되면 트랜잭션이 종료되어야합니다.
   즉시 파괴되었다. 클라이언트 트랜잭션과 마찬가지로이 작업이 필요합니다.
   INVITE에 대한 2xx 응답의 신뢰성을 보장합니다.

17.2.2 비 -INITE 서버 트랜잭션

   비 -INITE 서버 트랜잭션에 대한 상태 머신은 다음과 같습니다.
   그림 8.

   상태 머신은 "시도 중"상태에서 초기화되고 통과됩니다.
   초기화 될 때 INVITE 또는 ACK 이외의 요청. 이 요청은
   TU로 넘어 갔다. "Trying"상태가되면 추가 요청
   재전송은 폐기됩니다. 요청은 재전송입니다.
   에 지정된 규칙을 사용하여 동일한 서버 트랜잭션과 일치합니다.
   17.2.3 절.

   "Trying"상태에있는 동안, TU가 잠정적 응답을 통과하면
   서버 트랜잭션에 서버 트랜잭션은 반드시
   "Proceeding"상태. 응답은 반드시 전송으로 전달되어야한다.
   레이어. 추가 임시 응답은 다음과 같습니다.
   "Proceeding"상태에있는 동안 TU로부터 수신 된
   전송을 위해 전송 계층에 전달한다. 재전송이
   요청은 "진행 중"상태 인 동안 수신되고,
   최근 전송 된 임시 응답은 전송에 전달되어야한다
   레이어를 재전송합니다. TU가 최종 응답 (상태
   코드 200-699)를 서버에 보내고 "Proceeding"상태에서
   트랜잭션은 "Completed"상태에 있어야하며, 응답은 반드시 MUST
   전송을 위해 전송 계층으로 전달 될 수 있습니다.

   서버 트랜잭션이 "Completed"상태가되면 반드시 "
   타이머 J는 신뢰할 수없는 전송에 대해서는 64 * T1 초, 그리고 0
   신뢰할 수있는 운송을위한 초. "완료 됨"상태에있는 동안
   서버 트랜잭션은 전송에 대한 최종 응답을 전달해야합니다
   요청의 재전송이있을 때마다 재전송을위한 계층
   받았습니다. TU가 서버에 전달한 기타 최종 응답
   트랜잭션은 "Completed"상태 인 동안 폐기되어야합니다. 그만큼
   Timer J가 실행될 때까지 서버 트랜잭션은이 상태로 유지됩니다.
   어느 시점에서 "종결"상태로 전환해야합니다.

   서버 트랜잭션은 서버 트랜잭션이 진입하는 즉시 파괴되어야합니다 (MUST).
   "종료 됨"상태.



Rosenberg, et. al. 표준 트랙 [Page 137]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


17.2.3 서버 트랜잭션에 요청 일치시키기

   요청이 서버에 의해 네트워크로부터 수신되면,
   기존 거래와 일치시킬 수 있습니다. 이것은
   다음과 같은 방식으로

   요청의 최상위 Via 헤더 필드에있는 분기 매개 변수
   검사됩니다. 그것이 존재하고 마법의 쿠키로 시작한다면
   "z9hG4bK"요청이 클라이언트 트랜잭션에 의해 생성되었습니다.
   이 사양을 준수합니다. 따라서 분기 매개 변수
   해당 클라이언트가 보낸 모든 트랜잭션에서 고유합니다. 그만큼
   다음과 같은 경우 요청이 트랜잭션과 일치합니다.

      1. 요청의 분기 매개 변수가 요청의 분기 매개 변수와 같습니다.
         top 생성 한 요청의 헤더 필드를 통해
         거래 및

      2. 요청의 최상위 비아에있는 sent-by 값은
         트랜잭션을 생성 한 요청에서 하나

      3. 요청의 메소드는 요청을 생성 한 메소드와 일치합니다.
         트랜잭션 (ACK 제외). 요청의 메소드
         거래를 생성 한 사람은 INVITE입니다.

   이 일치 규칙은 INVITE 및 비 -INVITE 트랜잭션 모두에 적용됩니다.
   서로 같은.

      sent-by 값은 일치 프로세스의 일부로 사용됩니다.
      지점이 실수로 또는 악의적으로 복제 될 수 있습니다.
      다른 클라이언트의 매개 변수

   맨 위의 Via 헤더 필드에있는 분기 매개 변수가없는 경우,
   또는 마법 쿠키가 포함되어 있지 않은 경우 다음 절차를 따르십시오.
   익숙한. RFC 2543과의 하위 호환성을 처리하기 위해 존재합니다.
   준수 구현.

   Request-URI, To 태그,
   발신 태그, Call-ID, CSeq 및 Via 헤더 입력란은
   트랜잭션을 생성 한 INVITE 요청 이 경우,
   INVITE는 (는)
   트랜잭션. Request-
   URI, From 태그, Call-ID, CSeq 번호 (메소드가 아님) 및 최상위 비아
   헤더 필드가 생성 된 INVITE 요청의 헤더 필드와 일치해야합니다.
   트랜잭션의 To 태그와 일치하고, ACK의 To 태그는
   서버 트랜잭션이 보낸 응답. 일치는
   각 헤더 필드에 대해 정의 된 일치 규칙
   ACK 일치의 To 헤더 필드에 태그 포함
   프로세스는 다른 응답에 대해 ACK에서 2xx에 대한 ACK를 명확히하는 데 도움이됩니다.



Rosenberg, et. al. 표준 트랙 [Page 138]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   프록시에서 두 응답을 모두 전달했을 수 있습니다.
   비정상적인 조건에서. 특히, 프록시가 요청을 분기 할 때,
   충돌이 발생하면 응답을 다른 프록시로 전달할 수 있습니다.
   이는 여러 응답을 업스트림으로 전달할 수 있습니다.) ACK
   이전 ACK와 일치하는 INVITE 트랜잭션과 일치하는 요청
   이전 ACK의 재전송으로 간주됩니다.













































Rosenberg, et. al. 표준 트랙 [쪽 139]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


                                  요청 접수
                                  | TU로 패스하십시오.
                                  V
                            + ----------- +
                            | |
                            | 시도 중 ------------- +
                            | | |
                            TU에서 + ----------- + | 200-699
                                  | 응답 보내기
                                  | TU에서 1xx |
                                  | 응답 보내기 |
                                  | |
               TU에서 V 1xx 요청 |
               응답 보내기 + ----------- + 응답 보내기 |
                   + -------- | | -------- + |
                   | | 진행 | | |
                   + -------> | | <------- + |
            + <-------------- | | |
            | Trnsprt Err + ----------- + |
            | TU에 통보 | |
            | | |
            | | TU에서 200-699 |
            | | 응답 보내기 |
            | 요청 V |
            | 응답 보내기 + ----------- + |
            | + -------- | | |
            | | | 완료 됨 | <------------ +
            | + -------> | |
            + <-------------- | |
            | Trnsprt Err + ----------- +
            | TU에 통보 |
            | 타이머 J 화재
            | | -
            | |
            | V
            | + ----------- +
            | | |
            + --------------> | 종료 됨 |
                            | |
                            + ----------- +

                그림 8 : 비 INVITE 서버 트랜잭션

   다른 모든 요청 방법의 경우 요청이 트랜잭션과 일치합니다.
   Request-URI, To 태그, From 태그, Call-ID, CSeq (
   메소드)와 최상위 Via 헤더 필드가
   거래를 만들었습니다. 일치는 일치에 따라 수행됩니다.




Rosenberg, et. al. 표준 트랙 [쪽 140]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   각 헤더 필드에 대해 정의 된 규칙 비 초대 고객
   요청이 기존 트랜잭션과 일치하면 재전송입니다.
   해당 트랜잭션을 생성 한 요청

   일치하는 규칙에는 Request-URI가 포함되기 때문에 서버는
   거래에 대한 응답을 일치시킵니다. TU가에 응답을 보낼 때
   서버 트랜잭션, 특정 서버로 전달해야 함
   응답이 목표로하는 거래.

17.2.4 전송 오류 처리

   서버 트랜잭션이 전송 계층에 응답을 보낼 때
   전송할 경우 다음 절차를 따르십시오.
   계층은 실패를 나타냅니다.

   먼저, [4]의 절차를 따르고,
   백업에 대한 응답. 그것들이 모두 실패해야한다면,
   [4]에서 실패의 정의, 서버 트랜잭션은 통지해야한다
   장애가 발생한 TU, 그리고 장애가 발생한 TU
   종료 상태.

18 수송

   전송 계층은 실제 전송을 담당합니다.
   네트워크 전송을 통한 요청 및 응답. 여기에는 다음이 포함됩니다.
   요청 또는 응답에 사용할 연결 결정
   연결 지향 전송의 경우

   전송 계층은 지속성을 관리합니다.
   TCP 및 SCTP와 같은 전송 프로토콜 또는 TLS를 통한 연결
   그것들은 전송 계층에 열린 것들을 포함한다. 여기에는 다음이 포함됩니다.
   클라이언트 또는 서버에 의해 열린 연결은
   연결은 클라이언트와 서버 전송 기능간에 공유됩니다.
   이러한 연결은 주소에서 형성된 튜플에 의해 인덱스되며,
   포트 및 전송 프로토콜을 지원합니다. 언제
   전송 계층에 의해 연결이 열리면이 인덱스는
   목적지 IP, 포트 및 전송. 연결이되면
   전송 계층에서 허용 한이 인덱스는 소스 IP로 설정됩니다.
   주소, 포트 x 호 W 전송. 소스
   포트는 종종 임시 포트이지만 포트가 있는지 여부를 알 수 없습니다.
   일시적이거나 [4]의 절차를 통해 선택됨, 연결이 수락 됨
   전송 계층에 의한 재사용은 자주 재사용되지 않는다. 결과는 다음과 같습니다.
   연결을 사용하는 "피어링"관계에있는 두 개의 프록시는,
   지향 전송은 자주 두 개의 연결이 사용됩니다.
   각 방향에서 시작된 거래.






Rosenberg, et. al. 표준 트랙 [Page 141]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   일부 사람들은 연결을 열어 두는 것이 좋습니다
   최종 메시지를 보낸 후 구현 정의 된 기간 또는
   그 연결을 통해 받았다. 이 기간은 적어도 같아야합니다
   요소를 가져 오기 위해 필요한 가장 긴 시간
   인스턴스화에서 종료 된 상태로의 트랜잭션. 이것은 ~이다.
   트랜잭션이 동일하게 완료 될 가능성이 높습니다.
   연결이 시작된 연결 (예 : 요청,
   INVITE의 경우에는 2xx가 아닌 응답에 대한 ACK).
   이것은 일반적으로 적어도 64 * T1을 의미합니다 (섹션 17.1.1.1 참조).
   T1의 정의). 그러나 요소에서 더 클 수 있습니다.
   타이머 C에 큰 값을 사용하는 TU를가집니다 (16.6 절의 11 번 글 머리 기호).
   예를 들면.

   모든 SIP 요소는 UDP와 TCP를 구현해야합니다 (MUST). SIP 요소 MAY
   다른 프로토콜을 구현하십시오.

      UA를 위해 TCP를 필수로 만드는 것은 RFC에서 상당한 변화입니다
      더 큰 메시지를 다룰 필요가 없어졌으며,
      TCP는 반드시 사용해야한다. 따라서, 엘리먼트
      결코 큰 메시지를 보내지 않으면 메시지를 수신 할 수 있습니다.
      그들을 처리 할 수 ​​있습니다.

18.1 클라이언트

18.1.1 요청 보내기

   전송 계층의 클라이언트 측은
   요청을 보내고 응답을 받는다. 전송 계층의 사용자
   클라이언트가 요청, IP 주소, 포트,
   전송, 멀티 캐스트 대상의 TTL 등이 있습니다.

   요청이 경로 MTU의 200 바이트 내에 있거나 더 큰 경우
   1300 바이트 이상이고 경로 MTU를 알 수없는 경우 요청을 보내야합니다 (MUST).
   RFC 2914 [43] 혼잡 제어 전송 프로토콜을 사용하여
   TCP로. 이것이 전송 프로토콜의 변경을
   하나는 상단 비아에 표시되고, 상단 비아에는 반드시 있어야합니다.
   변경되었습니다. 이렇게하면 UDP를 통한 메시지 단편화를 방지하고
   큰 메시지에 대해 혼잡 제어를 제공합니다. 하나,
   구현은 최대까지 메시지를 처리 ​​할 수 ​​있어야합니다 (MUST).
   데이터 그램 패킷 크기. UDP의 경우이 크기는 65,535 바이트입니다.
   IP 및 UDP 헤더.

      메시지 크기와 MTU 사이의 200 바이트 "버퍼"
      SIP에서의 응답이
      요청. 이것은 Record-Route가 추가되어 발생합니다
      헤더 필드 값을 INVITE에 대한 응답으로 설정합니다. 와
      여분의 버퍼, 응답은 약 170 바이트보다 클 수 있습니다
      그 요청은 아직 IPv4에서 단편화되지 않습니다 (약 30 바이트



Rosenberg, et. al. 표준 트랙 [쪽 142]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      IPSec이 없다고 가정하면 IP / UDP에 의해 소비됩니다). 1300은
      1500 바이트의 가정에 기반하여 경로 MTU를 알 수 없음
      이더넷 MTU.

   요소가 이러한 메시지 크기로 인해 TCP를 통해 요청을 보내는 경우
   제약 조건을 가지며 그 요청은 다른 방법으로 전송되었을 것입니다
   UDP 연결을 설정하려는 시도가
   ICMP 프로토콜이 지원되지 않거나 TCP 리셋을 초래하는 요소
   UDP를 사용하여 요청을 재 시도해야합니다. 이것은 단지 제공하는 것입니다.
   RFC 2543 호환 구현과의 하위 호환성
   TCP를 지원하지 않습니다. 이 행동은
   이 사양의 향후 개정에서는 더 이상 사용되지 않습니다.

   멀티 캐스트 주소에 요청을 보내는 클라이언트는
   "maddr"매개 변수가 Via 헤더 필드 값에 포함됩니다.
   목적지 멀티 캐스트 주소를, IPv4의 경우, "ttl"
   매개 변수 값은 1입니다. IPv6 멀티 캐스트 사용은 정의되지 않았습니다.
   이 명세에서 미래의 주제가 될 것이다.
   필요시 표준화.

   이러한 규칙은 SIP의 멀티 캐스트를 목적으로 제한합니다.
   그것의 1 차적인 기능은 "single-hop-discovery-like"
   서비스를 제공하고 동종 서버 그룹에 요청을 전달하며,
   다음 중 하나의 응답 만 처리하면됩니다.
   그들. 이 기능은 등록에 가장 유용합니다. 사실로,
   17.1.3 절의 트랜잭션 처리 규칙에 따라
   클라이언트 트랜잭션은 첫 번째 응답을 수락하고
   모두가 동일한 Via를 포함하기 때문에 재전송으로 다른 것
   분기 식별자.

   요청이 전송되기 전에 클라이언트 전송은 다음 값을 삽입해야합니다.
   "보낸 사람"필드를 통해 Via 헤더 필드에 추가합니다. 이 필드에는 다음이 포함됩니다.
   IP 주소 또는 호스트 이름 및 포트 FQDN의 사용법은 다음과 같습니다.
   권장 사항. 이 입력란은 특정 조건에서 응답을 보내는 데 사용됩니다.
   조건들. 포트가 없으면 기본값
   값은 전송에 따라 다릅니다. UDP, TCP, SCTP는 5060이고,
   TLS는 5061입니다.

   신뢰할 수있는 전송의 경우 응답은 일반적으로
   요청을 수신 한 연결. 따라서 클라이언트
   전송은 동일한 응답을 수신 할 준비가되어 있어야합니다 (MUST).
   연결 요청을 보내는 데 사용됩니다. 오류 조건에서
   서버는 새 연결을 열어 응답을 보내려고 시도 할 수 있습니다. 에
   이 경우를 처리 할 때 전송 계층은
   소스 IP 주소에서 들어오는 연결을 수신합니다.
   요청은 "보낸 사람"필드에 보내지고 포트 번호는 보내집니다. 또한





Rosenberg, et. al. 표준 트랙 [143 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   모든 주소에서 들어오는 연결을받을 준비가되어 있어야합니다.
   절차에 따라 서버가 선택하는 포트
   [4]의 섹션 5에 설명되어 있습니다.

   신뢰할 수없는 유니 캐스트 전송의 경우 클라이언트 전송은
   소스 IP 주소에서 응답을받을 준비가되었습니다.
   요청이 전송됩니다 (응답이 소스 주소로 다시 전송 됨)
   및 "보낸 사람"필드의 포트 번호. 또한,
   신뢰할 수있는 운송 수단, 경우에 따라 응답이 보내질 것입니다.
   다른 곳에서. 클라이언트는 모든 응답을 수신 할 준비가되어 있어야합니다 (MUST).
   서버에 의해 선택된 주소 및 포트
   [4]의 섹션 5에 설명 된 절차.

   멀티 캐스트의 경우 클라이언트 전송은 수신 준비가되어야합니다
   요청과 동일한 멀티 캐스트 그룹 및 포트에 대한 응답
   전송됩니다 (즉, 멀티 캐스트 그룹의 구성원이어야 함)
   님에게 요청을 보냈습니다.)

   요청이 IP 주소, 포트,
 및에 수송
   기존 연결이 열려있는 경우, 다음과 같이 권장됩니다.
   연결은 요청을 보내는 데 사용되지만 다른 연결은 요청을 보낼 수 있습니다
   개봉 및 사용.

   요청이 멀티 캐스트를 사용하여 전송되면 그룹에 전송됩니다.
   주소, 포트 및 전송 사용자가 제공 한 TTL. 요청이있는 경우
   유니 캐스트 비 신뢰 전송을 사용하여 전송되면 IP로 전송됩니다
   주소 및 전송 사용자가 제공 한 포트.

18.1.2 응답 받기

   응답이 수신되면 클라이언트 전송은 맨 위를 검사합니다
   헤더 필드 값을 통해. "보낸 사람"매개 변수의 값이
   해당 헤더 필드 값이
   클라이언트 전송은 요청에 삽입하도록 구성됩니다.
   반드시 버려야합니다.

   존재하는 클라이언트 트랜잭션이있는 경우 클라이언트
   전송은 17.1.3 절의 일치 절차를 사용하여
   기존 트랜잭션에 대한 응답을 일치시킵니다. 있을 경우
   일치하는 경우 응답을 해당 트랜잭션으로 전달해야합니다 (MUST). 그렇지 않으면,
   응답은 코어에 전달되어야합니다 (상태 비 저장 여부).
   프록시, 스테이트 풀 프록시 또는 UA)를 사용합니다. 취급
   이러한 "이탈"응답은 핵심에 달려 있습니다 (프록시 의지
   예를 들어 UA가 삭제하는 동안 전달할 수 있습니다.







Rosenberg, et. al. 표준 트랙 [쪽 144]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


18.2 서버

18.2.1 요청 수신

   서버는 모든 IP 주소에서 요청을 수신 할 준비가되어 있어야하며,
   DNS 조회의 결과가 될 수있는 포트 및 전송 조합
   SIP 또는 SIPS URI [4]에서
   해당 서버와 통신합니다. 이 문맥에서, "전달"
   REGISTER의 Contact 헤더 필드에 URI 배치
   요청 또는 리다이렉트 응답에서, 또는 Record-Route 헤더 필드에서
   요청 또는 응답. URI는 URI를 배치하여 "전달"할 수도 있습니다.
   웹 페이지 또는 비즈니스 카드에. 또한 서버가
   기본 SIP 포트 (TCP 및 UDP의 경우 5060,
   모든 공용 인터페이스에서 TCP를 통한 TLS의 경우 5061). 전형적인
   예외는 사설 네트워크이거나 여러 서버
   인스턴스가 동일한 호스트에서 실행 중입니다. 모든 포트 및 인터페이스
   서버가 UDP를 청취 할 때 반드시 동일한 포트에서 수신 대기해야합니다
   및 TCP 인터페이스. 메시지를 보내야 할 수도 있기 때문입니다.
   UDP가 아닌 TCP를 사용하십시오. 결과적으로,
   반대는 사실이 아닙니다. 서버는 서버에서 UDP를 수신 할 필요가 없습니다.
   특정 주소와 포트가 수신 대기 중이므로
   TCP의 주소와 포트. 물론 다른 이유가있을 수 있습니다.
   서버는 특정 주소와 포트에서 UDP를 수신 대기해야합니다.

   서버 전송이 모든 전송을 통해 요청을 받으면
   상단 Via에서 "보낸 사람"매개 변수의 값을 검사해야합니다.
   헤더 필드 값. "보낸 사람"매개 변수의 호스트 부분
   도메인 이름을 포함하거나 IP 주소가 다른 경우
   패킷 소스 주소에서 서버는 "수신 된"
   파라미터를 그 ​​Via 헤더 필드 값에 적용한다. 이 매개 변수는 반드시
   패킷을 수신 한 소스 주소를 포함합니다. 이
   서버 전송 계층이 응답을 전송할 때 도움을 주며,
   요청을 보낸 원본 IP 주소로 보내야하기 때문에
   왔어.

   서버 전송에 의해 수신 된 요청을 고려해보십시오.
   일부:

      INVITE SIP : bob@Biloxi.com SIP / 2.0
      Via : SIP / 2.0 / UDP bobspc.biloxi.com:5060

   요청은 192.0.2.4의 원본 IP 주소로 수신됩니다.
   요청을 전달하기 전에 전송은 "수신 된"
   매개 변수를 사용하여 요청이 다음과 같이 보일 것입니다.

      INVITE SIP : bob@Biloxi.com SIP / 2.0
      경유 : SIP / 2.0 / UDP bobspc.biloxi.com:5060;received=192.0.2.4




Rosenberg, et. al. 표준 트랙 [145 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   그런 다음 서버 전송은 요청을 서버와 일치 시키려고 시도합니다.
   트랜잭션. 이는 다음에서 설명하는 일치 규칙을 사용하여 수행됩니다.
   17.2.3 절. 일치하는 서버 트랜잭션이 발견되면
   요청은 처리를 위해 해당 트랜잭션으로 전달됩니다. 일치하는 항목이없는 경우
   찾으면 요청이 코어로 전달되고
   해당 요청에 대한 새 서버 트랜잭션을 작성하십시오. 언제
   UAS 코어가 INVITE에 2xx 응답을 보내면 서버 트랜잭션은
   의해 파괴됨. 즉, ACK가 도착하면
   매칭 서버 트랜잭션을 생성하고,이 규칙에 기반하여, ACK는
   처리 된 UAS 코어로 전달됩니다.

18.2.2 응답 보내기

   서버 전송은 다음과 같은 Via 헤더 필드의 값을 사용합니다.
   응답을 보낼 위치를 결정하십시오. 반드시 따라야한다.
   다음 프로세스 :

      o "전송 된 프로토콜"이 다음과 같은 신뢰할 수있는 전송 프로토콜 인 경우
         TCP 또는 SCTP 또는 TLS를 사용하는 경우 응답은 다음을 사용하여 보내야합니다.
         최초의 요구의 소스에의 기존의 접속
         해당 연결이 아직 열려 있으면 트랜잭션을 생성 한
         이를 위해서는 서버 전송이 연결을 유지해야합니다.
         서버 트랜잭션과 전송 연결 사이. 그거면
         연결이 더 이상 열려 있지 않으면 서버는 다음 중 하나를 열어야합니다.
         "received"매개 변수의 IP 주소에 대한 연결, if
         현재, "보낸 사람"값의 포트를 사용하거나 기본값
         포트가 지정되어 있지 않은 경우 해당 전송에 대한 포트. 그거면
         연결 시도가 실패하면 서버는 절차를 사용해야합니다
         IP 주소를 결정하기 위해 서버에서 [4]를
         포트를 사용하여 연결을 열고 응답을 보냅니다.

      그렇지 않으면, Via 헤더 필드 값에 "maddr"
         매개 변수의 경우 응답을 나열된 주소로 전달해야합니다 (MUST).
         "보낸 사람"또는 포트 5060에 표시된 포트를 사용하여
         아무도 없다. 주소가 멀티 캐스트 주소 인 경우
         응답은 "ttl"필드에 표시된 TTL을 사용하여 전송되어야한다 (SHOULD)
         매개 변수가 없으면 TTL을 1로 설정하십시오.

      o 그렇지 않으면 (신뢰할 수없는 유니 캐스트 전송의 경우), 상위 Via
         "수신 된"매개 변수가 있으면 응답을
         지정된 포트를 사용하여 "received"매개 변수의 주소
         "보낸 사람"값으로 지정하거나 지정되지 않은 경우 포트 5060 사용
         명시 적으로. 이것이 실패 할 경우, 예를 들어, ICMP "포트
         도달 할 수없는 "응답, [5] 절의 절차
         응답을 보낼 곳을 결정할 때 사용해야한다.






Rosenberg, et. al. 표준 트랙 [Page 146]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      그렇지 않으면 수신자 태그가 없다면 응답은 반드시
         "보낸 사람"값이 나타내는 주소로
         [5]의 섹션 5의 절차.

18.3 프레이밍

   메시지 지향 전송 (예 : UDP)의 경우,
   메시지에 Content-Length 헤더 필드가 있으면 메시지 본문은 다음과 같습니다.
   그 많은 바이트를 포함한다고 가정합니다. 추가 바이트가있는 경우
   몸체의 끝을 넘어서는 전송 패킷, 그들은 반드시 있어야한다.
   버려진. 전송 패킷이 끝나기 전에 끝나면
   메시지 본문에서 오류로 간주됩니다. 메시지가
   응답을 보내면 반드시 폐기해야합니다. 메시지가 요청 인 경우
   요소는 400 (불량 요청) 응답을 생성해야한다 (SHOULD). 메시지가
   Content-Length 헤더 필드가 없으면 메시지 본문은 다음과 같이 가정됩니다.
   전송 패킷의 끝에서 끝납니다.

   TCP와 같은 스트림 지향 전송의 경우, Content-
   길이 헤더 필드는 본문의 크기를 나타냅니다. 콘텐츠 -
   Length 헤더 필드는 스트림 지향 전송과 함께 사용해야합니다 (MUST).

18.4 에러 처리

   오류 처리는 메시지가 요청인지 또는
   응답.

   전송 사용자가 메시지를 보내도록 요청한 경우
   신뢰할 수없는 전송 및 결과 ICMP 오류, 동작
   ICMP 오류의 유형에 따라 다릅니다. 호스트, 네트워크, 포트 또는 프로토콜
   도달 할 수없는 오류 또는 매개 변수 문제가 발생하면 오류가 발생해야합니다.
   전송 계층에 전송 실패를 알립니다.
   소스 퀀치 (source quench) 및 TTL 초과 된 ICMP 오류는 무시되어야한다 (SHOULD).

   전송 사용자가 요청을 신뢰할 수있는 서버를 통해 보내도록 요청한 경우
   전송, 결과가 연결 실패 인 경우 전송
   계층은 전송 사용자에게 전송 실패를 알려야합니다 (SHOULD).

19 공통 메시지 구성 요소

   다양한 형태로 나타나는 SIP 메시지의 특정 구성 요소가 있습니다.
   SIP 메시지 내의 장소 (때로는 외부)
   별도의 토론을 할 가치가있다.









Rosenberg, et. al. 표준 트랙 [Page 147]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


19.1 SIP 및 SIPS 통일 자원 표시기

   SIP 또는 SIPS URI는 통신 자원을 식별합니다. 모두처럼
   URI, SIP 및 SIPS URI는 웹 페이지, 전자 메일 메시지,
   또는 인쇄 된 문학. 그들은 충분한 정보를 담고 있습니다.
   자원과의 통신 세션을 개시하고 유지한다.

   통신 자원의 예는 다음과 같습니다.

      o 온라인 서비스 사용자

      o 다중 회선 전화상의 모양

      메시징 시스템의 사서함

      o 게이트웨이 서비스에서 PSTN 번호

      조직의 그룹 (예 : "판매"또는 "헬프 데스크")

   SIPS URI는 리소스가 안전하게 연락되도록 지정합니다. 이
   특히 TLS가 UAC와 UAC간에 사용된다는 것을 의미합니다.
   URI를 소유하고있는 도메인. 여기에서 보안 통신이 사용됩니다.
   특정 보안 메커니즘이 의존하는 사용자에게 접근
   도메인의 정책. SIP URI에 의해 기술 된 자원은
   스킴을 변경하여 SIPS URI로 "업그레이드"했습니다.
   해당 리소스와 안전하게 통신하기를 원합니다.

19.1.1 SIP 및 SIPS URI 구성 요소

   "sip :"및 "sips :"체계는 RFC 2396 [5]의 지침을 따릅니다.
   이들은 mailto URL과 비슷한 형식을 사용하여 사양을 허용합니다.
   SIP 요청 - 헤더 필드 및 SIP 메시지 - 바디를 포함한다. 이것은 그것을 만든다.
   제목, 미디어 유형 또는 긴급 세션 지정 가능
   웹 페이지의 URI 또는 ​​전자 메일 메시지를 사용하여 시작됩니다. 그만큼
   SIP 또는 SIPS URI에 대한 공식적인 구문은 섹션 25에 나와 있습니다.
   일반 양식 (SIP URI의 경우)은 다음과 같습니다.

      sip : user : password @ host : port; uri-parameters? headers

   SIPS URI의 형식은 스키마가
   "sip"대신 sip을 사용합니다. 이 토큰과 토큰 중 일부는
   확장은 다음과 같은 의미를 갖는다 :

      user : 호스트에있는 특정 자원의 식별자
         해결되었습니다. 이 문맥에서 "호스트"라는 용어는 흔히
         도메인으로 URI의 "userinfo"는이 사용자로 구성됩니다.
         필드, 암호 필드 및 그 뒤에 오는 @ 기호가 있습니다. 그만큼
         URI의 userinfo 부분은 선택 사항이며,



Rosenberg, et. al. 표준 트랙 [Page 148]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         대상 호스트에는 사용자 개념이 없거나
         호스트 자체는 식별되는 자원입니다. @ 기호가
         SIP 또는 SIPS URI에있는 사용자 필드는 비어서는 안됩니다.

         주소가 지정된 호스트가 전화 번호를 처리 할 수있는 경우
         인스턴스, 인터넷 전화 게이트웨이, 전화기 -
         RFC 2806 [9]에 정의 된 가입자 필드는
         사용자 필드를 채 웁니다. 에 대한 특별한 이스케이프 규칙이 있습니다.
         SIP 및 SIPS URI의 전화 - 가입자 필드 인코딩
         19.1.2 절에서 설명합니다.

      암호 : 사용자와 관련된 암호입니다. SIP 및
         SIPS URI 구문을 사용하면이 필드를 사용할 수 있으며 사용법은 NOT
         인증 정보가 전달되기 때문에 권장 됨
         일반 텍스트 (예 : URI)가 보안 위험이 있음이 입증되었습니다.
         거의 모든 경우에 사용되었습니다. 예를 들어,
         이 필드에서 PIN 번호를 전송하면 PIN이 노출됩니다.

         비밀번호 필드는 사용자의 확장 일뿐입니다.
         일부. 특별한 것을주고 싶지 않은 구현들
         필드의 암호 부분에 대한 중요성은 단순히
         "user : password"를 단일 문자열로 취급하십시오.

      호스트 : SIP 리소스를 제공하는 호스트. 호스트 부분은 다음을 포함합니다.
         정규화 된 도메인 이름 또는 숫자로 된 IPv4 또는 IPv6
         주소. 완전한 도메인 이름 양식 사용하기
         가능할 때마다 권장됩니다.

      port : 요청을 보낼 포트 번호.

      URI 매개 변수 :에서 생성 된 요청에 영향을주는 매개 변수
         URI.

         URI 매개 변수는 hostport 구성 요소 다음에 추가됩니다.
         세미콜론으로 구분.

         URI 매개 변수는 다음 형식을 취합니다.

            매개 변수 이름 "="매개 변수 값

         임의의 수의 URI 매개 변수가
         URI에 포함 된 경우, 주어진 매개 변수 이름은 나타나지 않아야합니다
         두 번 이상.

         이 확장 가능한 메커니즘에는 전송, maddr, ttl,
         사용자, 메소드 및 lr 매개 변수





Rosenberg, et. al. 표준 트랙 [Page 149]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         전송 매개 변수는 전송 메커니즘을 다음과 같이 결정합니다.
         [4]에서 지정된대로 SIP 메시지를 보내는 데 사용됩니다. SIP 수 있습니다.
         모든 네트워크 전송 프로토콜을 사용하십시오. 매개 변수 이름은
         UDP (RFC 768 [14]), TCP (RFC 761 [15]) 및 SCTP
         (RFC 2960 [16]). SIPS URI의 경우, 전송 매개 변수는 반드시 MUST
         신뢰할 수있는 운송 수단임을 나타냅니다.

         maddr 매개 변수는 서버 주소를 나타냅니다.
         이 사용자와 연락하여 파생 된 주소를 무시합니다.
         호스트 필드 maddr 매개 변수가 있으면 포트
         URI의 전송 구성 요소가 주소에 적용됩니다.
         maddr 매개 변수 값에 표시됩니다. [4]는
         전송, maddr 및 호스트 포트의 적절한 해석
         대상 주소, 포트 및 전송을 얻기위한 주문
         요청을 보내기 위해.

         maddr 필드는 간단한 소스 형태로 사용되었습니다.
         라우팅. URI가 있어야만하는 프록시를 지정할 수 있습니다.
         목적지로가는 도중에 지나간다. 계속해서
         이 방법으로 maddr 매개 변수를 사용하면
         그것을 가능하게하는 메커니즘). 구현
         대신에 설명 된 Route 메커니즘을 사용해야합니다.
         문서, 필요한 경우 기존 경로 설정
         (8.1.1.1 절 참조). 이는 설명 할 전체 URI를 제공합니다.
         횡단 할 노드

         ttl 매개 변수는 UDP의 유효 기간 값을 결정합니다
         멀티 캐스트 패킷이며 maddr이 멀티 캐스트 인 경우에만 사용해야합니다.
         주소이고 전송 프로토콜은 UDP입니다. 예를 들어, ~에
         멀티 캐스트를 사용하여 alice@atlanta.com에 대한 호출을 지정하십시오.
         239.255.255.1이고 ttl이 15 인 경우 다음 URI는
         익숙한:

            sip : alice@atlanta.com; maddr = 239.255.255.1; ttl = 15

         유효한 전화 가입자 스트링의 집합은
         유효한 사용자 문자열 사용자 URI 매개 변수는 다음에 존재합니다.
         일어난 사용자 이름과 전화 번호 구분
         전화 번호처럼 보입니다. 사용자 문자열에
         전화 가입자로 포맷 된 전화 번호, 사용자
         매개 변수 값 "phone"이 있어야합니다. 이것이 없어도
         매개 변수를 사용하면 SIP 및 SIPS URI의 수신자는
         전화 번호로 지역 번호가
         사용자 이름에 대한 이름 공간을 허용하십시오.

         URI로부터 생성 된 SIP 요청의 방법은
         method 매개 변수로 지정됩니다.




Rosenberg, et. al. 표준 트랙 [쪽 150]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         lr 매개 변수가 있으면 해당 요소가
         이 자원에 대한 책임은 라우팅 메커니즘을 구현합니다.
         이 문서에 명시되어 있습니다. 이 매개 변수는
         URI 프록시는 Record-Route 헤더 필드 값에 배치됩니다.
         기존 경로 집합의 URI에 나타날 수 있습니다.

         이 매개 변수는 이전 버전과의 호환성을 유지하는 데 사용됩니다.
         RFC 2543의 엄격한 라우팅 메커니즘을 구현하는 시스템
         rfc2543bis는 bis-05까지 초안을 작성합니다. 요소 준비
         이 매개 변수를 포함하지 않는 URI를 기반으로 요청을 보내려면
         수신 요소가 엄격한 라우팅을 구현한다고 가정 할 수 있으며
         정보를 보존하기 위해 메시지를 다시 포맷하십시오.
         요청 URI.

         URI 매개 변수 메커니즘이 확장 가능하기 때문에 SIP 요소
         반드시 그렇지 않은 URI 매개 변수를 자동으로 무시해야합니다.
         알다.

      헤더 : 생성 된 요청에 포함될 헤더 필드
         URI에서.

         SIP 요청의 헤더 필드는 "?"
         메커니즘. 헤더 이름과 값은 다음과 같습니다.
         앰퍼샌드로 구분 된 hname = hvalue 쌍으로 인코딩됩니다. 그만큼
         특수 hname "본문"은 연결된 hvalue가
         SIP 요청의 메시지 본문

   표 1은 SIP 및 SIPS URI 구성 요소의 사용을 요약 한 것입니다.
   URI가 표시되는 컨텍스트 외부 열은
   SIP 메시지 외부의 임의의 위치에 나타나는 URI입니다 (예 :
   웹 페이지 또는 명함. "m"이라고 표시된 항목은 필수 항목입니다.
   "o"표시는 선택 사항이며 "-"표시는 허용되지 않습니다.
   URI를 처리하는 요소는 허용되지 않는 구성 요소를 무시해야합니다.
   그들은 존재한다. 두 번째 열은 기본값을 나타냅니다.
   선택 요소 (존재하지 않는 경우). "-"는
   요소가 선택 사항이 아니거나 기본값이 없습니다.

   연락처 헤더 필드의 URI는
   머리글 필드가 나타나는 컨텍스트에서. 한 세트가에 적용됩니다
   대화를 설정하고 유지하는 메시지 (INVITE 및 200 (OK)
   응답). 다른 하나는 등록 및 리디렉션에 적용됩니다.
   메시지 (REGISTER, 200 (OK) 응답 및 3xx 클래스 응답)
   모든 방법).








Rosenberg, et. al. 표준 트랙 [151 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


19.1.2 문자 이스케이프 요구 사항

                                                       대화
                                          reg./redir. 접촉/
              Default Req-URI To Contact R-R / Route 외부 연락처
사용자 - o o o o o o
패스워드 - o o o o o o
호스트 - m m m m m m
항구 (1) o - - o o o
user-param ip o o o o o o
메소드 INVITE - - - - - - o
maddr-param - o - - o o o
ttl-param 1 o - - o - o
transp.-param (2) o - - o o o
lr-param - o - - - o o
other-param - o o o o o o
헤더 - - - - o - o

   (1) : 기본 포트 값은 전송 및 구성표에 따라 다릅니다. 그만큼
   UDP, TCP 또는 SCTP를 사용하는 sip의 경우 기본값은 5060입니다. 기본값은
   5061 for sip : TLS over TCP 및 SIP 사용 : TCP를 통해.

   (2) : 기본 전송은 체계에 따라 다릅니다. SIP의 경우 : UDP입니다.
   SIP의 경우 : TCP입니다.

   표 1 : SIP 헤더의 URI 구성 요소 사용 및 기본값
   필드 값, Request-URI 및 참조

   SIP는 RFC 2396 [5]의 요구 사항과 지침을 따릅니다.
   SIP URI에서 이스케이프해야하는 문자 세트 정의
   이스케이프를 위해 % "HEX HEX"메커니즘을 사용합니다. RFC 2396 [5] :

      지정된 URI 내에서 실제로 예약 된 문자 집합입니다.
      구성 요소는 해당 구성 요소에 의해 정의됩니다. 일반적으로 문자
      문자의 경우 URI의 의미가 변경되면 예약됩니다.
      이스케이프 된 US-ASCII 인코딩 [5]으로 대체됩니다. 제외 된 US-
      공간 및 제어와 같은 ASCII 문자 (RFC 2396 [5])
      URI 구분 기호로 사용되는 문자 및 문자도 반드시 사용해야합니다.
      탈출했다. URI는 이스케이프되지 않은 공간과 제어를 포함해서는 안됩니다
      문자.

   각 구성 요소에 대해 유효한 BNF 확장 세트는 정확하게 정의됩니다
   어떤 문자가 이스케이프 처리되지 않은 문자로 나타날 수 있습니다. 다른 모든 문자는 반드시
   탈출했다.

   예를 들어 "@"은 사용자의 문자 집합에 없습니다.
   컴포넌트이기 때문에 사용자 "j @ s0n"은 최소한 @ 기호를 인코딩해야하며,
   "j % 40s0n"과 같습니다.



Rosenberg, et. al. 표준 트랙 [154 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   25 절에서 hname과 hvalue 토큰을 확장하면 모든 URI
   헤더 필드 이름과 값의 예약 문자는 이스케이프되어야합니다 (MUST).

   사용자 구성 요소의 전화 가입자 서브 세트는 특별
   탈출 고려 사항. 에 예약되지 않은 문자 집합
   RFC 2806 [9] 전화 가입자에 대한 설명은
   이스케이프 할 때 필요한 다양한 구문 요소의 문자
   SIP URI에 사용됩니다. 전화 가입자에서 발생하는 모든 문자
   사용자 규칙에 대한 BNF의 확장에 나타나지 않는
   도망 가라.

   호스트 구성 요소에는 문자 이스케이프가 허용되지 않습니다.
   SIP 또는 SIPS URI (% 문자는 확장시 유효하지 않습니다).
   앞으로는이 요구 사항이 변경 될 가능성이 있습니다.
   국제화 된 도메인 이름이 최종 확정됩니다. 흐름
   구현은 치료로 견고성을 향상 시키려 시도해서는 안된다
   문자 그대로 호스트 구성 요소에서 이스케이프 된 문자를 수신했습니다.
   그들의 이스케이프 처리되지 않은 대응 항목과 같습니다. 필요한 행동
   IDN의 요구 사항을 충족하는 것은 상당히 다를 수 있습니다.

19.1.3 SIP 및 SIPS URI의 예

   한모금 : alice@atlanta.com
   sip : alice : secretword@atlanta.com; 전송 = tcp
   sips : alice@atlanta.com? subject = 프로젝트 % 20x 및 우선 순위 = 긴급
   한모금 : + 1-212-555-1212 : 1234@gateway.com; 사용자 = 전화
   모금 : 1212@gateway.com
   한모금 : alice@192.0.2.4
   한모금 : atlanta.com; method = REGISTER? to = alice % 40atlanta.com
   한모금 : alice; day=tuesday@atlanta.com

   위의 마지막 샘플 URI는 사용자 필드 값이입니다.
   "alice; day = tuesday". 위에 정의 된 이스케이프 규칙은
   세미콜론은 이스케이프 처리되지 않은이 필드에 나타납니다. 목적 상
   이 프로토콜은 필드가 불투명합니다. 그 값의 구조는 다음과 같습니다.
   리소스를 담당하는 SIP 요소에만 유용합니다.

19.1.4 URI 비교

   이 명세의 일부 동작은 두 개의
   SIP 또는 SIPS URI는 동등합니다. 이 명세에서, 등록 기관
   REGISTER 요청에서 Contact URI의 바인딩을 비교해야합니다 (
   섹션 10.3.). SIP와 SIPS URI가 동일한 지 비교
   다음 규칙에 따라

      o SIP와 SIPS URI는 절대로 동일하지 않습니다.





Rosenberg, et. al. 표준 트랙 [153 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      o SIP 및 SIPS URI의 사용자 정보 비교는 대소 문자를 구별합니다.
         민감한. 여기에는 암호가 포함 된 userinfo 또는
         전화 가입자로 형식이 지정됩니다. 다른 모든 것의 비교
         URI의 구성 요소는 명시 적으로
         다르게 정의됩니다.

      o 매개 변수와 헤더 필드의 순서가 중요하지 않습니다.
         SIP와 SIPS URI를 비교할 때.

      o "예약 된"세트에있는 문자 이외의 문자 (RFC 2396 참조)
         [5])는 % "HEX HEX"인코딩과 동일합니다.

      o 호스트 이름의 DNS 검색의 결과 인 IP 주소
         해당 호스트 이름과 일치하지 않습니다.

      o 두 개의 URI가 같으면 사용자, 암호, 호스트 및 포트
         구성 요소가 일치해야합니다.

         사용자 구성 요소를 생략 한 URI는
         하나 포함. 암호 구성 요소를 생략 한 URI는
         URI를 포함하는 URI를 찾습니다.

         기본값이있는 구성 요소를 생략하는 URI는
         그 컴퍼넌트를 명시 적으로 포함하고있는 URI와 그 URI를 매치합니다.
         기본값. 예를 들어, 선택적 포트를 생략 한 URI
         구성 요소는 포트 5060을 명시 적으로 선언하는 URI와 일치하지 않습니다.
         전송 매개 변수, ttl 매개 변수에 대해서도 마찬가지입니다.
         사용자 매개 변수 및 메소드 구성 요소가 포함됩니다.

            sip : user @ host를 정의하는 것은 다음과 같습니다.
            sip : user @ host : 5060은 RFC 2543의 변경 사항입니다.
            URI에서 가져온 주소는 다음과 같습니다.
            동등한 URI. URI sip : user @ host : 5060은 항상
            포트 5060으로 해결하십시오. URI sip : user @ host는 다음과 같이 해결할 수 있습니다.
            [4]에 설명 된 DNS SRV 메커니즘을 통한 다른 포트.

      URI URI 매개 변수 구성 요소는 다음과 같이 비교됩니다.

         - 두 URI에 나타나는 모든 URI 매개 변수가 일치해야합니다.

         - 사용자, ttl 또는 메소드 URI 매개 변수가 하나만에 표시됩니다.
            URI에 기본값이 포함되어 있어도 일치하지 않습니다.

         - maddr 매개 변수가 포함 된 URI는 URI와 일치하지 않습니다.
            maddr 매개 변수가 없습니다.

         - 하나의 URI에만 나타나는 다른 모든 URI 매개 변수는
            URI를 비교할 때 무시됩니다.



Rosenberg, et. al. 표준 트랙 [154 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      o URI 헤더 구성 요소가 무시되지 않습니다. 현재 헤더
         구성 요소는 두 URI에 모두 존재해야하며 URI와 일치해야합니다.
         일치시킵니다. 일치하는 규칙은 각 헤더 필드에 대해 정의됩니다.
         제 20 항.

   다음 각 세트 내의 URI는 동일합니다.

   sip : % 61lice@atlanta.com; 전송 = TCP
   sip : alice@AtLanTa.CoM; 전송 = tcp

   한모금 : carol@chicago.com
   한모금 : carol@chicago.com; newparam = 5
   한모금 : carol@chicago.com; security = on

   sip : biloxi.com; 전송 = tcp; method = REGISTER? to = sip : bob % 40biloxi.com
   sip : biloxi.com; method = REGISTER; 전송 = tcp? to = sip : bob % 40biloxi.com

   한모금 : alice@atlanta.com? 제목 = 프로젝트 % 20x 및 우선 순위 = 긴급
   한모금 : alice@atlanta.com? 우선 순위 = 긴급 & 제목 = 프로젝트 % 20x

   다음 각 세트 내의 URI는 동일하지 않습니다.

   SIP : ALICE@AtLanTa.CoM; 전송 = udp (다른 사용자 이름)
   한모금 : alice@AtLanTa.CoM; 전송 = UDP

   한모금 : bob@biloxi.com (다른 포트로 해결 가능)
   한모금 : bob@biloxi.com : 5060

   한모금 : bob@biloxi.com (다른 운송 수단으로도 해결할 수 있음)
   한모금 : bob@biloxi.com, 운송 = udp

   한모금 : bob@biloxi.com (다른 포트 및 전송으로 해결 가능)
   sip : bob@biloxi.com : 6000; 전송 = tcp

   한모금 : carol@chicago.com (다른 헤더 구성 요소)
   한모금 : carol@chicago.com? 제목 = 다음 % 20 회의

   한모금 : bob@phone21.boxesbybob.com (비록 이것이
   한모금 : bob@192.0.2.4 phone21.boxesbybob.com은 (는)

   평등은 전이 적이 지 않습니다.

      o sip : carol@chicago.com 및 sip : carol@chicago.com, 보안 = on
         동등한

      o sip : carol@chicago.com 및 sip : carol@chicago.com; 보안 = 꺼짐
         동등하다




Rosenberg, et. al. 표준 트랙 [쪽 155]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      o sip : carol@chicago.com, security = on 및
         한모금 : carol@chicago.com; 보안 = 꺼짐은 동일하지 않습니다.

19.1.5 URI로부터 요청 형성하기

   구현은 요청을 직접 형성 할 때주의를 기울여야합니다.
   URI에서. 명함, 웹 페이지 및 심지어 from의 URI
   등록 된 연락처와 같은 프로토콜 내부의 소스에는
   부적절한 헤더 필드 또는 본문 부분.

   구현시에는 제공된 모든 전송, maddr, ttl 또는
   생성 된 요청의 Request-URI에있는 사용자 매개 변수. URI
   메소드 매개 변수를 포함하고, 그 값을 메소드의 메소드로 사용해야합니다 (MUST).
   요청. method 매개 변수는
   요청 URI. 알 수없는 URI 매개 변수는 메시지의
   요청 URI.

   구현은 모든 헤더 나 본문의 존재를 처리해야합니다 (SHOULD).
   URI에 포함 된 부분을 메시지에 포함하려는 욕구로
   구성 요소별로 요청을 존중하도록 선택하십시오.

   구현시 이러한 명백하게 위험한 헤더를 존중해서는 안됩니다
   필드 : From, Call-ID, CSeq, Via 및 Record-Route.

   구현체는 요구 된 Route 헤더 필드를 존중해서는 안된다 (SHOULD NOT)
   악의적이지 않은 에이전트로 사용되지 않도록하기위한 값
   공격.

   구현체는 헤더 필드를 포함하는 요청을 받아 들여서는 안된다 (SHOULD NOT)
   광고 게재 위치 나 기능을 잘못 광고 할 수 있습니다.
   수락, 수락 - 인코딩, 수락 언어, 허용,
   연락처 (대화 상자 사용법에서), 조직, 지원 및 사용자 정의
   에이전트.

   구현체는 요구 된 것의 정확성을 검증해야한다.
   설명 형 헤더 필드 : Content-Disposition, Content-
   인코딩, 컨텐트 언어, 컨텐트 길이, 컨텐트 유형, 날짜,
   Mime-Version 및 Timestamp가 있습니다.

   주어진 URI로부터 메시지를 구성하여 형성된 요청이
   유효한 SIP 요청이 아니라면 URI가 유효하지 않습니다. 구현은 반드시
   요청을 전송하지 마십시오. 대신 추구해야한다.
   발생하는 컨텍스트에서 유효하지 않은 URI로 인한 조치 과정.

      생성 된 요청은 여러 가지면에서 유효하지 않을 수 있습니다. 이들
      여기에는 헤더 필드의 구문 오류,
      잘못된 URI 조합 또는 올바르지 않은 조합
      메시지 보의 설명

dy.



Rosenberg, et. al. 표준 트랙 [156 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   주어진 URI로부터 형성된 요청을 보내는 것은 능력을 요구할 수있다.
   구현에 사용할 수 없습니다. URI는
   구현되지 않은 전송 또는 확장, 예를 들어. 구현
   요청을 수정하지 말고 요청을 거부해야합니다.
   그들의 능력을 일치시킵니다. 구현시 요청을 보내면 안됩니다
   지원하지 않는 확장이 필요합니다.

      예를 들어, 이러한 요청은
      Require 헤더 매개 변수 또는 메서드 URI 매개 변수
      알 수 없거나 명시 적으로 지원되지 않는 값입니다.

19.1.6 관련 SIP URI와 tel URL

   tel URL (RFC 2806 [9])이 SIP 또는 SIPS URI로 변환되면
   tel URL의 전체 전화 - 가입자 부분.
   매개 변수는 SIP 또는 SIPS URI의 userinfo 부분에 배치됩니다.

   따라서 tel : + 358-555-1234567; postd = pp22가됩니다.

      sip : + 358-555-1234567; postd=pp22@foo.com; user = phone

   또는
      sips : + 358-555-1234567; postd=pp22@foo.com; user = phone

   아니
      sip : +358-555-1234567@foo.com; postd = pp22; user = 전화

   또는

      sips : +358-555-1234567@foo.com, postd = pp22, 사용자 = 전화

   일반적으로 SIP 또는 SIPS URI로 변환 된 동등한 "tel"URL은
   이 방식은 동등한 SIP 또는 SIPS URI를 생성하지 않을 수 있습니다. 그만큼
   SIP 및 SIPS URI의 userinfo는 대소 문자를 구분하여 비교됩니다.
   끈. Tel URL의 대소 문자를 구별하지 않는 부분의 차이 및
   tel URL 매개 변수를 재정렬해도 tel URL 동등성에 영향을 미치지 않으며,
   그것들로부터 형성된 SIP URI의 동등성에 영향을 미친다.

   예를 들어,

      tel : + 358-555-1234567; postd = pp22
      tel : + 358-555-1234567; POSTD = PP22

   동등한 반면,

      sip : + 358-555-1234567; postd=pp22@foo.com; user = phone
      sip : + 358-555-1234567; POSTD=PP22@foo.com; user = phone




Rosenberg, et. al. 표준 트랙 [157 쪽]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   그렇지 않다.

   마찬가지로,

      tel : + 358-555-1234567; postd = pp22; isub = 1411
      tel : + 358-555-1234567; isub = 1411; postd = pp22

   동등한 반면,

      sip : + 358-555-1234567; postd = pp22; isub=1411@foo.com; user = 전화
      sip : + 358-555-1234567; isub = 1411; postd=pp22@foo.com; 사용자 = 전화

   그렇지 않다.

   이 문제를 완화하기 위해 전화 가입자를 구성하는 요소
   SIP 또는 SIPS URI의 userinfo 부분에 배치 할 필드
   전화 가입자의 대소 문자를 구분하지 않는 부분을 소문자로,
   매개 변수에 의해 전화 가입자 매개 변수를 어휘 적으로 주문하십시오
   이름은 제외하고 isdn-subaddress와 post-dial을 제외하고 처음으로 발생합니다.
   그 순서대로. (향후 URL을 제외한 tel URL의 모든 구성 요소
   확장 매개 변수는 대 / 소문자를 구분하지 않도록 정의됩니다.

   이 제안에 따라,

      tel : + 358-555-1234567; postd = pp22
      tel : + 358-555-1234567; POSTD = PP22

      지다

        sip : + 358-555-1234567; postd=pp22@foo.com; user = phone

   둘 다

        tel : + 358-555-1234567; tsp = a.b; phone-context = 5
        tel : + 358-555-1234567, phone-context = 5, tsp = a.b

      지다

        sip : + 358-555-1234567; phone-context = 5; tsp=a.b@foo.com; user = phone

19.2 옵션 태그

   옵션 태그는 새 옵션을 지정하는 데 사용되는 고유 식별자입니다.
   (확장 기능). 이 태그는 Require (20.32 절),
   Proxy-Require (20.29 절), 지원 (20.37 절) 및
   지원되지 않는 (20.40 절) 헤더 필드 이 옵션들
   option-tag = 토큰의 헤더 필드에 매개 변수로 나타납니다.
   양식 (토큰의 정의에 대해서는 섹션 25 참조).



Rosenberg, et. al. 표준 트랙 [158 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   옵션 태그는 표준 트랙 RFC에 정의되어 있습니다. 이것은 변화이다.
   과거의 관행으로부터 시작하여,
   공급 업체 상호 운용성 (섹션 20.32 및 섹션
   20.37). 옵션 태그의 IANA 레지스트리는 쉽게 사용할 수 있도록하기 위해 사용됩니다.
   참고.

19.3 태그

   SIP의 To 및 From 헤더 필드에 "tag"매개 변수가 사용됩니다.
   메시지. 대화 상자를 식별하는 일반적인 메커니즘으로,
   두 개의 태그와 함께 Call-ID와 하나의
   각 참가자는 대화 상자에 있습니다. UA가 외부로 요청을 보내는 경우
   대화 상자에는 From 태그 만 포함되어 대화 상자의 "절반"을 제공합니다
   신분증. 대화 상자는 응답에서 완료되며 각각
   To 헤더 필드에 후반부를 제공합니다. 포크의
   SIP 요청은 여러 개의 대화 상자가
   단일 요청. 또한 양면 대화 상자의 필요성을 설명합니다.
   식별자; 수령인의 공헌없이
   발신자는 설정된 여러 대화 상자를 명확하게 할 수 없습니다.
   단일 요청에서.

   요청에 삽입하기 위해 UA가 태그를 생성하거나
   응답은 전 세계적으로 유일해야하고 암호 학적으로 무작위이어야한다.
   적어도 32 비트의 무작위로 이 선택의 속성
   요구 사항은 UA가 다른 태그를 From 태그에 배치한다는 것입니다.
   헤더의 To 헤더에 삽입 할 INVITE의 헤더
   동일한 INVITE에 대한 응답 이 작업은 UA가
   전화에 "헤어 피스 닝 (hairpinning)"하는 일반적인 경우 인 세션에 자신을 초대합니다.
   PSTN 게이트웨이에서 마찬가지로 여러 통화에 대한 두 명의 INVITE가
   다른 From 태그를 사용하고 다른 호출에 대한 두 가지 응답은
   다른 To 태그가 있습니다.

   글로벌 독창성에 대한 요구 외에도,
   태그 생성은 구현에 따라 다릅니다. 태그가 유용합니다
   폴트 톨러 런트 (fault tolerant) 시스템.
   실패 후 대체 서버. UAS는 이러한 태그에서 태그를 선택할 수 있습니다.
   백업이 대화 상자의 일부로 요청을 인식 할 수있는 방법
   실패한 서버이므로 시도해야한다고 결정합니다.
   대화 상자 및 이와 관련된 다른 모든 상태를 복구하십시오.

20 헤더 필드

   헤더 필드에 대한 일반적인 구문은 7.3 절에서 다룹니다. 이
   섹션에는 메모와 함께 전체 헤더 필드 집합이 나열됩니다.
   구문, 의미 및 사용법. 이 절에서 우리는 [HX.Y]
   현재의 HTTP / 1.1 사양 X.Y 절을 참조하십시오.
   2616 [8]. 각 헤더 필드의 예가 제공됩니다.




Rosenberg, et. al. 표준 트랙 [페이지 159]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   메소드와 프록시와 관련된 헤더 필드에 대한 정보
   처리는 표 2 및 표 3에 요약되어있다.

   "where"열은 요청 및 응답 유형을 설명합니다.
   헤더 필드를 사용할 수 있습니다. 이 열의 값은 다음과 같습니다.

      R : 헤더 필드는 요청에만 나타날 수 있습니다.

      r : 헤더 필드는 응답에만 나타날 수 있습니다.

      2xx, 4xx 등 : 숫자 값 또는 범위는 응답을 나타냅니다.
           헤더 필드가 사용될 수있는 코드;

      c : 헤더 필드가 요청에서 응답으로 복사됩니다.

      "where"열의 빈 항목은 헤더가
           필드는 모든 요청 및 응답에있을 수 있습니다.

   "프록시"열은 프록시가 프록시 서버에서 수행 할 수있는 작업을 설명합니다.
   헤더 필드 :

      a : 프록시가 없으면 헤더 필드를 추가하거나 연결할 수 있습니다.

      m : 프록시는 기존 헤더 필드 값을 수정할 수 있습니다.

      d : 프록시가 헤더 필드 값을 삭제할 수 있습니다.

      r : 프록시가 헤더 필드를 읽을 수 있어야하므로이
           헤더 필드는 암호화 될 수 없습니다.

   다음 6 개 열은 헤더 필드의 존재와 관련이 있습니다.
   방법:

      c : 조건부; 헤더 필드에 대한 요구 사항은
           메시지의 컨텍스트

      m : 헤더 필드는 필수 항목입니다.

      m * : 헤더 필드는 보내 져야하지만, 클라이언트 / 서버는
           헤더 필드없이 메시지를 수신 할 수 있도록 준비하십시오.

      o : 헤더 필드는 선택 사항입니다.

      t : 헤더 필드를 보내야하지만 클라이언트 / 서버가 있어야한다.
           헤더 필드없이 메시지를 수신 할 준비가되었습니다.

           스트림 기반 프로토콜 (예 : TCP)이
           전송할 때, 헤더 필드는 전송되어야한다.



Rosenberg, et. al. 표준 트랙 [Page 160]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      * : 메시지 본문이 비어 있지 않으면 헤더 필드가 필요합니다.
           자세한 내용은 20.14 절, 20.15 절 및 7.4 절을 참조하십시오.

      - : 헤더 필드는 적용 할 수 없습니다.

   "선택 사항"은 엘리먼트가 헤더 필드를
   요청 또는 응답을 포함 할 수 있으며, UA는 헤더 필드가 존재하면 그것을 무시할 수있다 (MAY)
   요청 또는 응답에서 (이 규칙에 대한 예외는 Require
   헤더 필드는 20.32에서 논의된다). "필수"헤더 필드는 반드시 있어야합니다 (MUST).
   요청서에 제시되어 있으며, 반드시 UAS에 의해 이해되어야한다.
   의뢰. 필수 응답 헤더 필드가 반드시 있어야합니다.
   응답 및 헤더 필드는 UAC에서 이해해야합니다
   응답을 처리합니다. "해당 없음"은 헤더가
   필드는 요청에 존재해서는 안됩니다. 하나가
   실수로 요청하면, UAS가이를 무시해야합니다.
   의뢰. 비슷하게, "적용 할 수 없음"으로 분류 된 헤더 필드는
   응답은 UAS가 헤더 필드를
   응답에서 UAC는 응답의 헤더 필드를 무시해야합니다 (MUST).

   UA는 확장 헤더 매개 변수를 무시해야한다.
   이해했다.

   일부 공통 헤더 필드 이름의 간략한 형식은
   전체 메시지 크기가 문제가 될 때 사용하십시오.

   Contact, From 및 To 헤더 필드에는 URI가 들어 있습니다. URI
   쉼표, 물음표 또는 세미콜론을 포함하는 경우 URI는 반드시
   꺽쇠 괄호 (<및>)로 묶습니다. 모든 URI 매개 변수는
   이 괄호 안에 들어 있습니다. URI가 앵글로 묶이지 않은 경우
   대괄호로 묶인 세미콜론으로 구분 된 매개 변수는 모두 헤더 매개 변수이며,
   URI 매개 변수가 아닙니다.

20.1 수락

   Accept 헤더 필드는 [H14.1]에 정의 된 구문을 따른다. 그만큼
   의미론도 동일하지만, 예외적으로 Accept
   헤더 필드가 존재하면, 서버는 디폴트 값으로 가정해야한다 (SHOULD).
   application / sdp.

   비어있는 Accept 헤더 필드는 받아 들일 수있는 형식이 없음을 의미합니다.











Rosenberg, et. al. 표준 트랙 [Page 161]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   예:

      헤더 필드에서 프록시 ACK BYE CAN INV OPT REG
      ___________________________________________________________
      수락 R - o - o m * o
      2xx 수령 - - - o m * o
      수락 415 - c - c c c
      동의 - 인코딩 R - o - o o o
      수락 - 인코딩 2xx - - - o m * o
      수락 - 인코딩 415 - c - c c c
      수락 언어 R - o - o o o
      수락 언어 2xx - - - o m * o
      수락 언어 415 - c - c c c
      Alert-Info R ar - - - o - -
      Alert-Info 180 ar - - - o - -
      Allow R - o - o o o
      2xx - o - m * m * o 허용
      r - o - o o o 허용
      허용 405 - m - m m m
      인증 정보 2xx - o - o o o
      승인 R o o o o o
      Call-ID c r m m m m m
      통화 정보 ar - - - o o o
      연락하기 : R o - - m o o
      연락처 1xx - - - o - -
      연락처 2xx - - - m o o
      연락처 3xx d - o - o o o
      연락처 485 - o - o o o
      내용 - 처분 o o o o o o
      콘텐츠 인코딩 o o - o o o
      콘텐츠 - 언어 o o - o o o
      내용 길이
      Content-Type * * - * * *
      CSeq c r m m m m m
      날짜 o o o o o o o
      오류 정보 300-699 a - o o o o o
      만료 - - - o - o
      ~부터 m m m m m까지
      In-Reply-To R - - - o - -
      최대 - 앞으로 R amr m m m m m m
      최소 만료 423 - - - - - m
      MIME-Version o o - o o o
      조직 ar - o - o o o

             표 2 : 헤더 필드 요약, A - O






Rosenberg, et. al. 표준은 궤 [220 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   헤더 필드에서 프록시 ACK BYE CAN INV OPT REG
   ___________________________________________________________________
   우선 순위 R ar - - - o - -
   프록시 - 인증 407 - m - m m m
   Proxy-Authenticate 401 ar-o o o o
   프록시 인증 R dr o o - o o o
   프록시 요구 R ar o o o o o
   기록 - 기록 R o o o o o -
   Record-Route 2xx, 18x mr - o o o o -
   답장 - - - - o - -
   ar - c - c c c 필요
   재시도 - 404,413,480,486 - o o o o o
                            500, 503 - o o o o o
                            600,603 - o o o o o
   경로 R adr c c c c c c
   서버 r - o o o o o
   제목 R - - - o - -
   지원되는 R - o o m * o o
   지원 2xx - o o m * m * o
   타임 스탬프 o o o o o o
   에 c (1) r m m m m m m
   지원되지 않는 420 - m - m m m
   사용자 에이전트 o o o o o o
   Via R amr m m m m m m
   Via rc dr m m m m m m
   경고 r - o o o o o
   WWW- 인증 401 - m - m m m
   WWW-Authenticate 407 ar - o - o o o

   표 3 : 헤더 필드 요약, P - Z; (1) : 가능한 복사
   태그 추가

      수락 : application / sdp; level = 1, application / x-private, text / html

20.2 Accept-Encoding

   Accept-Encoding 헤더 필드는 Accept와 비슷하지만
   응답에서 수용 가능한 내용 코딩 [H3.5]. 만나다
   [H14.3]. SIP의 의미는에서 정의 된 것과 동일합니다.
   [H14.3].

   빈 Accept-Encoding 헤더 필드는 허용됩니다. 그것은
   Accept-Encoding : identity (즉, ID 만 해당)
   인코딩 (인코딩이 없음)이 허용됩니다.

   Accept-Encoding 헤더 필드가 존재하지 않으면, 서버는 SHOULD
   identity의 기본값을 가정합니다.




Rosenberg, et. al. 표준 트랙 [쪽 163]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   이것은 HTTP 정의와 약간 다릅니다.
   존재하지 않을 경우, 임의의 인코딩이 사용될 수 있지만, 신원 인코딩
   선호된다.

   예:

      수락 - 인코딩 : gzip

20.3 수락 언어

   Accept-Language 헤더 필드는 요청을 나타내는 데 사용됩니다.
   이유 구문, 세션 설명, 또는
   상태 응답은 응답에서 메시지 본문으로 전달됩니다. 없는 경우
   Accept-Language 헤더 필드가 존재하면, 서버는 모든 것을 가정해야한다
   언어는 클라이언트에게 허용됩니다.

   Accept-Language 헤더 필드는 다음에 정의 된 구문을 따릅니다.
   [H14.4]. "q"에 기초한 언어 주문 규칙은 "
   매개 변수는 SIP에도 적용됩니다.

   예:

      수락 언어 : da, en-gb; q = 0.8, ko; q = 0.7

20.4 경고 - 정보

   INVITE 요청에있을 때 Alert-Info 헤더 필드
   UAS에 대한 대체 호출음을 지정합니다. 180시에있을 때
   (Ringing) 응답에서 Alert-Info 헤더 필드는
   UAC에 대한 대체 링백 톤. 일반적인 용도는 프록시입니다.
   이 헤더 필드를 삽입하여 다른 링 기능을 제공합니다.

   Alert-Info 헤더 필드는 보안 위험을 초래할 수 있습니다. 이들
   위험 및이를 다루는 방법은 20.9 절에서 논의되며,
   위험이 있기 때문에 Call-Info 헤더 필드에 대해 논의합니다.
   같은.

   또한 사용자는이 기능을 비활성화 할 수 있어야합니다 (SHOULD).
   선택적으로

      이렇게하면 사용으로 인한 장애를 예방할 수 있습니다.
      신뢰할 수없는 요소에 의한이 헤더 필드.

   예:

      알림 정보 : <http://www.example.com/sounds/moo.wav>





Rosenberg, et. al. 표준 트랙 [Page 164]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


20.5 허용

   허용 헤더 필드는 UA가 지원하는 메소드 세트를 나열합니다
   메시지를 생성합니다.

   UA가 이해하는 ACK 및 CANCEL을 포함한 모든 방법은
   허용 헤더 필드의 메소드 목록에 포함 된
   선물. Allow 헤더 필드가 없을 수 없다
   메시지를 보내는 UA가 메시지를 지원하지 않는다는 의미로 해석됩니다.
   행동 양식. 오히려, UA가 어떤 것도 제공하지 않는다는 것을 의미합니다.
   그것이 지원하는 메소드에 대한 정보.

   이외의 메소드에 대한 응답에 Allow 헤더 필드 제공
   OPTIONS은 필요한 메시지 수를 줄입니다.

   예:

      허용 : INVITE, ACK, OPTIONS, CANCEL, BYE

20.6 인증 정보

   인증 정보 헤더 필드는 상호
   HTTP 다이제스트로 인증. UAS는이 헤더 필드를 포함 할 수있다
   성공적으로 인증 된 요청에 대한 2xx 응답
   Authorization 헤더 필드를 기반으로하는 다이제스트를 사용합니다.

   구문과 의미는 RFC 2617 [17]에 명시된 것과 같습니다.

   예:

      인증 정보 : nextnonce = "47364c23432d2e131a5fb210812c"

20.7 승인

   Authorization 헤더 필드는 다음의 인증 자격 증명을 포함합니다.
   UA. 22.2 절은 Authorization 헤더의 사용을 개괄적으로 설명한다.
   필드와 섹션 22.4는 사용될 때의 구문과 의미를 설명합니다
   HTTP 인증.

   이 헤더 필드는 Proxy-Authorization과 함께 일반
   여러 헤더 필드 값에 대한 규칙 쉼표가 아니더라도,
   이 헤더 필드 이름은 여러 번 나타날 수 있지만,
   반드시 평소 사용하는 단일 헤더 행에 결합해서는 안됩니다
   7.3 절에 설명 된 규칙.







Rosenberg, et. al. 표준 트랙 [Page 165]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   아래 예에서 다이제스트는 따옴표가 없습니다.
   매개 변수 :

      권한 부여 : Digest username = "Alice", realm = "atlanta.com",
       nonce = "84a4cc6f3082121f32b42a2187831a9e"
       응답 = "7587245234b3434cc3412213e5f113a5432"

20.8 Call-ID

   Call-ID 헤더 필드는 특정 초대장을 고유하게 식별합니다.
   또는 특정 클라이언트의 모든 등록. 단일 멀티미디어
   회의는 서로 다른 Call-ID를 가진 여러 개의 호출을 발생시킬 수 있습니다.
   예를 들어 사용자가 한 명의 개인을 여러 번 초대하여
   동일한 (장기간) 회의. 통화 ID는 대소 문자를 구분하며
   단순히 바이트 단위로 비교됩니다.

   Call-ID 헤더 필드의 간결한 형태는 i입니다.

   예 :

      통화 ID : f81d4fae-7dec-11d0-a765-00a0c91e6bf6@biloxi.com
      i : f81d4fae-7dec-11d0-a765-00a0c91e6bf6@192.0.2.4

20.9 통화 정보

   Call-Info 헤더 필드는
   발신자 또는 수신자가 요청에 포함되어 있는지 또는
   응답. URI의 목적은 "목적"
   매개 변수. "icon"매개 변수는
   발신자 또는 수신자의 상징적 표현. "info"매개 변수
   예를 들어 웹을 통해 호출자 또는 호출 수신자를 일반적으로 설명합니다.
   페이지. "card"매개 변수는 예를 들어 명함을 제공합니다.
   vCard [36] 또는 LDIF [37] 형식을 사용합니다. 추가 토큰을 등록 할 수 있습니다.
   IANA와 섹션 27의 절차를 사용하십시오.

   Call-Info 헤더 필드를 사용하면 보안 위험이 발생할 수 있습니다. 만약
   피 호출자는 악의적 인 호출자가 제공 한 URI, 피 호출자
   부적절하거나 불쾌감을주는 콘텐츠를 표시 할 위험이 있습니다.
   위험하거나 불법적 인 콘텐츠 등이 포함될 수 있습니다. 따라서
   UA는 오직 Call-Info의 정보만을 표현할 것을 권장한다.
   헤더 필드는 엘리먼트의 진정성을 검증 할 수있다.
   헤더 필드를 생성하고 해당 요소를 신뢰합니다. 필요가 없다.
   동료 UA가되어야한다. 프록시는이 헤더 필드를 요청에 삽입 할 수 있습니다.

   예:

   호출 정보 : <http://wwww.example.com/alice/photo.jpg>; 목적 = 아이콘,
     <http://www.example.com/alice/>; 목적 = 정보



Rosenberg, et. al. 표준 트랙 [쪽 166]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


20.10 연락처

   Contact 헤더 필드 값은 의미가 의존하는 URI를 제공합니다.
   요청 또는 응답의 유형.

   Contact 헤더 필드 값은 표시 이름,
   URI 매개 변수 및 헤더 매개 변수

   이 문서는 Contact 매개 변수 "q"와 "expires"를 정의합니다.
   이 매개 변수는 Contact가있을 때만 사용됩니다.
   REGISTER 요청 또는 응답 또는 3xx 응답. 추가
   매개 변수는 다른 사양에서 정의 될 수 있습니다.

   헤더 필드 값에 표시 이름이 있으면 URI
   모든 URI 매개 변수를 포함하여 "<"및 ">"로 묶습니다. "<"
   및 ">"가 있으면 URI 다음의 모든 매개 변수가 header입니다.
   매개 변수가 아니라 URI 매개 변수. 표시 이름은 토큰 또는
   더 큰 문자 집합이 필요한 경우 따옴표 붙은 문자열.

   "display-name"이 비어 있더라도 "name-addr"양식은 반드시
   "addr-spec"에 쉼표, 세미콜론 또는 질문이 포함 된 경우 사용됩니다.
   표. 표시 이름과 표시 이름 사이에 LWS가 있거나 없을 수 있습니다.
   "<".

   표시 이름, URI 및 URI 매개 변수를 구문 분석하기위한 이러한 규칙
   헤더 매개 변수는 To 및 From 헤더 필드에도 적용됩니다.

      Contact 헤더 필드에는 Location 헤더와 비슷한 역할이 있습니다.
      HTTP의 필드. 그러나 HTTP 헤더 필드는 하나만 허용합니다.
      주소, 따옴표없는. URI에는 쉼표와 세미콜론이 포함될 수 있으므로
      예약 된 문자로 헤더 나
      매개 변수 분리 문자입니다.

   Contact 헤더 필드의 압축 형식은 m ( "이동"용)입니다.

   예 :

      연락처 : "Mr. Watson"<sip : watson@worcester.bell-telephone.com>
         q = 0.7; expires = 3600,
         "Mr. Watson"<mailto : watson@bell-telephone.com>; q = 0.1
      m : <sips : bob@192.0.2.4>; 만료 = 60










Rosenberg, et. al. 표준 트랙 [쪽 167]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


20.11 내용 - 처분

   Content-Disposition 헤더 필드는 메시지 본문
   또는 여러 부분 메시지의 경우 메시지 본문 부분을 해석해야합니다
   UAC 또는 UAS. 이 SIP 헤더 필드는 MIME Content-
   유형 (RFC 2183 [18]).

   Content-Disposition 헤더의 몇 가지 새로운 "폐기 유형"은 다음과 같습니다.
   SIP에 의해 정의됩니다. "session"값은 몸체 부분
   는 통화 또는 초기 (사전 호출) 미디어에 대한 세션을 설명합니다. 그만큼
   값 "렌더링"은 본문 부분이 표시되어야 함을 나타냅니다.
   그렇지 않으면 사용자에게 표시됩니다. "render"값이 사용됨에 유의하십시오.
   MIME 본문의 의미를 피하기 위해 "인라인"보다는
   전체 메시지 렌더링의 일부로 표시됩니다 (
   종종 SIP 메시지의 MIME 본문은 사용자에게 표시되지 않습니다.
   이전 버전과의 호환성을 위해 Content-Disposition 헤더 필드
   서버가 누락 된 경우, 서버는 Content-Type의 본문을 가정해야합니다
   application / sdp는 "세션"처분이며 다른 내용
   유형은 "렌더링"입니다.

   처분 유형 "icon"은 본문 부분에
   발신자 또는 수신자의 아이코닉 표현으로 적합한 이미지
   메시지가있을 때 사용자 에이전트가 정보로 표현할 수있는
   대화가 진행되는 동안 지속적으로 수신됩니다. 그만큼
   값 "alert"는 본문 부분에 정보가 들어 있음을 나타냅니다.
   오디오 클립으로서, 사용자 에이전트에 의해 렌더링되어야하는
   사용자에게 요청을 알리는 시도, 일반적으로
   대화를 시작하는 요청; 이 경고 몸체는 예를 들어
   180 벨이 울린 후 전화 벨소리로 렌더링
   임시 응답이 전송되었습니다.

   콘텐츠를 "콘텐츠 유형"으로 렌더링하는 "처분 유형"이있는 모든 MIME 본문
   사용자는 메시지가 올바르게 처리 된 경우에만 처리해야합니다.
   인증 된.

   처리 매개 변수 인 handling-param은 UAS가
   내용 유형 또는 처리가있는 메시지 본문을 수신하면 대응합니다.
   이해하지 못하는 유형. 매개 변수에는 다음과 같은 값이 정의되어 있습니다.
   "선택적"및 "필수". handling 매개 변수가 누락 된 경우
   필요한 "가치"가 가정되어야한다. 처리 매개 변수는 다음과 같습니다.
   RFC 3204 [19]에 설명되어 있습니다.

   이 헤더 필드가 없으면 MIME 유형에 따라 기본값이 결정됩니다.
   콘텐츠 처리. 아무 것도없는 경우 "렌더링"이 사용됩니다.

   예:

      콘텐츠 - 처리 : 세션



Rosenberg, et. al. 표준 트랙 [Page 168]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


20.12 콘텐츠 인코딩

   Content-Encoding 헤더 필드는
   "media-type". 이 값이 있으면 해당 값은 추가
   컨텐츠 코딩이 엔티티 본문에 적용되어
   디코딩 메커니즘은 미디어 유형을 획득하기 위해 적용되어야한다.
   Content-Type 헤더 필드에 의해 참조됩니다. 콘텐츠 인코딩
   주로 몸을 잃지 않고 압축 할 수있게하는 데 사용됩니다.
   기본 미디어 유형의 ID

   하나의 엔티티 본문에 여러 개의 인코딩이 적용된 경우
   내용 코딩은 그들이 있던 순서대로 나열되어야한다
   적용된.

   모든 내용 코딩 값은 대소 문자를 구분하지 않습니다. IANA는
   내용 코딩 값 토큰에 대한 레지스트리 [H3.5]를 참조하십시오.
   내용 코딩을위한 구문 정의.

   클라이언트는 요청시 본문에 내용 인코딩을 적용 할 수 있습니다 (MAY). 에이
   서버는 응답으로 본문에 내용 인코딩을 적용 할 수있다. 그만큼
   서버는 Accept-Encoding 헤더에 나열된 인코딩 만 사용해야합니다.
   필드를 요청하십시오.

   Content-Encoding 헤더 필드의 압축 형식은 e입니다.
   예 :

      콘텐츠 인코딩 : gzip
      전자 : 타르

20.13 콘텐츠 언어

   [H14.12] 참조. 예:

      콘텐츠 언어 : fr

20.14 내용 길이

   Content-Length 헤더 필드는 메시지의 크기를 나타냅니다.
   몸체, 수신자에게 전송 된 옥텟의 10 진수.
   응용 프로그램은이 필드를 사용하여
   전송 될 메시지 본문은 미디어 유형에 관계없이
   실재. 스트림 기반 프로토콜 (예 : TCP)이 다음과 같이 사용되는 경우
   헤더 필드는 반드시 사용해야한다.

   메시지 본문의 크기에는 분리 된 CRLF가 포함되지 않습니다.
   헤더 필드 및 본문. 모든 Content-Length보다 크거나 같음
   0은 유효한 값입니다. 메시지에 본문이 없으면
   Content-Length 헤더 필드 값을 0으로 설정해야합니다 (MUST).



Rosenberg, et. al. 표준 트랙 [쪽 169]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      Content-Length를 생략하는 기능은
      동적으로 응답을 생성하는 cgi와 유사한 스크립트.

   헤더 필드의 압축 형식은 l입니다.

   예 :

      콘텐츠 길이 : 349
      l : 173

20.15 내용 유형

   Content-Type 헤더 필드는 미디어 유형을 나타냅니다.
   메시지 본문이 수신자에게 전송되었습니다. "media-type"요소는 다음과 같습니다.
   [H3.7]에 정의되어있다. Content-Type 헤더 필드는 다음과 같은 경우에 존재해야한다.
   시체는 비어 있지 않습니다. 본문이 비어 있고 Content-Type
   헤더 필드가있는 경우 특정
   유형의 길이가 0입니다 (예 : 빈 오디오 파일).

   헤더 필드의 압축 형식은 c입니다.

   예 :

      콘텐츠 유형 : application / sdp
      c : text / html; charset = ISO-8859-4

20.16 CSeq

   요청의 CSeq 헤더 필드에는 단일 십진수 시퀀스가 ​​포함됩니다.
   번호와 요청 방법. 순서 번호는 반드시
   32 비트 부호없는 정수로 나타낼 수 있습니다. CSeq의 메소드 부분은 다음과 같습니다.
   대소 문자를 구분합니다. CSeq 헤더 필드는 거래를 주문하는 데 사용됩니다.
   대화 상자 내에서 고유하게 식별 할 수있는 수단을 제공합니다.
   새로운 요청과 요청을 구별하기 위해
   재전송. 2 개의 CSeq 헤더 필드는,
   시퀀스 번호와 요청 방법은 동일합니다. 예:

      CSeq : 4711 초대

20.17 날짜

   Date 헤더 필드에는 날짜와 시간이 포함됩니다. HTTP / 1.1과 달리,
   SIP는 날짜에 대한 최신 RFC 1123 [20] 형식 만 지원합니다. 같이
   [H3.3]에서 SIP는 SIP-date의 시간대를 "GMT"로 제한하며,
   RFC 1123은 모든 시간대를 허용합니다. RFC 1123 날짜는 대소 문자를 구분합니다.

   날짜 헤더 필드는 요청 또는 응답이 발생한 시간을 반영합니다.
   전나무

보낸 사람.



Rosenberg, et. al. 표준 트랙 [Page 170]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      Date 헤더 필드는 간단한 최종 시스템에서 사용할 수 있습니다.
      배터리 백업 시계는 현재 시간의 개념을 획득합니다.
      그러나 GMT 형식의 경우 고객이 오프셋을 알아야합니다.
      그리니치 표준시.

   예:

      날짜 : 2010 년 11 월 13 일 토요일 23:29:00 GMT

20.18 오류 정보

   Error-Info 헤더 필드는 추가 정보에 대한 포인터를 제공합니다.
   오류 상태 응답에 대한 정보.

      SIP UAC는 팝업 (pop-up)
      PC 소프트 클라 이언트의 Windows 및 오디오는 "검은 색"
      게이트웨이를 통해 연결된 전화 또는 종점. 강제로
      서버가 오류를 생성하여 오류 전송 중 선택
      자세한 이유 구문을 포함한 상태 코드와 오디오 재생
      Error-Info 헤더 필드는 둘 모두를 전송할 수있게 해준다.
      그런 다음 UAC는 렌더링 할 오류 표시기를 선택할 수 있습니다
      발신자.

   UAC는 Error-Info 헤더 필드의 SIP 또는 SIPS URI를 다음과 같이 취급 할 수있다 (MAY)
   리디렉션의 연락처 였고 새 INVITE를 생성했습니다.
   녹음 된 발표 세션에서 설정됩니다. 비 SIP URI
   사용자에게 렌더링 될 수있다.

   예 :

      SIP / 2.0 404 전화를 건 번호가 사용되지 않습니다.
      오류 정보 : <sip : not-in-service-recording@atlanta.com>

만료 20.19

   Expires 헤더 필드는 상대 시간을 제공합니다.
   메시지 (또는 콘텐츠)가 만료됩니다.

   정확한 의미는 메소드에 따라 다릅니다.

   INVITE의 만료 시간은
   초대로 인해 발생할 수있는 실제 세션 세션
   설명 프로토콜은 시간 제한을 표현할 수있는 능력을 제공 할 수있다.
   그러나 세션 기간.

   이 필드의 값은 정수 (초)입니다 (10 진수).
   요청의 수신으로부터 측정 된 0과 (2 ** 32) -1 사이의 값.




Rosenberg, et. al. 표준 트랙 [Page 171]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   예:

      만료 : 5

20.20

   From 헤더 필드는 요청의 개시자를 나타냅니다. 이
   대화 상자의 시작 자와 다를 수 있습니다. 님이 보낸 요청
   발신자의 수신자가 수신자 헤더의 수신자 주소를 사용합니다.
   들.

   선택적인 "display-name"은 인간 사용자에 의해 표현되기위한 것이다.
   인터페이스. 시스템은 "익명"표시 이름을 사용하여야한다 (SHOULD).
   클라이언트의 신원은 숨겨져 있어야합니다. 비록 "display-
   name "이 비어있는 경우,"addr-spec "
   쉼표, 물음표 또는 세미콜론을 포함합니다. 구문 문제는
   7.3.1 절에서 논의되었다.

   URI 필드가 일치하면 두 개의 From 헤더 필드가 같고
   매개 변수가 일치합니다. 하나의 헤더 필드에있는 확장 매개 변수.
   비교 대상으로는 다른쪽에있는 선물은 무시됩니다. 이
   표시 이름과 꺾쇠 괄호의 유무를 의미합니다.
   일치에 영향을주지 않습니다.

   표시 이름, URI 및 구문 분석 규칙은 20.10 절을 참조하십시오.
   URI 매개 변수 및 헤더 필드 매개 변수

   From 헤더 필드의 압축 형식은 f입니다.

   예 :

      보낸 사람 : "A. G. Bell"<sip : agb@bell-telephone.com>; tag = a48s
      보낸 사람 : sip : +12125551212@server.phone2net.com; tag = 887s
      f : 익명 <sip : c8oqz84zk7z@privacy.org>; tag = hyh8

20.21 In-Reply-To

   In-Reply-To 헤더 필드는이 호출에서 호출 ID를 열거합니다
   참조 또는 반환. 이러한 Call-ID는
   그 다음 클라이언트는 반환 호출에서이 헤더 필드에 포함됩니다.

      이를 통해 자동 콜 분배 시스템이 경로 반환을 허용합니다.
      첫 번째 호출의 발신자에 대한 호출. 이것은 또한
      호출을 필터링하여 호출에 대한 호출만을 반환합니다.
      기원 된 것입니다. 이 입력란은
      요청 인증.





Rosenberg, et. al. 표준 트랙 [Page 172]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   예:

      In-Reply-To : 70710@saturn.bell-tel.com, 17320@saturn.bell-tel.com

최대 20.22 포워드

   Max-Forwards 헤더 필드는 모든 SIP 메소드와 함께 사용해야합니다.
   요청을 전달할 수있는 프록시 또는 게이트웨이의 수를 제한하십시오.
   다음 다운 스트림 서버로 보내십시오. 이 기능은 또한
   클라이언트가 요청 체인을 추적하려고 시도하고 있습니다.
   중간 사슬에서 실패 또는 반복.

   최대 - 전달 값은 0-255 범위의 정수입니다.
   이 요청 메시지가 허용되는 남은 횟수
   전달. 이 수는 전달하는 각 서버에 의해 감소됩니다
   요청. 권장되는 초기 값은 70입니다.

   이 헤더 필드는
   그렇지 않으면 루프 감지를 보장합니다. 예를 들어, B2BUA는
   Max-Forwards 헤더 필드를 삽입하십시오.

   예:

      최대 전진 : 6

20.23 최소 유효 기간

   Min-Expires 헤더 필드는 최소 새로 고침 간격을 전달합니다
   해당 서버에서 관리하는 소프트 상태 요소에 대해 지원됩니다. 이
   레지스트라에 의해 저장되는 연락처 헤더 필드를 포함합니다. 그만큼
   헤더 필드는 0에서 10 진수의 초를 포함합니다.
   (2 ** 32) -1. 423 (Interval Too Brief) 필드의 헤더 필드 사용
   응답은 섹션 10.2.8, 10.3 및 21.4.17에 설명되어 있습니다.

   예:

      최소 유효 기간 : 60

20.24 MIME 버전

   [H19.4.1] 참조.

   예:

      MIME 버전 : 1.0






Rosenberg, et. al. 표준 트랙 [쪽 173]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


20.25 조직

   조직 헤더 필드는 조직의 이름을
   요청 또는 응답을 발행하는 SIP 엘리먼트가 속한다.

      이 필드는 클라이언트 소프트웨어가 호출을 필터링하는 데 사용할 수 있습니다 (MAY).

   예:

      조직 : Bob by Boxes

20.26 우선 순위

   Priority 헤더 필드는 요청의 긴급 성을 다음과 같이 나타냅니다.
   클라이언트에 의해 감지됩니다. Priority 헤더 필드는
   SIP 요청이 수신하는 사람에게 있어야하는 우선 순위 또는
   그 대리인. 예를 들어, 전화에 대한 결정에 고려 될 수 있습니다
   라우팅 및 수용. 이러한 결정의 경우,
   우선 순위 헤더 필드는 우선 순위를 지정한 것처럼 취급되어야합니다 (SHOULD).
   "정상". Priority 헤더 필드는 사용에 영향을주지 않습니다.
   패킷 전달 우선 순위와 같은 통신 자원
   라우터 또는 PSTN 게이트웨이의 회선에 액세스 할 수 있습니다. 헤더 필드는
   "비 긴급 성", "보통", "긴급 성"및 "비상 사태"가있다.
   추가 값은 다른 곳에서 정의 할 수 있습니다. 권장 사항
   "비상 사태"의 가치는 생명, 사지 또는
   재산이 임박한 위험에 처해있다. 그렇지 않으면 의미가 없습니다.
   이 헤더 필드에 대해 정의됩니다.

      이것들은 RFC 2076 [38]의 값이며,
      "비상 사태".

   예 :

      제목 : 토네이도가 가고 있습니다!
      우선 순위 : 비상 사태

   또는

      제목 : 주말 계획
      우선 순위 : 비 긴급

20.27 프록시 - 인증

   Proxy-Authenticate 헤더 필드 값에 인증이 포함되어 있습니다.
   도전.

   이 헤더 필드의 사용은 [H14.33]에 정의되어있다. 섹션 참조
   그 사용법에 대한 더 자세한 정보는 22.3을 참조하십시오.



Rosenberg, et. al. 표준 트랙 [Page 174]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   예:

      프록시 인증 : 다이제스트 영역 = "atlanta.com",
       domain = "sip : ss1.carrier.com", qop = "auth",
       nonce = "f84f1cec41e6cbe5aea9c8e88d359",
       opaque = "", 부실 = FALSE, 알고리즘 = MD5

20.28 프록시 인증

   Proxy-Authorization 헤더 필드는 클라이언트가
   자체 (또는 사용자)를 인증이 필요한 프록시로 에이
   Proxy-Authorization 필드 값은 다음을 포함하는 자격 증명으로 구성됩니다.
   프록시 용 사용자 에이전트의 인증 정보 및 / 또는
   자원의 영역이 요청됩니다.

   이 헤더 필드의 사용법에 대한 정의는 22.3 절을 참조하십시오.

   이 헤더 필드는 인증과 함께 일반 규칙을 위반합니다.
   여러 헤더 필드 이름에 대해. 쉼표로 구분 된 것은 아니지만
   목록에서이 헤더 필드 이름은 여러 번 나타날 수 있으며 반드시
   일반적인 규칙을 사용하여 단일 헤더 행에 결합해서는 안됩니다.
   섹션 7.3.1에서 설명합니다.

   예:

   프록시 인증 : Digest username = "Alice", realm = "atlanta.com",
      nonce = "c60f3082ee1212b402a21831ae",
      응답 = "245f23415f11432b3434341c022"

20.29 프록시 - 요구 사항

   Proxy-Require 헤더 필드는 프록시에 민감한
   프록시가 지원해야하는 기능 20.32 절 참조
   이 메시지의 메카니즘 및 사용 예에 ​​대한 자세한 내용.

   예:

      Proxy-Require : foo

20.30 기록 - 경로

   Record-Route 헤더 필드는 요청에 대한 프록시에 의해 삽입됩니다.
   미래의 요청을 대화 상자에서 프록시를 통해 라우트하도록합니다.

   Route 헤더 필드와 함께 사용되는 예는
   섹션 16.12.1.





Rosenberg, et. al. 표준 트랙 [Page 175]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   예:

      Record-Route : <sip : server10.biloxi.com; lr>,
                    <sip : bigbox3.site3.atlanta.com; lr>

20.31 답장

   Reply-To 헤더 필드는 다음과 같은 논리 반환 URI를 포함합니다.
   From 헤더 필드와 다릅니다. 예를 들어, URI는
   부재중 전화 또는 설정되지 않은 세션을 반환하는 데 사용됩니다. 사용자가
   익명으로 남아 있기를 바란다면, 헤더 필드는 생략되어야한다 (SHOULD).
   요청에서 얻었거나 아무 것도 공개하지 않는 방식으로 채워진
   개인 정보.

   "display-name"이 비어 있더라도 "name-addr"양식은 반드시
   "addr-spec"에 쉼표, 물음표 또는
   세미콜론. 구문 문제는 7.3.1 절에서 설명합니다.

   예:

      답장 : Bob <sip : bob@biloxi.com>

20.32 요구 사항

   요구 헤더 필드는 UAC가 옵션에 대해 UAS에 알리기 위해 사용됩니다.
   UAC는 UAS가 해당 서비스를 처리하기 위해 지원할 것으로 기대합니다.
   의뢰. 선택적인 헤더 필드이지만, Require는 존재하지 않아야한다.
   존재하는 경우 무시됩니다.

   헤더 필드에는 옵션 태그 목록이 들어 있습니다.
   섹션 19.2. 각 옵션 태그는 반드시 SIP 확장을 정의합니다.
   요청을 처리하는 것으로 이해합니다. 자주, 이것은
   특정 확장 헤더 필드 세트가 있어야 함을 나타냅니다.
   이해했다. 이 규격에 부합하는 UAC는
   표준 추적 RFC에 해당하는 옵션 태그

   예:

      요구 사항 : 100rel

20.33 다시 시도 - 이후

   Retry-After 헤더 필드는 500 (서버 내부
   오류) 또는 503 (서비스 사용 불가능) 응답을 표시합니다.
   서비스는 요청한 클라이언트가 사용할 수 없을 것으로 예상됩니다.
   404 (찾을 수 없음), 413 (요청 엔터티가 너무 큼), 480
   (일시적으로 사용 불가), 486 (사용 중), 600 (사용 중) 또는 603




Rosenberg, et. al. 표준 트랙 [쪽 176]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   (거절) 응답을 수신자가 예상 할 때 나타냅니다
   다시 사용할 수 있습니다. 이 필드의 값은 양의 정수입니다.
   응답 시간 후 초 수 (십진수).

   선택적 주석은 추가 정보를 나타내는 데 사용할 수 있습니다.
   콜백의 시간. 선택적 "기간"매개 변수
   착신자가 전화를 걸 수있는 시간을 나타냅니다.
   가용성의 초기 시간. duration 매개 변수를 지정하지 않으면
   서비스가 무기한으로 사용 가능하다고 가정합니다.

   예 :

      재시도 후 : 18000; 지속 시간 = 3600
      재시도 후 : 120 (회의 중)

20.34 국도

   Route 헤더 필드는 요청에 대한 라우팅을 강제로 수행하는 데 사용됩니다.
   나열된 프록시 집합 Route 헤더의 사용 예
   필드는 16.12.1 절에 있습니다.

   예:

      경로 : <sip : bigbox3.site3.atlanta.com; lr>
             <sip : server10.biloxi.com; lr>

20.35 서버

   서버 헤더 필드에는 사용 된 소프트웨어에 대한 정보가 들어 있습니다.
   UAS는 요청을 처리합니다.

   서버의 특정 소프트웨어 버전을 공개하면
   서버는 소프트웨어에 대한 공격에보다 취약 해집니다.
   보안 구멍이있는 것으로 알려져 있습니다. 구현자는 서버를 만들어야합니다.
   헤더 필드는 구성 가능한 옵션입니다.

   예:

      서버 : HomeServer v2

20.36 제목

   주제 헤더 필드는 요약을 제공하거나 자연을 나타냅니다.
   구문 분석 할 필요없이 호출 필터링을 허용합니다.
   세션 설명 세션 설명은 사용할 필요가 없습니다.
   초대장과 동일한 제목 표시.

   Subject 헤더 필드의 압축 형식은 s입니다.



Rosenberg, et. al. 표준 트랙 [쪽 177]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   예:

      제목 : 상자가 더 필요함
      s : 기술 지원

20.37 지원됨

   Supported 헤더 필드는 다음에 의해 지원되는 모든 확장을 열거합니다.
   UAC 또는 UAS.

   Supported 헤더 필드는 옵션 태그 목록을 포함합니다.
   19.2 절에서 UAC 또는 UAS가 이해할 수있는 UA
   이 사양을 준수하는 경우 옵션 태그 만 포함해야합니다
   표준 추적 RFC에 해당합니다. 비어있는 경우
   확장이 지원됩니다.

   지원되는 헤더 필드의 압축 형식은 k입니다.

   예:

      지원 : 100rel

20.38 타임 스탬프

   Timestamp 헤더 필드는 UAC가 요청을 보낸시기를 설명합니다.
   UAS.

   응답을 생성하는 방법에 대한 자세한 내용은 8.2.6 절을 참조하십시오.
   헤더 필드를 포함하는 요청. 없다.
   여기에서 정의 된 규범적인 행동은 헤더를 사용한다.
   확장 또는 SIP 애플리케이션이 RTT 견적을 얻을 수 있도록합니다.

   예:

      타임 스탬프 : 54

받는 사람 20.39

   To 헤더 필드는 요청의 논리적 수신자를 지정합니다.

   선택적인 "display-name"은 인간 사용자에 의해 표현되기위한 것이다.
   인터페이스. "태그"매개 변수는 다음에 대한 일반적인 메커니즘으로 사용됩니다.
   대화 상자 식별.

   "tag"매개 변수에 대한 자세한 내용은 19.3 절을 참조하십시오.






Rosenberg, et. al. 표준 트랙 [Page 178]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   To 헤더 필드의 동일성 비교는 다음과 같습니다.
   From 헤더 필드 비교. 규칙에 대해서는 20.10 절을 보라.
   표시 이름, URI 및 URI 매개 변수를 구문 분석하고 헤더 필드
   매개 변수.

   To 헤더 필드의 압축 형식은 t입니다.

   다음은 유효한 To 헤더 필드의 예입니다.

      받는 사람 : 운영자 <sip : operator@cs.columbia.edu>; tag = 287447
      t : sip : +12125551212@server.phone2net.com

20.40 지원되지 않음

   지원되지 않는 헤더 필드는 지원되지 않는 기능을 나열합니다.
   UAS. 동기 부여에 대해서는 20.32 절을 참조하십시오.

   예:

      지원되지 않음 : foo

20.41 사용자 에이전트

   User-Agent 헤더 필드에는 UAC에 대한 정보가 들어 있습니다.
   요청을 발신합니다. 이 헤더 필드의 의미는 다음과 같습니다.
   [H14.43]에 정의되어있다.

   사용자 에이전트의 특정 소프트웨어 버전 공개
   사용자 에이전트는 소프트웨어에 대한 공격에보다 취약해진다.
   보안 구멍이있는 것으로 알려져 있습니다. 구현자는 반드시 만들어야한다.
   User-Agent 헤더 필드는 구성 가능한 옵션입니다.

   예:

      사용자 에이전트 : Softphone Beta1.5

20.42 비아

   Via 헤더 필드는 지금까지 요청에 의해 취해진 경로를 나타냅니다
   라우팅 응답에서 따라야하는 경로를 나타냅니다.
   Via 헤더 필드 값의 분기 ID 매개 변수는
   트랜잭션 식별자이며 프록시가 루프를 감지하는 데 사용됩니다.

   Via 헤더 필드 값은 전송에 사용 된 전송 프로토콜을 포함합니다
   메시지, 클라이언트의 호스트 이름 또는 네트워크 주소 및 가능하면
   응답을 받기를 원하는 포트 번호. 비아
   헤더 필드 값은 "maddr",
   "ttl", "received"및 "branch"는 의미와 사용법이 설명되어 있습니다.



Rosenberg, et. al. 표준 트랙 [쪽 179]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   다른 섹션. 이것에 준거 한 구현
   사양을 사용하는 경우 분기 매개 변수의 값은
   magic cookie "z9hG4bK", 섹션 8.1.1.7.

   여기에 정의 된 전송 프로토콜은 "UDP", "TCP", "TLS"및 "SCTP"입니다.
   "TLS"는 TCP를 통한 TLS를 의미합니다. 요청이 SIPS URI로 전송되면
   프로토콜은 여전히 ​​"SIP"를 나타내고 전송 프로토콜은 TLS입니다.

경유 : SIP / 2.0 / UDP erlang.bell-telephone.com:5060;branch=z9hG4bK87asdks7
Via : SIP / 2.0 / UDP 192.0.2.1:5060, received = 192.0.2.207
     분기 = z9hG4bK77asjd

   Via 헤더 필드의 압축 형식은 v입니다.

   이 예에서 메시지는 다음과 같은 다중 홈 호스트에서 발생한 메시지입니다.
   두 개의 주소, 192.0.2.1 및 192.0.2.207. 발신자가 잘못 생각한 경우
   어떤 네트워크 인터페이스가 사용될 것인가. 얼랭. 벨 -
   telephone.com은 불일치를 발견하고
   이전 홉의 Via 헤더 필드 값으로
   패킷은 실제로 온 것입니다.

   호스트 또는 네트워크 주소와 포트 번호는 필요하지 않습니다.
   SIP URI 구문을 따르십시오. 구체적으로 LWS는
   다음과 같이 ":"또는 "/"가 허용됩니다.

      경유 : SIP / 2.0 / UDP first.example.com : 4000, ttl = 16
        ; maddr = 224.2.0.1; 가지 = z9hG4bKa7c6a8dlze.1

   이 사양에서는 분기 매개 변수가
   모든 요청에 ​​나타나면 헤더 필드의 BNF는
   선택 사항입니다. 이를 통해 RFC 2543 요소와의 상호 운용이 가능하며,
   분기 매개 변수를 삽입 할 필요가 없었습니다.

   두 개의 Via 헤더 필드는 전송 된 프로토콜과 보낸 사람이 같으면 동일합니다.
   필드가 동일하고 둘 다 동일한 매개 변수 세트를 가지며
   모든 매개 변수의 값은 동일합니다.

20.43 경고

   경고 헤더 필드는 추가 정보를 전달하는 데 사용됩니다.
   응답 상태에 대해 경고 헤더 필드 값이 전송됩니다.
   응답과 함께 3 자리 경고 코드, 호스트 이름 및
   경고 텍스트.

   "warn-text"는 자연어로 작성되어야합니다.
   응답을 수신하는 인간 사용자가 알 수 있어야한다. 이
   의사 결정은 가능한 모든 지식 (예 :
   사용자의 위치, 요청의 Accept-Language 필드 또는



Rosenberg, et. al. 표준 트랙 [Page 180]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   응답의 내용 - 언어 필드. 기본 언어는 i-
   기본값 [21].

   현재 정의 된 "경고 코드"는 다음과 같습니다.
   영어로 경고문을 추천하고 의미를 설명한다.
   이 경고는 세션 설명으로 인한 실패를 설명합니다.
   "3"으로 시작하는 경고 코드의 첫 번째 숫자는
   SIP 관련 경고. 경고 300 ~ 329는
   세션 설명의 키워드 문제 표시, 330
   339까지는 요청 된 기본 네트워크 서비스와 관련된 경고입니다.
   세션 설명에서 370 ~ 379는 다음과 관련된 경고입니다.
   세션 설명에서 요청 된 정량적 QoS 매개 변수
   390에서 399까지는 하나에 속하지 않는 기타 경고입니다.
   위 카테고리 중

      300 호환되지 않는 네트워크 프로토콜 : 하나 이상의 네트워크 프로토콜
          세션 설명에 포함 된 내용은 사용할 수 없습니다.

      301 호환되지 않는 네트워크 주소 형식 : 하나 이상의 네트워크
          세션 설명에 포함 된 주소 형식은
          유효한.

      302 호환되지 않는 전송 프로토콜 : 하나 이상의 전송
          세션 설명에 설명 된 프로토콜은
          유효한.

      303 호환되지 않는 대역폭 단위 : 하나 이상의 대역폭
          세션 설명에 포함 된 측정 단위는
          이해되지.

      304 미디어 유형을 사용할 수 없음 :
          세션 설명을 사용할 수 없습니다.

      305 호환되지 않는 미디어 포맷 : 하나 이상의 미디어 포맷 포함
          세션 설명에서 사용할 수 없습니다.

      306 Attribute not understand : 하나 이상의 미디어 속성
          세션 설명에서 지원되지 않습니다.

      307 세션 설명 매개 변수를 알 수 없음 : 매개 변수
          위에 열거 된 것들 이외의 것들은 이해되지 않았다.

      330 Multicast not available : 사용자가있는 사이트
          멀티 캐스트를 지원하지 않습니다.

      331 유니 캐스트를 사용할 수 없음 : 사용자가있는 사이트에서 수행
          유니 캐스트 통신을 지원하지 않습니다 (일반적으로
          ).



Rosenberg, et. al. 표준 트랙 [Page 181]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      370 대역폭 부족 : 세션에 지정된 대역폭
          설명 또는 매체에 의해 정의 된 것보다
          유효한.

      399 기타 경고 : 경고 텍스트는 임의적
          인간 사용자에게 제공되거나 기록 될 정보. 에이
          이 경고를받는 시스템은 자동으로
          동작.

             1xx 및 2xx는 HTTP / 1.1에 의해 사용되었습니다.

   추가 "경고 코드"는 IANA를 통해 정의 할 수 있습니다.
   27.2 절.

   예 :

      경고 : 307 isi.edu "세션 매개 변수 'foo'not understand"
      경고 : 301 isi.edu "호환되지 않는 네트워크 주소 유형 'E.164'"

20.44 WWW- 인증

   WWW-Authenticate 헤더 필드 값에 인증이 포함되어 있습니다.
   도전. 사용법에 대한 더 자세한 정보는 22.2 절을 참조하십시오.

   예:

      WWW- 인증 : 다이제스트 영역 = "atlanta.com",
        domain = "sip : boxesbybob.com", qop = "auth",
        nonce = "f84f1cec41e6cbe5aea9c8e88d359",
        opaque = "", 부실 = FALSE, 알고리즘 = MD5

21 응답 코드

   응답 코드는 HTTP / 1.1 응답과 일치하고 확장됩니다.
   코드. 모든 HTTP / 1.1 응답 코드가 적절하지는 않으며
   적절한 것은 여기에 주어집니다. 기타 HTTP / 1.1 응답
   코드를 사용해서는 안됩니다 (SHOULD NOT). 또한 SIP는 새로운 클래스 인 6xx를 정의합니다.

21.1 잠정 1xx

   잠정적 인 응답 (정보 응답으로도 알려짐)
   접촉 한 서버가 추가 작업을 수행하고 있음을 나타냅니다.
   아직 명확한 응답이 없습니다. 서버가 1xx를 보냅니다.
   최종 결과를 얻기 위해 200ms 이상 걸릴 것으로 예상되면 응답
   응답. 1xx 응답은 안정적으로 전송되지 않습니다.
   클라이언트가 절대로 ACK를 전송하지 못하게합니다. 임시 (1xx)
   응답은 세션 설명을 포함하여 메시지 본문을 포함 할 수 있습니다.




Rosenberg, et. al. 표준 트랙 [Page 182]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.1.1 100 시도하기

   이 응답은 요청이
   다음 홉 서버를 사용하고 일부 지정되지 않은 작업이 수행되고 있음을 나타냅니다.
   이 호출을 대신하여 (예를 들어, 데이터베이스가 참조되고 있음).
   이 응답은 다른 모든 임시 응답과 마찬가지로 중지됩니다.
   UAC에 의한 INVITE의 재전송. 100 (Trying) 응답은 다음과 같습니다.
   다른 임시 응답과는 달리
   상태 저장 프록시에 의해 업스트림으로 전달됩니다.

21.1.2 180 울림

   INVITE를 수신 한 UA가 사용자에게 경고하려고합니다. 이
   응답은 로컬 링백을 시작하는 데 사용될 수 있습니다 (MAY).

21.1.3 181 전화가 착신 전환되고 있습니다.

   서버는이 상태 코드를 사용하여 호출이 있음을 나타낼 수 있습니다
   다른 대상 집합으로 전달됩니다.

21.1.4 182 대기 중

   수신자가 일시적으로 사용할 수 없지만 서버에
   호출을 거부하기보다는 대기열에 넣기로 결정했습니다. 피 호출자가
   사용할 수있게되면 적절한 최종 상태를 반환합니다.
   응답. 이유 구문은
   통화 상태 (예 : "5 통화 대기 중, 예상 대기 중
   시간은 15 분입니다. "서버는 여러 개의 182 (Queued)
   응답을 사용하여 대기중인 통화의 상태에 대해 발신자를 업데이트합니다.

21.1.5 183 세션 진행

   183 (세션 진행) 응답은 정보를 전달하는 데 사용됩니다.
   달리 분류되지 않은 통화 진행 상황 그만큼
   이유 - 구문, 헤더 필드 또는 메시지 본문은 전달에 사용될 수 있습니다
   통화 진행에 대한 자세한 내용.

21.2 성공한 2xx

   요청이 성공했습니다.

21.2.1 200 OK

   요청이 성공했습니다. 반환 된 정보는
   응답은 요청에 사용 된 메소드에 따라 다릅니다.






Rosenberg, et. al. 표준 트랙 [Page 183]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.3 리디렉션 3xx

   3xx 응답은 사용자의 새 위치에 대한 정보를 제공합니다.
   통화를 만족시킬 수있는 대체 서비스에 대해

21.3.1 300 다중 선택

   요청의 주소는 몇 가지 선택 사항으로 해결되었으며 각각
   자신의 특정 위치를 선택할 수 있으며 사용자 (또는 UA)는 선호하는 위치를 선택할 수 있습니다.
   통신 끝점을 찾아 해당 위치로 요청을 리디렉션합니다.

   응답은 자원 목록을 포함하는 메시지 본문을 포함 할 수있다 (MAY)
   사용자 또는 UA가 선택할 수있는 특성 및 위치
   Accept 요청 헤더에 의해 허용되는 경우 가장 적합한 것
   들. 그러나이 메시지에 대해 정의 된 MIME 형식이 없습니다.
   신체.

   선택 사항은 연락처 필드 (20.10 절)로도 나열되어야합니다 (SHOULD).
   HTTP와 달리 SIP 응답에는 여러 개의 Contact 필드 또는
   연락처 필드의 주소 목록 UA는 Contact 헤더를 사용할 수있다.
   자동 재 지정을위한 필드 값 또는 사용자에게 확인을 요청할 수 있습니다
   선택. 그러나이 표준은 어떤 표준도 정의하지 않는다.
   그러한 자동 선택.

      이 상태 응답은 호출 수신자에게 도달 할 수있는 경우 적절합니다.
      여러 위치에서 서버를 사용할 수 없거나
      요청을 프록시 처리하지 않습니다.

21.3.2 301 영원한 이사

   사용자는 Request-URI의 주소에서 더 이상 찾을 수 없으며,
   그리고 요청 클라이언트는에 의해 주어진 새로운 주소에서 재 시도해야한다.
   Contact 헤더 필드 (20.10 절). 요청자는
   로컬 디렉토리, 주소록 및 사용자 위치 캐시를 업데이트하십시오.
   이 새로운 가치로 미래의 요청을 주소로 리디렉션합니다.
   나열됩니다.

일시적으로 이사 한 21.3.3 302

   요청 클라이언트는 새로운 주소 (들)에서 요청을 재 시도해야한다 (SHOULD)
   Contact 헤더 필드 (20.10 절)에 의해 주어진다. 요청 URI
   새 요청의 Contact 헤더 필드 값이
   응답.








Rosenberg, et. al. 표준 트랙 [Page 184]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   Contact URI의 유효 기간을 표시 할 수 있습니다.
   Expires (20.19 절) 헤더 필드를 사용하거나 만료
   매개 변수는 Contact 헤더 필드에 있습니다. 프록시와 UA 모두 MAY
   만료 시간 동안이 URI를 캐시하십시오. 있을 경우
   명시적인 만료 시간 없음. 주소는 다음 경우에만 한 번 유효합니다.
   재귀 적으로, 미래의 트랜잭션을 위해 캐싱되어서는 안된다.

   Contact 헤더 필드에서 캐시 된 URI가 실패하면 Request-
   리디렉션 된 요청의 URI가 한 번만 다시 시도 될 수 있습니다 (MAY).

      임시 URI가 이전보다 만료되었을 수 있습니다.
      만료 시간 및 새 임시 URI를 사용할 수 있습니다.

21.3.4 305 프록시 사용

   요청 된 리소스는에 의해 주어진 프록시를 통해 액세스해야합니다.
   연락처 필드 Contact 필드는 프록시의 URI를 제공합니다.
   수령인은 다음을 통해이 단일 요청을 반복해야합니다.
   프록시. 305 (Use Proxy) 응답은 UAS에 의해서만 생성되어야한다.

21.3.5 380 대체 서비스

   전화가 성공하지 못했지만 대체 서비스가 가능합니다.

   대체 서비스는 본문의 메시지 본문에 설명되어 있습니다.
   응답. 그러한 몸체에 대한 형식은 여기에 정의되지 않으며
   미래 표준화의 주제

21.4 요청 실패 4xx

   4xx 응답은 특정 오류 응답입니다.
   섬기는 사람. 클라이언트는 다음 조건을 만족하지 않으면 동일한 요청을 재 시도하지 않아야한다.
   수정 (예 : 적절한 권한 부여 추가).
   그러나 다른 서버에 대한 동일한 요청이 성공할 수 있습니다.

21.4.1 400 요청이 잘못되었습니다.

   형식이 잘못된 구문으로 인해 요청을 이해할 수 없습니다. 그만큼
   Reason-Phrase는 구문 문제를보다 자세히 식별해야합니다.
   예 : "누락 된 Call-ID 헤더 필드".

21.4.2 401 승인되지 않음

   이 요청에는 사용자 인증이 필요합니다. 이 응답은
   UAS 및 레지스트라, 407 (프록시 인증 필요)은
   프록시 서버에서 사용됩니다.





Rosenberg, et. al. 표준 트랙 [Page 185]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.4.3 402 지불 필요

   나중에 사용하기 위해 예약되어 있습니다.

21.4.4 403 금지됨

   서버가 요청을 이해했지만이를 이행하기를 거부합니다.
   승인은 도움이되지 않으며 요청을 반복해서는 안됩니다.

21.4.5 404 찾을 수 없음

   서버에는 사용자가 존재하지 않는 확실한 정보가 있습니다.
   Request-URI에 지정된 도메인. 이 상태는 또한이다
   요청 URI의 도메인이 요청 URI와 일치하지 않으면 반환됩니다.
   도메인은 요청 수신자가 처리하는 도메인입니다.

21.4.6 405 메서드가 허용되지 않음

   Request-Line에 명시된 메소드는 이해되지만
   Request-URI에 의해 식별 된 주소에 대해 허용된다.

   응답은 다음을 포함하는 허용 헤더 필드를 포함해야한다.
   지정된 주소에 유효한 메소드.

21.4.7 406 허용되지 않음

   요청으로 식별 된 리소스는 생성 만 가능합니다.
   내용 특성이 수용 가능하지 않은 응답 엔터티
   요청에서 보낸 Accept 헤더 필드에 따라.

21.4.8 407 프록시 인증 필요

   이 코드는 401 (Unauthorized)과 유사하지만
   클라이언트는 먼저 자신을 프록시로 인증해야합니다. SIP 액세스
   인증 나는

26 절과 22.3 절에서 설명했다.

   이 상태 코드는 애플리케이션에 액세스 할 수있는 애플리케이션에 사용할 수 있습니다.
   통신 채널 (예 : 전화 통신 게이트웨이)보다는
   호출 수신자에게는 인증이 필요합니다.

21.4.9 408 요청 제한 시간

   서버가 적절한 양의 응답을 생성 할 수 없습니다.
   예를 들어 사용자의 위치를 ​​파악할 수없는 경우
   제 시간에. 클라이언트는 다음과 같이 수정하지 않고 요청을 반복 할 수있다.
   나중에.





Rosenberg, et. al. 표준 트랙 [Page 186]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.4.10 410 사라짐

   요청 된 리소스는 서버에서 더 이상 사용할 수 없으며
   전달 주소가 알려져 있습니다. 이 상태는
   영원한 것으로 간주됩니다. 서버가 모르는 경우 또는없는 경우
   상태가 영구적인지 아닌지를 결정하는 시설,
   상태 코드 404 (찾을 수 없음)를 대신 사용해야합니다.

21.4.11 413 요청 개체가 너무 큽니다.

   요청으로 인해 서버가 요청 처리를 거부합니다.
   entity-body는 서버가 처리 할 수있는 것보다 큽니다.
   서버는 클라이언트를 막기 위해 연결을 닫을 수 있습니다.
   요청을 계속합니다.

   조건이 임시라면, 서버는 재시도 -
   헤더 필드 다음에 임시이며 이후에 있음을 나타냅니다.
   클라이언트가 다시 시도 할 수있는 시간.

21.4.12 414 Request-URI가 너무 깁니다.

   서버가 요청을 처리하기를 거부합니다. 요청 URI
   서버가 해석하려고하는 것보다 길다.

21.4.13 415 지원되지 않는 미디어 유형

   서버가 요청을 처리하는 것을 거부합니다.
   요청의 본문이 서버에서 지원하지 않는 형식입니다.
   요구 된 메소드 서버는 허용 가능한 목록을 반환해야합니다 (MUST).
   Accept, Accept-Encoding 또는 Accept-Language 헤더를 사용하여 형식 지정
   필드를 사용하여 콘텐츠의 특정 문제를 해결할 수 있습니다. UAC
   이 응답 처리는 8.1.3.5 절에 설명되어 있습니다.

21.4.14 416 지원되지 않는 URI 체계

   서버가 URI 스킴으로 인해 요청을 처리 할 수 ​​없습니다.
   Request-URI의 URI는 서버에 알려지지 않습니다. 클라이언트 프로세싱
   이 응답은 8.1.3.5 절에 설명되어 있습니다.

21.4.15 420 잘못된 확장

   서버가 a에 지정된 프로토콜 확장을 이해하지 못했습니다.
   Proxy-Require (20.29 절) 또는 Require (Section 20.32) 헤더
   들. 서버는 지원되지 않는 확장 목록을 포함해야합니다 (MUST).
   응답의 지원되지 않는 헤더 필드 UAC 처리 중
   이 응답은 8.1.3.5 절에 설명되어 있습니다.





Rosenberg, et. al. 표준 트랙 [Page 187]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.4.16 421 연장 필수

   UAS는 요청을 처리하기 위해 특정 확장이 필요하지만이
   확장은 요청의 지원 헤더 필드에 나열되지 않습니다.
   이 상태 코드가있는 응답은 Require 헤더 필드를 포함해야합니다
   필요한 확장을 나열합니다.

   UAS는이 응답을 진정으로 제공 할 수없는 경우를 제외하고는이 응답을 사용하지 않아야합니다.
   유용한 서비스. 대신 바람직한 확장자가
   지원되는 헤더 필드에 나열되지 않은 경우 서버는
   기본 SIP 기능 및 지원되는 모든 내선 번호를 사용하여 요청
   클라이언트가

21.4.17 423 간격 너무 짧음

   서버가 요청을 거부합니다.
   요청에 의해 새로 고쳐진 자원이 너무 짧습니다. 이 응답
   레지스트라가 등록을 거절하는 데 사용될 수 있습니다.
   헤더 필드 만료 시간이 너무 짧습니다. 이 응답의 사용
   및 관련 Min-Expires 헤더 필드는 섹션에 설명되어 있습니다.
   10.2.8, 10.3 및 20.23.

21.4.18 480 일시적으로 사용할 수 없음

   피 호출자의 최종 시스템에 성공적으로 연결되었지만 피사체는
   현재 사용할 수 없습니다 (예 : 로그인하지 않고 로그인 한 상태
   피 호출자와의 통신을 방해하거나
   "방해 금지"기능 활성화). 응답은
   Retry-After 헤더 필드를 호출하는 것이 더 좋습니다. 사용자는
   또한이 서버에 익숙하지 않은 다른 곳에서도 사용할 수 있습니다. 이유
   구는 왜 피 호출자가 왜 더 정확한 원인을 나타내야 만한다.
   없는. 이 값은 UA에 의해 설정 가능해야한다. 상태 486
   (Busy Here) 특정 상황을보다 정확하게 나타 내기 위해 사용될 수 있습니다
   통화 실패의 이유.

   이 상태는 리디렉션 또는 프록시 서버에서도 반환됩니다.
   Request-URI에 의해 식별 된 사용자를 인식하지만
   현재 해당 사용자에 대한 유효한 전달 위치가 있습니다.

21.4.19 481 통화 / 거래가 존재하지 않습니다.

   이 상태는 UAS가 요청을받지 못했음을 나타냅니다.
   기존 대화 또는 거래와 일치시킵니다.

21.4.20 482 루프 감지 됨

   서버가 루프를 감지했습니다 (16.3 항목 4).




Rosenberg, et. al. 표준 트랙 [Page 188]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.4.21 483 너무 많은 홉

   서버가 Max-Forwards (섹션
   20.22) 헤더 필드를 값 0으로 설정합니다.

21.4.22 484 주소 불완전

   서버가 불완전한 요청 URI를 가진 요청을 받았습니다.
   추가 정보는 이유 구문에 제공되어야한다.

      이 상태 코드는 중복 다이얼링을 허용합니다. 겹쳐서
      전화 걸기, 클라이언트가 전화 걸기 길이를 알지 못함
      끈. 늘어나는 길이의 문자열을 보내어
      사용자가 더 이상 입력을받지 못하면 484 (주소
      불완전한) 상태 응답.

21.4.23 485 모호합니다.

   Request-URI가 모호했습니다. 응답은 다음의 목록을 포함 할 수있다.
   Contact 헤더 필드에서 가능한 모호하지 않은 주소. 계시
   대안은 사용자 또는 조직의 개인 정보를 침해 할 수 있습니다.
   상태 404로 응답하도록 서버를 구성 할 수 있어야합니다 (MUST).
   (찾을 수 없음) 또는 가능한 선택 목록을 표시하지 않으려면
   모호한 Request-URI.

   Request-URI로 요청에 대한 응답의 예
   한모금 : lee@example.com :

      SIP / 2.0 485 모호한
      연락처 : Carol Lee <sip : carol.lee@example.com>
      연락처 : Ping Lee <sip : p.lee@example.com>
      연락처 : Lee M. Foote <sips : lee.foote@example.com>

      일부 이메일 및 음성 메일 시스템은이 기능을 제공합니다. 에이
      의미가 3xx이므로 3xx와는 별개의 상태 코드가 사용됩니다.
      다르다 : 300을 위해, 동일한 사람 또는 서비스
      제공된 선택 사항에 도달 할 것입니다. 자동화 된
      선택 또는 순차 검색은 3xx 응답, 사용자
      485 (모호한) 응답에 개입이 필요합니다.

21.4.24 486 여기에서 바쁜

   피 호출자의 최종 시스템에 성공적으로 연결되었지만 피사체가
   현재이 목적으로 추가 통화를 할 의사가 없거나 추가 통화를 할 수 없음
   체계. 응답은 전화를 걸기에 더 좋은 시간을 나타낼 수 있습니다.
   Retry-After 헤더 필드. 사용자는 또한 사용할 수 있습니다.





Rosenberg, et. al. 표준 트랙 [Page 189]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   음성 메일 서비스 등을 통해 상태 600 (사용 중
   어디든지) 클라이언트가 다른 끝이 없다는 것을 알고 있으면 사용해야합니다
   시스템이이 통화를 수락 할 수 있습니다.

21.4.25 487 요청 종료 됨

   요청은 BYE 또는 CANCEL 요청으로 종료되었습니다. 이 응답
   CANCEL 요청 자체에 대해서는 반환되지 않습니다.

21.4.26 488 여기서 허용되지 않습니다.

   응답은 606 (허용되지 않음)과 동일한 의미이지만,
   Request-URI로 주소 지정된 특정 자원에 적용되며
   요청은 다른 곳에서 성공할 수 있습니다.

   미디어 기능에 대한 설명이 포함 된 메시지 본문이있을 수 있습니다
   응답에 표시되며 Accept에 따라 형식이 지정됩니다.
   INVITE의 헤더 필드 (존재하지 않을 경우 응용 프로그램 / sdp),
   OPTIONS 요청에 대한 200 (OK) 응답의 메시지 본문과 동일합니다.

21.4.27 491 요청 대기 중

   보류중인 요청이있는 UAS에서 요청을 받았습니다.
   동일한 대화 상자. 14.2 절은 그러한 "섬광"상황
   해결되었습니다.

21.4.28 493 해독 할 수 없음

   암호화 된 MIME을 포함하는 UAS에서 요청을 받았습니다.
   수령인이 소유하지 않거나 제공하지 않을 단체
   적절한 해독 키. 이 응답은 단일 본문을 가질 수있다
   암호화에 사용되어야하는 적절한 공개 키를 포함
   이 UA로 전송 된 MIME 본문. 이 응답의 사용법에 대한 세부 정보
   코드는 23.2 절에서 찾을 수 있습니다.

21.5 서버 장애 5xx

   5xx 응답은 서버 자체가 가지고있을 때 주어진 실패 응답입니다.
   잘못했다.

21.5.1 500 서버 내부 오류

   서버가 예기치 않은 조건을 만났습니다.
   요청을 이행합니다. 클라이언트는 특정 오류를 표시 할 수 있습니다 (MAY).
   몇 초 후에 요청을 재 시도 할 수있다.

   조건이 임시라면, 서버는
   클라이언트는 Retry-After 헤더 필드를 사용하여 요청을 재 시도 할 수 있습니다.



Rosenberg, et. al. 표준은 궤 [196]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.5.2 501 구현되지 않음

   서버는 해당 기능을 수행하는 데 필요한 기능을 지원하지 않습니다.
   의뢰. UAS가 지원하지 않을 때 적절한 응답입니다.
   요청 방법을 인식하고 그것을 지원할 능력이 없다.
   임의의 사용자. (프록시는 방법에 관계없이 모든 요청을 전달합니다.)

   405 (Method Not Allowed)는 서버가
   요청 메소드를 인식하지만 해당 메소드가 허용되지 않거나
   지원.

21.5.3 502 잘못된 게이트웨이

   서버가 게이트웨이 또는 프록시로 작동하는 동안 잘못된
   시도에서 액세스 한 다운 스트림 서버의 응답
   요청을 이행하십시오.

21.5.4 503 서비스를 사용할 수 없습니다.

   서버가 일시적으로 요청을 처리 할 수 ​​없습니다.
   일시적인 과부하 또는 서버 유지 관리 서버 MAY
   Retry-After에서 클라이언트가 요청을 재 시도해야하는 시점을 나타냅니다.
   헤더 필드. Retry-After가 주어지지 않으면, 클라이언트는 다음과 같이 행동해야한다.
   500 (서버 내부 오류) 응답을 받았습니다.

   503 (서비스를 사용할 수 없음)을 수신하는 클라이언트 (프록시 또는 UAC)는
   요청을 대체 서버로 전달하려고 시도합니다. 그것을해서는 안된다.
   지정된 기간 동안 해당 서버에 대한 다른 요청을 전달합니다.
   Retry-After 헤더 필드에 존재할 경우.

   서버는 연결을 거절하거나 요청을 삭제할 수 있습니다
   503 (Service Unavailable)으로 응답 함.

21.5.5 504 서버 시간 초과

   서버가 외부 서버에서 적시에 응답을받지 못했습니다.
   요청을 처리하려고 시도 할 때 액세스했습니다. 408 (요청
   제한 시간 내에 응답이 없으면 대신 시간 제한)을 사용해야합니다.
   업스트림에서 Expires 헤더 필드에 지정된 기간
   섬기는 사람.

21.5.6 505 버전이 지원되지 않음

   서버가 SIP 프로토콜을 지원하지 않거나 지원을 거부합니다.
   요청에 사용 된 버전 서버가
   동일한 요청을 사용하여 요청을 완료 할 수 없거나 원치 않는 경우
   이 오류 메시지 이외의 클라이언트로 주 버전.




Rosenberg, et. al. 표준 트랙 [Page 191]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


21.5.7 513 메시지가 너무 큼

   서버가 메시지 길이 이후로 요청을 처리 할 수 ​​없습니다.
   그것의 능력을 초과했다.

21.6 글로벌 실패 6xx

   6xx 응답은 서버에 대한 최종 정보가 있음을 나타냅니다.
   특정 사용자, 예를 들어
   요청 URI.

어디서나 바쁜 21.6.1 600

   피 호출자의 최종 시스템에 성공적으로 연결되었지만 피사체는
   통화 중이며 통화 중입니다. 응답
   Retry-After 헤더 필드를 호출 할 때 더 좋은 시간을 나타낼 수 있습니다.
   피 호출자가 그 이유를 밝히지 않으려면
   호출 수신자는 대신 상태 코드 603 (거부)을 사용합니다. 이 상태
   클라이언트가 다른 끝점이 없다는 것을 알고있는 경우에만 응답이 반환됩니다.
   (예 : 음성 메일 시스템)가 요청에 응답합니다. 그렇지 않으면,
   486 (여기에서 바쁜)이 반환되어야합니다.

21.6.2 603 거부

   수신자의 기기에 성공적으로 접속했지만 사용자
   명시 적으로 참여하기를 원하지 않거나 참여할 수 없습니다. 응답 MAY
   Retry-After 헤더 필드를 호출하는 것이 더 좋습니다. 이
   상태 응답은 클라이언트가 다른 클라이언트가 없다는 것을 알고있는 경우에만 리턴됩니다.
   엔드 포인트가 요청에 응답합니다.

21.6.3 604가 어디에도 존재하지 않음

   서버는 사용자가 다음과 같이 표시 한 신뢰할 수있는 정보를 가지고 있습니다.
   Request-URI가 어디에도 존재하지 않습니다.

21.6.4 606 불가

   사용자의 상담원이 성공적으로 연락되었지만
   요청 된 미디어, 대역폭 또는
   주소 스타일이 용납되지 않았습니다.

   606 (Not Acceptable) 응답은 사용자가
   통신하지만 설명 된 세션을 적절히 지원할 수는 없습니다.
   606 (Not Acceptable) 응답은 다음과 같은 이유 목록을 포함 할 수 있습니다.
   설명 된 세션을 사용할 수없는 이유를 설명하는 경고 헤더 필드
   지원. 경고 이유 코드는 20.43 절에 나와 있습니다.





Rosenberg, et. al. 표준은 궤 [192 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   미디어 기능에 대한 설명이 포함 된 메시지 본문이있을 수 있습니다
   응답에 표시되며 Accept에 따라 형식이 지정됩니다.
   INVITE의 헤더 필드 (존재하지 않을 경우 응용 프로그램 / sdp),
   OPTIONS 요청에 대한 200 (OK) 응답의 메시지 본문과 동일합니다.

   협상이 자주 필요하지 않으며,
   새로운 사용자가 이미 존재하는 회의에 참가하도록 초대 받고 있으며,
   협상이 불가능할 수도 있습니다. 초대장까지입니다.
   개시자가 606 (Not Acceptable)
   응답.

   이 상태 응답은 클라이언트가
   다른 엔드 포인트가 요청에 응답합니다.

22 HTTP 인증 사용

   SIP는 다음과 같은 이유로 상태 기반의 챌린지 기반 메커니즘을 제공합니다.
   HTTP의 인증을 기반으로하는 인증. 언제든지
   프록시 서버 또는 UA가 요청을 수신 함 (예외
   22.1 절에서 주어진다), 요청의 개시 자에게 도전 할 수있다 (MAY)
   그것의 신원의 보증을 제공하기 위하여. 발신자가
   확인 된 경우, 요청의 수신자는 요청의 수신 여부를 확인해야한다.
   이 사용자는 문제의 요청을 할 권한이 없습니다. 아니
   이 문서에서는 권한 부여 시스템을 권장하거나 논의합니다.

   이 섹션에서 설명하는 "다이제스트"인증 메커니즘
   없이 메시지 인증 및 재생 보호 기능을 제공합니다.
   메시지 무결성 또는 기밀성. 위의 보호 조치
   다이제스트가 제공하는 것 이외의 다른 것들은 활성화되지 않도록해야합니다.
   공격자가 SIP 요청 및 응답을 수정하지 못하게합니다.

   약한 보안으로 인해 "기본"
   인증이 더 이상 사용되지 않습니다. 서버는 받아 들여 선 안된다
   "기본"권한 부여 체계를 사용하는 자격 증명 및 서버
   반드시 "Basic"으로 도전해서는 안됩니다. 이것은 RFC 2543의 변경 사항입니다.

22.1 프레임 워크

   SIP 인증을위한 프레임 워크는 HTTP의 프레임 워크와 매우 유사합니다.
   (RFC 2617 [17]). 특히 auth-scheme, auth-param,
   도전, 영역, 영역 - 값 및 자격 증명은 동일합니다 (비록
   "기본"을 스키마로 사용하는 것은 허용되지 않습니다). SIP에서 UAS
   401 (Unauthorized) 응답을 사용하여
   UAC. 또한 등록 기관과 리디렉션 서버는
   401 (인증되지 않은) 인증에 대한 응답이지만 프록시는 반드시
   NOT, 대신 407 (프록시 인증 필요)





Rosenberg, et. al. 표준 트랙 [Page 193]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   응답. Proxy-Authenticate를 포함하기위한 요구 사항,
   프록시 권한 부여, WWW 인증 및 권한 부여
   다양한 메시지는 RFC 2617 [17]에 설명 된 것과 동일합니다.

   SIP에는 정식 루트 URL이라는 개념이 없으므로
   보호 공간의 개념은 SIP에서 다르게 해석됩니다. 그만큼
   영역 문자열 만 보호 도메인을 정의합니다. 이것은 변화이다.
   Request-URI와 영역이 함께있는 RFC 2543
   보호 도메인을 정의했습니다.

      보호 도메인의 이전 정의는 어느 정도의 금액을 발생 시켰습니다.
      UAC에서 보낸 Request-URI와
      도전적인 서버가 수신 한 요청 URI는 다를 수 있지만,
      실제로 Request-URI의 최종 형태는 다음에 알려지지 않을 수 있습니다.
      UAC 또한, 이전의 정의는 존재에 의존했다.
      Request-URI에 SIP URI가 포함되어 있으며 대체 URI를 배제하는 것으로 보입니다.
      URI 체계 (예 : tel URL).

   인증 할 사용자 에이전트 또는 프록시 서버 운영자
   수신 된 요청은 다음 지침을 준수해야합니다.
   서버에 대한 영역 문자열 작성 :

      o 영역 문자열은 반드시 전역 적으로 유일해야합니다. 권장 사항
         영역 문자열은 호스트 이름 또는 도메인 이름을 포함하며
         RFC 2617의 섹션 3.2.1 [17]에서 권장 사항.

      o 영역 문자열은 다음과 같은 사람이 읽을 수있는 식별자를 제시해야합니다 (SHOULD).
         사용자에게 표시 될 수 있습니다.

   예 :

      INVITE SIP : bob@biloxi.com SIP / 2.0
      승인 : 다이제스트 영역 = "biloxi.com", <...>

   일반적으로 SIP 인증은 특정 영역에 대해 의미가 있습니다.
   보호 도메인. 따라서 다이제스트 인증의 경우
   보호 도메인에는 고유 한 사용자 이름 및 비밀번호 세트가 있습니다. 만약
   서버는 특정 요청에 대해 인증을 필요로하지 않습니다.
   패스워드가없는 기본 사용자 명 "anonymous"를 받아 들일 수있다.
   ( ""의 암호). 마찬가지로 많은 사용자를 나타내는 UAC
   PSTN 게이트웨이는 자신의 장치 별 사용자 이름과
   특정 사용자의 계정이 아닌 해당 사용자의 영역에 대한 암호

   서버가 대부분의 SIP 요청에 정당하게 도전 할 수는 있지만
   이 문서에서 정의한 두 가지 요청은 특수
   인증 처리 : ACK 및 CANCEL.





Rosenberg, et. al. 표준 트랙 [Page 194]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   응답을 사용하여 값을 전달하는 인증 체계에서
   nonces (다이제스트 등)를 계산할 때 사용되는
   ACK를 포함하여 응답을받지 않는 요청. 이러한 이유로,
   서버가 수락 한 INVITE의 자격 증명은
   해당 서버에서 ACK를 받아들입니다. ACK 메시지를 생성하는 UAC
   모든 승인 및 프록시 인증을 복제합니다.
   ACK가 나타나는 INVITE에 나타난 헤더 필드 값
   일치합니다. 서버는 ACK에 도전하려고 시도해서는 안된다.

   CANCEL 메소드가 응답 (2xx)을 취하더라도, 서버는 반드시 응답해야합니다
   이러한 요청은 CANCEL 요청에 도전 할 수 없으므로 시도하지 마십시오.
   다시 제출하십시오. 일반적으로 CANCEL 요청은 a에 의해 받아 들여 져야한다.
   서버가 요청을 보낸 동일한 홉에서 온 경우
   취소됨 (일종의 전송 또는 네트워크 계층
   26.2.1 절에 설명 된대로 보안 연결이 설정됩니다.

   UAC가 챌린지를 받으면 사용자에게 렌더링해야합니다.
   챌린지에서 "영역"매개 변수의 내용 (
   WWW-Authenticate 헤더 필드 또는 Proxy-Authenticate 헤더
   필드) UAC 장치가 아직 자격 증명을 알지 못하는 경우
   문제의 영역. UA를 사전 구성하는 서비스 공급자
   그 영역에 대한 자격 증명을 가진 사용자는 사용자가
   이 영역에 대한 자신의 자격 증명을 제시 할 기회가있다.
   사전 구성된 장치에서 문제가 발생했을 때.

   마지막으로, UAC가
   적절한 영역과 관련하여,
   자격 증명이 더 이상 유효하지 않거나 까다로운 서버
   어떤 이유에서든이 자격 증명을 수락하지 않습니다 (특히
   암호가없는 "익명"이 제출 될 때). 이 인스턴스에서는
   서버는 챌린지를 반복 할 수도 있고, 403
   금지됨. UAC는 자격 증명으로 요청을 다시 시도하면 안됩니다
   (요청이 재 시도 될 수는 있지만
   nonce는 오래되었습니다.)

22.2 사용자 대 사용자 인증

   UAS가 UAC로부터 요청을 받으면 UAS는 인증 할 수있다
   요청 전에 처리자가 처리됩니다. 자격 증명이없는 경우
   (Authorization 헤더 필드에 있음)가 요청에 제공되면
   UAS는 발신자가 거부함으로써 자격 증명을 제공하도록 요청할 수 있습니다.
   401 (Unauthorized) 상태 코드와 함께 요청.

   WWW-Authenticate 응답 헤더 필드는 반드시 401에 포함되어야한다.
   (승인되지 않은) 응답 메시지. 입력란 값은 다음과 같이 구성됩니다.
   인증 체계 (들)을 나타내는 적어도 하나의 챌린지 및
   영역에 적용 할 수있는 매개 변수.




Rosenberg, et. al. 표준 트랙 [Page 195]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   401 챌린지에서 WWW-Authenticate 헤더 필드의 예
   :

      WWW- 인증 : 다이제스트
              영역 = "biloxi.com",
              qop = "auth, auth-int",
              nonce = "dcd98b7102dd2f0e8b11d0f600bfb0c093",
              불투명 "5ccc069c403ebaf9f0171e9517f40e41"

   원래의 UAC가 401 (Unauthorized)을 수신하면 SHOULD,
   가능하면 적절한 신임장으로 요청을 다시 시작하십시오.
   UAC는 이전 사용자로부터 입력을 요구할 수 있습니다.
   진행. 인증 자격 증명이 제공되면
   (사용자가 직접 또는 내부 키링에서 발견)
   UA는 To 헤더의 주어진 값에 대한 자격 증명을 캐시해야합니다 (SHAULD).
   필드 및 "영역"을 검색하고 다음에이 값을 다시 사용하려고 시도합니다
   해당 목적지에 대한 요청. UA는 어떤 식 으로든 자격 증명을 캐시 할 수 있습니다
   그들은 원합니다.

   영역에 대한 자격 증명을 찾을 수없는 경우 UAC는 다음을 시도 할 수 있습니다.
   사용자 이름이 "anonymous"이고 비밀번호가없는 요청을 다시 시도하십시오 (a
   암호는 "").

   자격 증명이 있으면 UA를 원하는 모든 UA
   UAS 나 레지스트라로 인증합니다.
   401 (Unauthorized) 응답을받은 후 필히 -해야 할 수도 있습니다
   요청과 함께 Authorization 헤더 필드를 포함시켜야합니다. 그만큼
   권한 부여 필드 값은
   자원의 영역에 대한 UA의 인증 정보
   지원 요청에 필요한 매개 변수뿐만 아니라
   인증 및 재생 보호.

   Authorization 헤더 필드의 예는 다음과 같습니다.

      인증 : Digest username = "bob",
              영역 = "biloxi.com",
              nonce = "dcd98b7102dd2f0e8b11d0f600bfb0c093",
              uri = "sip : bob@biloxi.com",
              qop = auth,
              nc = 00000001,
              cnonce = "0a4f113b",
              응답 = "6629fae49393a05397450978507c4ef1",
              불투명 "5ccc069c403ebaf9f0171e9517f40e41"

   UAC가 인증서를받은 후 자격 증명으로 요청을 다시 제출하면
   401 (인증되지 않음) 또는 407 (프록시 인증 필요) 응답,
   그것은 정상적으로 CSeq 헤더 필드 값을 증가시켜야한다.
   업데이트 된 요청을 보낼 때



Rosenberg, et. al. 표준 트랙 [Page 196]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


22.3 프록시 대 사용자 인증

   마찬가지로 UAC가 프록시 서버에 요청을 보내면 프록시
   서버는 요청이 있기 전에 송신자를 인증 할 수있다.
   처리됨. 자격 증명이없는 경우 (Proxy-Authorization 헤더에 있음)
   필드)가 요청에 제공되면 프록시는
   보낸 사람이 요청을 거부하여 자격 증명을 제공하도록 407
   (프록시 인증 필요) 상태 코드. 프록시는 반드시 입력해야합니다.
   407 (Proxy Authentication Required) 메시지가 Proxy-
   프록시에 적용 할 수있는 헤더 필드 값을 인증합니다.
   요청한 자원.

   Proxy-Authenticate 및 Proxy-Authorization 병렬 사용
   하나의 차이점을 가지고 [17]에 설명되어있다. 프록시는 값을 추가해서는 안됩니다
   Proxy-Authorization 헤더 필드에 추가합니다. 모두 407 (프록시
   인증 필요) 응답은 반드시 업스트림으로
   다른 응답에 대한 절차를 따르는 UAC. 그것은
   Proxy-Authorization 헤더 필드를 추가하는 UAC의 책임
   프록시의 영역에 대한 자격 증명을 포함하는 값
   인증을 요청했습니다.

      프록시가 요청을 다시 제출하여 프록시 인증을 추가하는 경우
      헤더 필드 값을 변경하려면 새로운 CSeq를 증가시켜야합니다.
      의뢰. 그러나 이로 인해 UAC가
      CSEq로서 UAS로부터의 응답을 폐기하라는 원래 요청
      가치는 다를 것입니다.

   원래 UAC가 407 (프록시 인증
   필수적), 가능하다면 요청을 다시 보낸다.
   적절한 신임장. 그것은 동일한 절차를 따라야한다.
   응답을 위해 위에 주어진 "realm"매개 변수의 표시
   ~ 401

   영역에 대한 자격 증명을 찾을 수없는 경우 UAC는 다음을 시도 할 수 있습니다.
   사용자 이름이 "anonymous"이고 비밀번호가없는 요청을 다시 시도하십시오 (a
   암호는 "").

   또한 UAC는 재사용 된 웹 사이트에 사용 된 자격 증명을 캐시해야한다 (SHAULD).
   의뢰.

   다음 규칙은 프록시 자격 증명 캐싱에 권장됩니다.

   UA가 401/407에서 Proxy-Authenticate 헤더 필드 값을 수신하면
   특정 Call-ID가있는 요청에 대한 응답
   모든 후속 요청에 해당 영역에 대한 자격 증명 통합
   같은 Call-ID를 포함하고 있습니다. 이러한 자격 증명은 캐시해서는 안됩니다
   대화 상자에서; 그러나 UA가 해당 영역으로 구성된 경우
   로컬 아웃 바운드 프록시가 존재하면 UA MAY 캐시



Rosenberg, et. al. 표준 트랙 [197 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   대화 상자에서 해당 영역에 대한 자격 증명. 이것이 의미하는 바입니다.
   대화 상자의 향후 요청에
   Route 헤더 경로를 따라 임의의 프록시에 의해 필요합니다.

   프록시 서버에 자신을 인증하고자하는 모든 UA -
   일반적으로, 그러나 반드시 그런 것은 아니지만, 407 (Proxy
   인증 필요) 응답 - Proxy-
   요청과 함께 권한 부여 헤더 필드 값. 프록시 -
   인증 요청 헤더 필드는 클라이언트가
   자체 (또는 사용자)를 인증이 필요한 프록시로 그만큼
   Proxy-Authorization 헤더 필드 값은 자격 증명으로 구성됩니다.
   프록시 용 UA의 인증 정보를 포함하는
   및 / 또는 요청되는 리소스의 영역.

   프록시 인증 헤더 필드 값은 프록시에만 적용됩니다.
   그 영역은 "영역"매개 변수에서 식별됩니다 (이 프록시는
   이전에 프록시 인증을 사용하여 인증을 요구했습니다.
   들). 여러 프록시가 체인에서 사용될 때 Proxy-
   인증 헤더 필드 값은 프록시에 의해 소비되어서는 안된다.
   해당 영역이 해당 영역에 지정된 "영역"매개 변수와 일치하지 않습니다.
   값.

   영역을 지원하지 않는 인증 체계가
   Proxy-Authorization 헤더 필드에서 사용되는 프록시 서버
   모든 Proxy-Authorization 헤더 필드 값을 다음과 같이 구문 분석하려고 시도합니다.
   그들 중 하나가 프록시 서버가 고려하는 것을 가지고 있는지 결정하십시오.
   유효한 자격증 명. 이것은 잠재적으로 매우 시간이 걸리기 때문에,
   대규모 네트워크에서 소모하는 프록시 서버는
   프록시 인증에서 영역을 지원하는 인증 체계
   헤더 필드.

   요청이 포크 된 경우 (16.7 절에서 설명), 다양한 프록시
   서버 및 / 또는 UA가 UAC에 도전 할 수 있습니다. 이 경우,
   포크 프록시 서버는 이러한 문제를 종합해야합니다.
   하나의 응답으로 각 WWW- 인증 및 프록시 인증
   분기 된 요청에 대한 응답으로 수신 된 값은
   단 하나의 응답은 포크 프록시에 의해 UA에 보내진다; 그만큼
   이러한 헤더 필드 값의 순서는 중요하지 않습니다.

      프록시 서버가 요청에 대한 응답으로 챌린지를 발행 할 때,
      UAC가 요청을 재 시도 할 때까지 요청을 프록시하지 않습니다.
      유효한 자격 증명이있는 요청. 포크 프록시는
      요구하는 여러 프록시 서버에 동시에 요청
      인증은 각각 요청을 전달하지 않습니다.
      원래 UAC가 자신의
      각각의 영역. UAC가 자격 증명을 제공하지 않는 경우





Rosenberg, et. al. 표준 트랙 [224 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      각 도전 과제를 발행 한 프록시 서버는
      목적지 사용자가있을 수있는 UA로 요청을 전달하지 않는다.
      따라서 포크의 덕목은 크게 잃어버린다.

   401 (Unauthorized) 또는에 대한 응답으로 요청을 다시 제출할 때
   407 (프록시 인증 필요)
   도전 과제에서 UAC는 각 WWW-
   각 프록시 별 인증 값과 프록시 인증 값을 인증합니다.
   UAC가 자격 증명을 제공하려는 값을 인증합니다.
   위에서 언급 한 것처럼 요청에있는 여러 자격 증명이 있어야합니다 (SHOULD).
   "영역"매개 변수로 구분됩니다.

   동일한 영역과 관련된 여러 가지 도전이 가능합니다.
   동일한 401 (인증되지 않음) 또는 407 (프록시 인증
   필수). 예를 들어, 여러 개의 프록시가있는 경우
   공통 영역을 사용하는 동일한 관리 도메인에 도달했습니다.
   forking 요청에 의해. 요청을 재 시도 할 때, 따라서 UAC는
   권한 부여 또는 프록시 인증에서 다중 자격 증명 제공
   동일한 "영역"매개 변수 값을 갖는 헤더 필드 같은
   동일한 영역에 대해 자격 증명을 사용해야합니다 (SHOULD).

22.4 다이제스트 인증 방식

   이 섹션에서는 수정 내용을 설명합니다.
명확한 설명이 필요하다.
   HTTP 다이제스트 인증 방식을 SIP에 적용합니다. SIP
   scheme 사용은 HTTP와 거의 동일하다 [17].

   RFC 2543은 RFC 2069 [39]에 정의 된 HTTP Digest를 기반으로하기 때문에,
   RFC 2617을 지원하는 SIP 서버는 그것이 거꾸로 있는지 확인해야합니다
   RFC 2069와 호환됩니다. 이에 대한 절차
   호환성은 RFC 2617에 명시되어 있습니다. 그러나 SIP
   서버는 기본 인증을 수락하거나 요청해서는 안됩니다.

   다이제스트 인증에 대한 규칙은 [17]에 정의 된 규칙을 따릅니다.
   "HTTP / 1.1"을 다음과 같이 "SIP / 2.0"으로 대체했습니다
   차이 :

      1. 챌린지에 포함 된 URI에는 다음과 같은 BNF가 있습니다.

          URI = SIP-URI / SIPS-URI

      2. RFC 2617의 BNF는 'uri'매개 변수가 잘못되었습니다.
          다이제스트의 Authorization 헤더 필드에 대한 설명








Rosenberg, et. al. 표준 트랙 [226 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


          인증은 따옴표로 묶지 않습니다. (그만큼
          RFC 2617의 섹션 3.5에있는 예는 정확합니다.) SIP의 경우
          'uri'는 따옴표로 묶어야합니다.

      3. digest-uri-value에 대한 BNF는 다음과 같습니다.

          digest-uri-value = 요청 URI; 제 25 절에 정의 된대로

      4. Etag를 기반으로 한 nonce를 선택하는 예제 프로시 저는
          SIP에서는 작동하지 않습니다.

      5. 캐시 작동과 관련한 RFC 2617 [17]의 텍스트는
          SIP에 신청하십시오.

      6. RFC 2617 [17]에서는 서버가
          요청 헤더와 Authorization 헤더에 포함 된 URI
          필드가 동일한 리소스를 가리 킵니다. SIP 컨텍스트에서이 두
          URI는 다른 사용자에게 전달할 수 있습니다.
          프록시. 따라서 SIP에서 서버는
          Authorization 헤더 필드 값의 Request-URI
          서버가 수락하고자하는 사용자에 해당
          전달 된 요청 또는 직접 요청은 아니지만 반드시
          두 필드가 같지 않으면 실패.

      7.에 대한 A2 값의 계산에 대한 설명
          다이제스트 인증에서 메시지 무결성 보증
          스킴에서, 구현자는 엔터티 본문이
          비어 있음 (즉, SIP 메시지에 본문이없는 경우) 해시
          엔티티 본문의 MD5 해시가 비어 있음을 확인합니다.
          문자열 또는 :

             H (entity-body) = MD5 ( "") =
          "d41d8cd98f00b204e9800998ecf8427e"

      8. RFC 2617은 cnonce 값이
          권한 부여 (및 확장하여 프록시 권한 부여) 헤더
          qop 지시문을 보내지 않은 경우 필드. 따라서,
          cnonce에 대한 의존성을 갖는 알고리즘
          "MD5-Sess") qop 지시문을 보내야합니다. 사용
          "qop"매개 변수는 목적을 위해 RFC 2617에서 선택 사항입니다.
          RFC 2069와의 하위 호환성; RFC 2543이
          RFC 2069에 기반하여 "qop"매개 변수는 유감스럽게도
          클라이언트 및 서버가 수신하려면 선택적으로 유지하십시오. 하나,
          서버는 항상 WWW-Authenticate에서 "qop"매개 변수를 보내야합니다
          및 Proxy-Authenticate 헤더 필드 값 클라이언트
          챌린지 헤더 필드에서 "qop"매개 변수를 받으면
          모든 결과 인증에 "qop"매개 변수를 보내야합니다
          헤더 필드.



Rosenberg, et. al. 표준 트랙 [쪽 200]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   RFC 2543은 인증 정보 헤더 필드의 사용을 허용하지 않았습니다.
   (RFC 2069를 효과적으로 사용함). 그러나 이제이 기능의 사용을 허용합니다.
   헤더 필드는 본문에 대한 무결성 검사를 제공하므로
   상호 인증을 제공합니다. RFC 2617 [17]은
   요청에서 qop 속성을 사용하여 이전 버전과의 호환성.
   이러한 메커니즘은 서버가 클라이언트가
   에서 지정되지 않은 RFC 2617의 새로운 메커니즘을 지원합니다.
   RFC 2069.

23 S / MIME

   SIP 메시지는 MIME 본문을 전달하며 MIME 표준에는 다음이 포함됩니다.
   무결성과 보안 성을 보장하기 위해 MIME 내용을 보호하는 메커니즘
   기밀 유지 ( 'multipart / signed'및
   'application / pkcs7-mime'MIME 유형은 RFC 1847 [22], RFC 2630 [23]을 참조하십시오.
   및 RFC 2633 [24]). 그러나 구현자는
   드문 네트워크 중개자 (일반적인 프록시 서버가 아님) 일 수 있습니다.
   SIP 메시지의 본문보기 또는 수정에 의존합니다 (특히
   SDP), 안전한 MIME은 이러한 종류의 중개자를 막을 수 있습니다
   기능에서.

      이는 특히 특정 유형의 방화벽에 적용됩니다.

      헤더 필드와 본문을 암호화하기위한 PGP 메커니즘
      RFC 2543에 설명 된 SIP 메시지는 더 이상 사용되지 않습니다.

23.1 S / MIME 인증서

   최종 사용자를 식별하는 데 사용되는 인증서
   S / MIME의 목적은 서버에서 사용하는 것과는 중요한 차이가 있습니다
   존경 - 소유주의 신원을 주장하는 것보다
   특정 호스트 이름에 해당하면이 인증서는
   소유자는 최종 사용자 주소로 식별됩니다. 이 주소는
   "userinfo" "@"와 "domainname"의 연결로 구성됩니다.
   SIP 또는 SIPS URI의 일부 (즉,
   양식 "bob@biloxi.com"), 가장 일반적으로 사용자의
   주소 기록.

   이 인증서는 또한 사용되는 키와 연관됩니다.
   SIP 메시지 본문에 서명하거나 암호화 할 수 있습니다. 시체는
   보낸 사람의 개인 키 (공개 키를 포함 할 수 있음)
   메시지), 그러나 시체는 공개 키로 암호화됩니다
   의도 한 수신자의 분명히 발신자는
   수신자의 공개 키를 미리 암호화하여 암호화
   메시지 본문. 공개 키는 가상의 UA 내에 저장 될 수 있습니다.
   열쇠 고리.





Rosenberg, et. al. 표준 트랙 [Page 201]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   S / MIME을 지원하는 각 사용자 에이전트는 키링을 포함해야합니다
   특히 최종 사용자의 인증서에 사용됩니다. 이 열쇠 고리는지도에 표시해야합니다.
   기록 주소와 해당 인증서 사이. 위에
   사용자는 인증서를 채울 때 동일한 인증서를 사용해야합니다.
   동일한 발신지 헤더 (From 헤더 필드)
   주소 기록.

   최종 사용자 인증서의 존재 여부에 따른 모든 메커니즘
   사실상 통합되지 않았다는 점에서 심각하게 제한되어있다.
   최종 사용자 응용 프로그램에 대한 인증서를 제공합니다.
   그러나 사용자는 알려진 공개 인증서를 받아야합니다
   인증 기관. 대안으로서, 사용자는 자기 -
   서명 된 인증서. 자체 서명 인증서의 의미
   26.4.2 절에서 더 자세히 살펴 본다. 구현시에도 사용할 수 있습니다.
   이전 트러스트가 배포 된 사전 구성된 인증서
   모든 SIP 엔티티간에 관계가 존재합니다.

   최종 사용자 인증서를 획득하는 문제 이상으로,
   배포하는 잘 알려진 중앙 집중식 디렉토리가 거의 없습니다.
   최종 사용자 인증서. 그러나 인증서 소지자는
   적절한 공개 디렉토리에 인증서를 게시하십시오.
   유사하게, UAC는 (수동 또는
   공개 디렉토리에서 발견 된 인증서
   SIP 요청의 대상 URI에 해당하는

23.2 S / MIME 키 교환

   SIP 자체는 또한 공개 키를 배포하는 수단으로 사용될 수 있습니다.
   다음과 같은 방식으로

   CMS SignedData 메시지가 SIP 용 S / MIME에서 사용될 때마다
   필요한 공개 키가있는 인증서를 포함해야합니다.
   서명을 확인하십시오.

   UAC가 S / MIME 본문을 포함하는 요청을 보내면
   대화 상자의 컨텍스트 외부에서 비 -INVITE 요청을 보내거나
   대화 상자에서 UAC는 본문을 S / MIME로 구조해야합니다
   'multipart / signed'CMS SignedData 본문입니다. 원하는 CMS 서비스
   EnvelopedData이며 (대상 사용자의 공개 키를 알고있는 경우),
   UAC는 a에서 캡슐화 된 EnvelopedData 메시지를 전송해야한다.
   SignedData 메세지

   UAS가 S / MIME CMS 본문이 포함 된 요청을 받으면
   인증서를 포함하는 경우, UAS는 먼저
   가능한 경우, 사용 가능한 루트 인증서로 인증서
   인증 기관. 또한 UAS는 주제를 결정해야한다
   인증서 (S / MIME의 경우 SubjectAltName에
   적절한 신원)을 확인하고이 값을 From 헤더 필드와 비교하십시오



Rosenberg, et. al. 표준 트랙 [Page 202]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   요청의 인증서를 확인할 수 없으면 인증서를 확인할 수 없습니다.
   자체 서명 또는 알려진 기관의 서명이없는 경우 또는 검증이 가능한 경우
   제목이 From 헤더 필드와 일치하지 않습니다.
   UAS는 사용자에게 자신의 상태를 알리십시오 (MUST).
   인증서 (인증서의 제목, 서명자,
   및 모든 주요 지문 정보) 및 명시 적 허가 요청
   계속하기 전에. 인증서가 성공적으로 확인되고
   인증서의 제목은 From 헤더 필드에 해당합니다.
   SIP 요청의 (사용자가 통지 한 후) 명시 적으로
   인증서의 사용을 허가하고, UAS는 이것을 더해야한다.
   주소록에 의해 색인 된 로컬 키링에 대한 인증서
   증명서 소지자

   UAS가 응답하는 S / MIME 본문이 포함 된 응답을 보내면
   대화 상자의 첫 번째 요청 또는 비 초대 요청에 대한 응답
   대화 상자의 컨텍스트 외부에서 UAS는 본문을 다음과 같이 구조화해야합니다.
   S / MIME 'multipart / signed'CMS SignedData 본문입니다. 원하는 CMS
   서비스가 EnvelopedData 인 경우, UAS는 EnvelopedData
   SignedData 메세지 내에 캡슐화 된 메세지

   UAC가 S / MIME CMS 본문이 포함 된 응답을 받으면
   인증서를 포함하는 경우 UAC는 먼저
   가능하면 적절한 루트 인증서로 인증서를 발급 받아야합니다. 그만큼
   또한 UAC는 인증서의 제목을 결정하고
   이 값을 응답의받는 사람 필드에; 두 사람이
   잘 다르고, 이것이 반드시 반드시
   보안 침해. 인증서가 있기 때문에 인증서를 확인할 수없는 경우
   자체 서명 또는 알려진 기관의 서명이없는 경우 UAC는
   사용자는 인증서 상태 (해당
   인증서, 서명자 및 키 지문 정보) 및
   계속하기 전에 명시 적 권한을 요청하십시오. 인증서가있는 경우
   성공적으로 확인되었으며 인증서의 제목
   응답의 To 헤더 필드에 해당하거나 사용자
   (통지 후) 명시 적으로
   UAC는이 인증서를 로컬 키링에 추가해야하며,
   인증서 소지자의 주소 기록에 의해 색인됩니다.
   UAC가 자신의 인증서를 UAS에 전송하지 않은 경우
   이전 거래의 경우 CMS SignedData 본문을 사용해야합니다.
   다음 요청 또는 응답.

   장래에 UA가 요청 또는 응답을 받으면
   그 열쇠 고리 내의 값에 대응하는 From 헤더 필드를 포함 해,
   UA는이 메시지에서 제공된 인증서를
   열쇠 고리 내의 기존의 증명서 불일치가있는 경우,
   UA는 사용자에게 인증서 변경을 통보해야한다.
   (잠재적으로 이것이 잠재적 인 보안임을 나타내는 관점에서
   위반)하고 계속하기 전에 사용자의 허가를 얻으십시오.




Rosenberg, et. al. 표준 트랙 [Page 203]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   신호 처리. 사용자가이 인증서를 인증하면
   이전 값과 함께 키링에 추가해야합니다.
   이 주소 기록.

   그러나이 키 교환 메커니즘은
   자체 서명 된 인증서가있을 때 키의 안전한 교환을 보장하고,
   또는 모호한 기관이 서명 한 인증서가 사용됩니다.
   잘 알려진 공격에 취약합니다. 저자들의 의견에 따르면,
   그러나 제공하는 보안은
   아무것도; 실제로 널리 사용되는 SSH 응용 프로그램과 비교할 수 있습니다.
   이러한 제한 사항은 26.4.2 절에서 더 자세히 설명합니다.

   UA가 공개로 암호화 된 S / MIME 본문을 수신하는 경우
   수신자에게 키를 알지 못하면, 493
   (해독 할 수 없음) 응답. 이 응답은 유효한 응답을 포함해야한다.
   응답자의 인증서 (가능하면
   To 헤더 필드에 주어진 레코드의 주소
   요청)을 '인증서 전용' "smime-type"
   매개 변수.

   인증서없이 발송 된 493 건 (미해결)은
   응답자는 S / MIME 암호화 된 메시지를 사용할 수 없거나 사용하지 않을 것이며,
   그들은 여전히 ​​S / MIME 서명을 지원할 수 있습니다.

   S / MIME가 포함 된 요청을받는 사용자 에이전트
   선택 사항이 아닌 본문 (Content-Disposition 헤더 포함)
   "요구"의 "취급"매개 변수)은 반드시
   415 MIME 유형이 지원되지 않는 경우 지원되지 않는 미디어 유형 응답
   이해했다. S / MIME을 사용할 때 이러한 응답을받는 사용자 에이전트
   원격 장치가 사용자에게 알려주지 않는다는 것을 사용자에게 통지해야합니다 (SHOULD).
   S / MIME을 지원하며, 이후에 요청을 재전송 할 수 있습니다.
   적절한 경우 S / MIME; 그러나이 415 응답은
   다운 그레이드 공격.

   사용자 에이전트가 요청에서 S / MIME 본문을 전송하지만
   응답이 보안되지 않은 MIME 본문을 포함하면 UAC
   세션을 보호 할 수 없다는 것을 사용자에게 알려줘야합니다 (SHOULD).
   그러나 S / MIME을 지원하는 사용자 에이전트가
   안전하지 않은 몸체, 그것은 확실한 몸체로 반응해서는 안되지만 만약
   보낸 사람의 S / MIME을 예상합니다 (예 : 보낸 사람의
   From 헤더 필드 값은 키 체인의 ID에 해당합니다.)
   UAS는 세션을 보안 할 수 없다는 것을 사용자에게 통지해야한다.

   이전 텍스트에서 발생하는 여러 가지 조건이
   변칙적 인 인증서 관리가있을 때의 사용자 통지
   이벤트가 발생합니다. 사용자는이 아래에서해야 할 일을 잘 물어볼 수도 있습니다.
   상황. 우선 무엇보다 예기치 않은 변화가
   인증서 또는 보안이 예상 될 때 보안이 부재 한 경우



Rosenberg, et. al. 표준 트랙 [Page 204]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   주의가 필요하지만 반드시 공격이 아니라는 표시
   진행 중입니다. 사용자가 연결 시도를 중단하거나
   그들이받은 연결 요청 전화 통화에서
   끊고 전화를 걸 수 있습니다. 사용자는 대체품을 찾고 싶어 할 수 있습니다.
   상대방에게 연락하고 키가 있음을 확인하는 것을 의미합니다.
   합법적으로 바뀌었다. 사용자는 때로는
   인증서를 변경하십시오. 예를 들어,
   개인 키의 비밀이 손상되었습니다. 그들의
   개인 키가 더 이상 비공개가 아니므로, 사용자는 합법적으로
   새로운 키와 오래된 키를 가진 모든 사용자와의 신뢰를 다시 구축하십시오.
   키.

   마지막으로, 대화 중에 UA가 인증서를 받으면
   에 해당하지 않는 CMS SignedData 메시지에서
   이전에 대화 상자에서 교환 된 인증서 인 경우, UA는 반드시 통지해야한다
   변경의 사용자, 바람직하게는
   잠재적 인 보안 위반입니다.

23.3 MIME 본문 보안

   보안 MIME 시체에는 두 가지 유형이 있습니다.
   SIP :이 기관의 사용은 S / MIME 사양 [24]을 따라야합니다.
   약간의 변화가 있었다.

      o "multipart / signed"는 CMS를 분리 할 때만 사용해야합니다.
         서명.

            이렇게하면 비 -S / MIME-
            준수하는 수신자.

      o S / MIME 시체는 Content-Disposition 헤더 필드를 가져야한다 (SHOULD)
         "handling"매개 변수의 값은 "필수"이어야한다 (SHOULD).

      o UAC에 해당 키링 관련 인증서가없는 경우
         요청을 보내려는 레코드 주소.
         암호화 된 "application / pkcs7-mime"MIME 메시지를 보낼 수 없습니다.
         UAC는 OPTIONS 메시지와 같은 초기 요청을 보낼 수 있습니다
         CMS를 분리하라는 서명이있는
         원격 측 인증서 (서명은 반드시 서명되어야 함)
         "message / sip"본문 23.4 절 참조).

            S / MIME에 대한 향후 표준화 작업을 통해
            비 인증서 기반 키.

      o S / MIME 바디의 발신자는 "SMIMECapabilities"를 사용해야한다 (SHOULD)
         ([24]의 2.5.2 절 참조) 속성을 사용하여
         추가 통신을위한 기능 및 선호도. 노트
         특히 보낸 사람은 "preferSignedData"



Rosenberg, et. al. 표준 트랙 [쪽 205]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         리시버가 CMS로 응답하도록 장려하는 기능
         SignedData 메시지 (예 : OPTIONS
         요청).

      o S / MIME 구현은 SHA1을 최소한으로 지원해야한다.
         디지털 서명 알고리즘 및 3DES 암호화
         연산. 기타 모든 서명 및 암호화 알고리즘 MAY
         지원 될 수 있습니다. 구현은 이러한 지원을 협상 할 수 있습니다.
         알고리즘은 "SMIMECapabilities"속성을 갖습니다.

      o SIP 메시지의 각 S / MIME 본문은
         하나의 인증서. UA가 복수의 메시지를 수신하면
         가장 바깥 쪽 서명은
         이 본문에 대한 단일 인증서. 병렬 서명 (SHOULD)
         사용하지 마십시오.

         다음은 암호화 된 S / MIME SDP 본문의 예입니다.
         SIP 메시지 내에서 :

        INVITE SIP : bob@biloxi.com SIP / 2.0
        경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
        To : Bob <sip : bob@biloxi.com>
        보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
        통화 ID : a84b4c76e66710
        CSeq : 314159 INVITE
        최대 전진 : 70
        연락처 : <sip : alice@pc33.atlanta.com>
        콘텐츠 유형 : application / pkcs7-mime; smime-type = enveloped-data;
             이름 = smime.p7m
        내용 - 처분 : 첨부; filename = smime.p7m
           취급 = 필수

      *************************************************** *****
      * Content-Type : application / sdp *
      * *
      * v = 0 *
      * o = alice 53655765 2353687637 IN IP4 pc33.atlanta.com *
      * s = - *
      * t = 0 0 *
      * c = IN IP4 pc33.atlanta.com *
      * m = 오디오 3456 RTP / AVP 0 1 3 99 *
      * a = rtpmap : 0 PCMU / 8000 *
      *************************************************** *****








Rosenberg, et. al. 표준 트랙 [쪽 206]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


23.4 S / MIME을 사용한 SIP 헤더 개인 정보 보호 및 무결성 : SIP 터널링

   어느 정도의 엔드 - 투 - 엔드 인증을 제공하는 수단으로서,
   SIP 헤더 필드의 무결성 또는 기밀성, S / MIME 수
   유형의 MIME 본문 내에 전체 SIP 메시지 캡슐화
   "message / sip"을 입력 한 다음 MIME 보안을
   일반적인 SIP 시체와 같은 방식입니다. 이러한 캡슐화 된 SIP 요청
   응답은 별도의 대화 또는 트랜잭션을 구성하지 않습니다.
   그들은 확인하는 데 사용되는 "외부"메시지의 사본입니다.
   무결성 또는 추가 정보를 제공해야합니다.

   UAS가 터널링 된 "message / sip"메시지를 포함하는 요청을 수신하면,
   S / MIME 본문에서는 터널링 된 "message / sip"본문을
   동일한 smime-type을 가진 응답.

   기존 MIME 본문 (예 : SDP)은
   "내부"메시지를 사용하여 S / MIME 보안을 활용할 수도 있습니다.
   "message / sip"본문은 MIME의 일부로 보낼 수 있습니다
   보안되지 않은 MIME 형식도 있어야하는 경우 "multipart / mixed"본문
   요청에 따라 전송됩니다.

23.4.1 SIP 헤더의 무결성 및 기밀성 속성

   S / MIME 무결성 또는 기밀성 메커니즘이 사용될 때,
   "내부"메시지의 값 사이에 불일치가있을 수 있습니다
   및 "외부"메시지의 값. 그러한 사항을 다루기위한 규칙
   이 문서에서 설명 된 모든 헤더 필드의 차이점
   이 절에 주어져있다.

   느슨한 타임 스탬핑을 위해 모든 SIP 메시지
   그 터널 "message / sip"은
   "내부"및 "외부"헤더.

23.4.1.1 무결성

   무결성 검사가 수행 될 때마다 헤더의 무결성
   필드는 헤더 필드의 값과 일치시켜야한다.
   서명 된 본문에서 "외부"메시지의 내용과 함께
   20에서 설명한 SIP의 비교 규칙

   프록시 서버에 의해 합법적으로 수정 될 수있는 헤더 필드는 다음과 같습니다.
   Request-URI, Via, Record-Route, Route, Max-Forwards 및 Proxy-
   권한 부여. 이러한 헤더 필드가 완전한 엔드 - 투 - 엔드가 아닌 경우,
   구현은 이것을 보안 위반으로 간주해서는 안됩니다 (SHOULD NOT SHOULD).
   이 문서에 정의 된 다른 헤더 필드의 변경 사항
   무결성 위반을 구성한다. 사용자는 반드시
   모순.




Rosenberg, et. al. 표준 트랙 [Page 207]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


23.4.1.2 기밀 유지

   메일이 암호화되면 헤더 입력란이
   암호화 된 본문은 "외부"메시지에 없습니다.

   일부 헤더 필드는 항상 일반 텍스트 버전이어야합니다.
   요청 및 응답의 필수 헤더 필드는 다음과 같습니다.

   To, From, Call-ID, CSeq, Contact. 아마 유용하지는 않지만
   Call-ID, CSeq 또는 Contact에 대한 암호화 된 대안을 제공하고,
   To 또는 From의 "외부"정보에 대한 대안 제공
   허용됩니다. 암호화 된 본문의 값은 사용되지 않습니다.
   거래 또는 대화 상자를 식별하기 위해
   단순한 정보 제공. 암호화 된 본문의 From 헤더 필드
   "외부"메시지의 값과 다른 경우,
   암호화 된 본문은 사용자에게 표시되어야하지만 반드시 사용되어서는 안됩니다 (SHOULD).
   향후 메시지의 "외부"헤더 필드에

   주로 사용자 에이전트는 다음과 같은 헤더 필드를 암호화하려고합니다.
   Subject, Reply-To, Organization, 등등을 포함하는 종단 간 의미론 (end-to- end semantic)
   수락, 수락 - 인코딩, 수락 언어, 경고 정보, 오류 정보,
   인증 정보, 만료, 회신 요청, 필요, 지원됨,
   지원되지 않음, 재시도 후, 사용자 에이전트, 서버 및 경고. 다음 중 하나 인 경우
   이러한 헤더 필드는 암호화 된 본문에 존재하므로
   이것이 "외부"헤더 필드 대신에 사용되는지 여부
   헤더 필드 값을 사용자에게 표시하거나 내부 설정
   UA의 주. 그러나 그들은 "바깥 쪽"
   향후 메시지의 헤더.

   존재하는 경우 Date 헤더 필드는 항상 동일해야합니다.
   "내부"및 "외부"헤더.

   MIME 본문은 "내부"메시지에 첨부되므로,
   구현은 일반적으로 MIME 관련 헤더 필드를 암호화합니다.
   MIME-Version, Content-Type, Content-Length, Content-
   언어, 콘텐츠 인코딩 및 콘텐츠 처리. "외부"
   메시지에는 S / MIME 본문에 대한 적절한 MIME 헤더 필드가 있습니다.
   이 헤더 필드 (및 머리글 본문)는 다음과 같아야합니다.
   SIP에서 수신 된 일반 MIME 헤더 필드 및 본문으로 처리됩니다.
   메시지.

   다음 헤더 필드를 암호화하는 것은 특히 유용하지 않습니다.
   최소 만료, 타임 스탬프, 권한 부여, 우선 순위 및 WWW-
   인증. 이 카테고리에는 또한 다음과 같은 헤더 필드가 포함됩니다.
   프록시 서버 (앞 절에서 설명)로 변경할 수 있습니다.
   UA는 이들을 "내부"메시지에 포함시키지 않아야한다 (SHAULD).





Rosenberg, et. al. 표준 트랙 [쪽 208]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   "외부"메시지에 포함됩니다. 이 중 하나를받는 UA
   암호화 된 본문의 헤더 필드는 암호화 된 본문을 무시해야합니다 (SHOULD).
   값.

   SIP 확장은 추가 헤더 필드를 정의 할 수 있습니다. 그만큼
   이러한 확장자의 작성자는 무결성 및
   이러한 헤더 필드의 기밀성 속성 SIP UA
   무결성 위반이있는 알 수없는 헤더 필드를 발견하면
   반드시 헤더 필드를 무시해야한다.

23.4.2 터널링 무결성 및 인증

   S / MIME 본문 내의 터널링 SIP 메시지는
   SIP 헤더 필드. 발신자가 원하는 헤더 필드
   보안은 CMS로 서명 된 "message / sip"MIME 본문에 복제됩니다.
   분리 된 서명.

   "message / sip"본문에 적어도
   기본 대화 상자 식별자 (To, From, Call-ID, CSeq), 그리고 나서 a
   서명 된 MIME 본문은 제한된 인증을 제공 할 수 있습니다. 아주
   시체에 서명하는 데 사용 된 인증서가
   수신자이며 확인할 수없는 경우 서명을 사용하여
   대화 상자에서 나중의 요청이
   대화 상자를 시작한 동일한 인증서 보유자. 수령인
   서명 된 MIME 본문의 일부를 신뢰할 수있는 인센티브가 있습니다.
   인증서 (그들은 그것을 검증 할 수 있었고,
   신뢰할 수있는 저장소 또는 자주 사용하는 경우)
   서명은 본인의 신원을 강력하게 주장하는 것으로 간주 될 수 있습니다.
   인증서의 제목.

   추가에 관한 혼란을 없애기 위해
   전체 헤더 필드의 뺄셈, 전송자는 모든 것을 복제해야한다.
   서명 된 본문 내의 요청에서 헤더 필드. 모든 메시지
   무결성 보호가 필요한 신체는 반드시
   "내부"메시지.

   서명 된 본문이있는 메시지에 Date 헤더가있는 경우
   수신자는 헤더 필드 값을 자신의 내부 필드와 비교해야한다 (SHOULD).
   해당되는 경우 시계. 중요한 시간 불일치가 감지되면
   (1 시간 이상), 사용자 에이전트는 다음을 경고해야한다.
   사용자에게 이의 제기를 제기하고 잠재적 인 보안 침해임을인지하십시오.

   수신자가 메시지의 무결성 위반을 탐지하면,
   메시지는 403 (금지 된) 응답으로 거부 될 수있다.
   요청 또는 기존 대화 상자가 종료 될 수 있습니다. UA는 사용해야한다.
   이 상황을 사용자에게 알리고 이에 대한 명확한 지침을 요청하십시오.
   진행 방법.




Rosenberg, et. al. 표준 트랙 [쪽 209]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   다음은 터널링 된 "message / sip"메시지를 사용하는 예입니다.
   신체:

      INVITE SIP : bob@biloxi.com SIP / 2.0
      경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
      To : Bob <sip : bob@biloxi.com>
      보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
      통화 ID : a84b4c76e66710
      CSeq : 314159 INVITE
      최대 전진 : 70
      날짜 : Thu, 2002 년 2 월 21 일 13:02:03 GMT
      연락처 : <sip : alice@pc33.atlanta.com>
      Content-Type : multipart / signed;
        protocol = "application / pkcs7-signature";
        micalg = sha1; 경계 = 경계 42
      콘텐츠 길이 : 568

      - 경계 42
      Content-Type : 메시지 / sip

      INVITE SIP : bob@biloxi.com SIP / 2.0
      경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
      받는 사람 : Bob <bob@biloxi.com>
      보낸 사람 : Alice <alice@atlanta.com>; tag = 1928301774
      통화 ID : a84b4c76e66710
      CSeq : 314159 INVITE
      최대 전진 : 70
      날짜 : Thu, 2002 년 2 월 21 일 13:02:03 GMT
      연락처 : <sip : alice@pc33.atlanta.com>
      콘텐츠 유형 : application / sdp
      콘텐츠 길이 : 147

      v = 0
      o = UserA 2890844526 2890844526 IN IP4 here.com
      s = 세션 SDP
      c = IN IP4 pc33.atlanta.com
      t = 0 0
      m = 오디오 49172 RTP / AVP 0
      a = rtpmap : 0 PCMU / 8000

      - 경계 42
      Content-Type : application / pkcs7-signature; 이름 = smime.p7s
      콘텐츠 전송 인코딩 : base64
      내용 - 처분 : 첨부; filename = smime.p7s;
         취급 = 필수






Rosenberg, et. al. 표준 트랙 [210 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      ghyHhHuujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6
      4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj
      n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4
      7GhIGfHfYT64vQbnj756

      - 경계 42-

23.4.3 터널링 암호화

   또한이 메커니즘을 사용하여
   "message / sip"CMS 내의 MIME 본문 EnvelopedData 메시지 S / MIME
   body하지만 실제로는 대부분의 헤더 필드는 적어도
   네트워크; S / MIME을 통한 암호화의 일반적인 사용은 보안을 유지하는 것입니다.
   메시지 머리글보다는 SDP와 같은 메시지 본문. 약간
   제목 또는 조직과 같은 정보 헤더 필드
   아마 종단 간 보안을 보증 할 수 있습니다. 미래에 정의 된 헤더
   SIP 응용 프로그램은 난독 화가 필요할 수도 있습니다.

   헤더 필드를 암호화하는 또 다른 가능한 응용 프로그램은 선택적입니다.
   익명. From 헤더 필드를 사용하여 요청을 구성 할 수 있습니다.
   개인 정보가 포함되어 있지 않습니다 (예 :
   sip : anonymous@anonymizer.invalid). 그러나 두 번째 From 헤더
   발신자의 실제 주소 기록을 포함하는 필드
   "message / sip"MIME 본문 내에서 암호화 될 수 있습니다.
   대화 상자의 끝점에서만 볼 수 있습니다.

      이 메커니즘이 익명 성을 위해 사용되면 From 헤더
      필드는 메시지 수신자가 더 이상 사용할 수 없게됩니다.
      retrievin에 대한 인증서 키 체인의 색인
적절한 g
      보낸 사람과 관련된 S / MIME 키. 메시지는 먼저
      해독되어야하며, "inner"From 헤더 필드는 반드시
      색인.

   종단 간 무결성을 제공하기 위해 암호화 된 "message / sip"
   MIME 시체는 보낸 사람이 서명해야합니다 (SHOULD). 이렇게하면
   암호화 된 본문이 포함 된 "multipart / signed"MIME 본문
   서명, 모두 "application / pkcs7-mime"유형.














Rosenberg, et. al. 표준 트랙 [쪽 211]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   암호화 된 서명 된 메시지의 다음 예에서
   별표 ( "*")로 표시된 텍스트는 암호화됩니다.

        INVITE SIP : bob@biloxi.com SIP / 2.0
        경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
        To : Bob <sip : bob@biloxi.com>
        보낸 사람 : 익명 <sip : anonymous@atlanta.com>; tag = 1928301774
        통화 ID : a84b4c76e66710
        CSeq : 314159 INVITE
        최대 전진 : 70
        날짜 : Thu, 2002 년 2 월 21 일 13:02:03 GMT
        연락처 : <sip : pc33.atlanta.com>
        Content-Type : multipart / signed;
          protocol = "application / pkcs7-signature";
          micalg = sha1; 경계 = 경계 42
        콘텐츠 길이 : 568

        - 경계 42
        콘텐츠 유형 : application / pkcs7-mime; smime-type = enveloped-data;
             이름 = smime.p7m
        콘텐츠 전송 인코딩 : base64
        내용 - 처분 : 첨부; filename = smime.p7m
           취급 = 필수
        콘텐츠 길이 : 231

      *************************************************** *********
      * Content-Type : message / sip *
      * *
      * INVITE SIP : bob@biloxi.com SIP / 2.0 *
      * Via : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8 *
      *받는 사람 : Bob <bob@biloxi.com> *
      * 보낸 사람 : Alice <alice@atlanta.com>; tag = 1928301774 *
      * 통화 ID : a84b4c76e66710 *
      * CSeq : 314159 INVITE *
      * 최대 - 전달 : 70 *
      * 날짜 : Thu, 2002 년 2 월 21 일 13:02:03 GMT *
      * 연락처 : <sip : alice@pc33.atlanta.com> *
      * *
      * Content-Type : application / sdp *
      * *
      * v = 0 *
      * o = alice 53655765 2353687637 IN IP4 pc33.atlanta.com *
      * s = 세션 SDP *
      * t = 0 0 *
      * c = IN IP4 pc33.atlanta.com *
      * m = 오디오 3456 RTP / AVP 0 1 3 99 *
      * a = rtpmap : 0 PCMU / 8000 *
      *************************************************** *********



Rosenberg, et. al. 표준 트랙 [쪽 212]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


        - 경계 42
        Content-Type : application / pkcs7-signature; 이름 = smime.p7s
        콘텐츠 전송 인코딩 : base64
        내용 - 처분 : 첨부; filename = smime.p7s;
           취급 = 필수

        ghyHhHuujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6
        4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj
        n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4
        7GhIGfHfYT64VQbnj756

        - 경계 42-

24 예제

   다음 예제에서 우리는 종종 메시지 본문과
   해당 Content-Length 및 Content-Type 헤더 필드
   짧음.

24.1 등록

   Bob은 시작시 등록합니다. 메시지 흐름은 그림 9와 같습니다.
   일반적으로 등록에 필요한 인증은
   단순화를 위해 도시된다.

                  biloxi.com Bob 's
                   레지스트라 소프트 폰
                      | |
                      | F1 등록 |
                      | <--------------- |
                      | 200 OK F2 |
                      | ---------------> |

                  그림 9 : SIP 등록 예

   F1 등록 밥 -> 등록 기관

       REGISTER sip : registrar.biloxi.com SIP / 2.0
       Via : SIP / 2.0 / UDP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7
       최대 전진 : 70
       To : Bob <sip : bob@biloxi.com>
       보낸 사람 : Bob <sip : bob@biloxi.com>; tag = 456248
       통화 ID : 843817637684230 @ 998sdasdh09
       CSeq : 1826 등록
       연락처 : <sip : bob@192.0.2.4>
       만료일 : 7200
       콘텐츠 길이 : 0




Rosenberg, et. al. 표준 트랙 [쪽 213]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   2 시간 후에 등록이 만료됩니다. 레지스트라가 응답 함
   200 OK :

   F2 200 OK 등록 기관 -> Bob

        SIP / 2.0 200 OK
        Via : SIP / 2.0 / UDP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7
         수신 = 192.0.2.4
        받는 사람 : Bob <sip : bob@biloxi.com>; tag = 2493k59kd
        보낸 사람 : Bob <sip : bob@biloxi.com>; tag = 456248
        통화 ID : 843817637684230 @ 998sdasdh09
        CSeq : 1826 등록
        연락처 : <sip : bob@192.0.2.4>
        만료일 : 7200
        콘텐츠 길이 : 0

24.2 세션 설정

   이 예제에는 예제 세션 설정의 전체 세부 정보가 포함되어 있습니다.
   메시지 흐름은 그림 1에 나와 있습니다.
   이러한 흐름은 헤더 필드의 최소 필수 집합을 보여줍니다.
   허용 및 지원과 같은 다른 헤더 필드는 일반적으로
   선물.

F1 INVITE 앨리스 -> atlanta.com 프록시

INVITE SIP : bob@biloxi.com SIP / 2.0
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
최대 전진 : 70
To : Bob <sip : bob@biloxi.com>
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
연락처 : <sip : alice@pc33.atlanta.com>
콘텐츠 유형 : application / sdp
콘텐츠 길이 : 142

(앨리스의 SDP는 표시되지 않음)













Rosenberg, et. al. 표준 트랙 [쪽 214]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


F2 100 시도 atlanta.com 프록시 -> 앨리스

SIP / 2.0 100 시도 중
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
To : Bob <sip : bob@biloxi.com>
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
콘텐츠 길이 : 0

F3 Invite atlanta.com 프록시 -> biloxi.com 프록시

INVITE SIP : bob@biloxi.com SIP / 2.0
경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com; 지점 = z9hG4bK77ef4c2312983.1
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
최대 전진 : 69
To : Bob <sip : bob@biloxi.com>
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
연락처 : <sip : alice@pc33.atlanta.com>
콘텐츠 유형 : application / sdp
콘텐츠 길이 : 142

(앨리스의 SDP는 표시되지 않음)

F4 100 biloxi.com 시도 프록시 -> atlanta.com 프록시

SIP / 2.0 100 시도 중
경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com; 지점 = z9hG4bK77ef4c2312983.1
 수신 = 192.0.2.2
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
To : Bob <sip : bob@biloxi.com>
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
콘텐츠 길이 : 0











Rosenberg, et. al. 표준 트랙 [쪽 215]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


F5 INVITE biloxi.com proxy -> Bob

INVITE SIP : bob@192.0.2.4 SIP / 2.0
Via : SIP / 2.0 / UDP server10.biloxi.com, 지점 = z9hG4bK4b43c2ff8.1
경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com; 지점 = z9hG4bK77ef4c2312983.1
 수신 = 192.0.2.2
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
최대 전진 : 68
To : Bob <sip : bob@biloxi.com>
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
연락처 : <sip : alice@pc33.atlanta.com>
콘텐츠 유형 : application / sdp
콘텐츠 길이 : 142

(앨리스의 SDP는 표시되지 않음)

F6 180 울리는 밥 -> biloxi.com 프록시

SIP / 2.0 180 울림
Via : SIP / 2.0 / UDP server10.biloxi.com, 지점 = z9hG4bK4b43c2ff8.1
 수신 = 192.0.2.3
경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com; 지점 = z9hG4bK77ef4c2312983.1
 수신 = 192.0.2.2
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
연락처 : <sip : bob@192.0.2.4>
CSeq : 314159 INVITE
콘텐츠 길이 : 0

F7 180 울리는 biloxi.com 대리인 -> atlanta.com 대리인

SIP / 2.0 180 울림
경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com; 지점 = z9hG4bK77ef4c2312983.1
 수신 = 192.0.2.2
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
연락처 : <sip : bob@192.0.2.4>
CSeq : 314159 INVITE
콘텐츠 길이 : 0



Rosenberg, et. al. 표준 트랙 [쪽 216]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


F8 180 링잉 atlanta.com 프록시 -> 앨리스

SIP / 2.0 180 울림
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
연락처 : <sip : bob@192.0.2.4>
CSeq : 314159 INVITE
콘텐츠 길이 : 0

F9 200 OK Bob -> biloxi.com 프록시

SIP / 2.0 200 OK
Via : SIP / 2.0 / UDP server10.biloxi.com, 지점 = z9hG4bK4b43c2ff8.1
 수신 = 192.0.2.3
경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com; 지점 = z9hG4bK77ef4c2312983.1
 수신 = 192.0.2.2
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
연락처 : <sip : bob@192.0.2.4>
콘텐츠 유형 : application / sdp
콘텐츠 길이 : 131

(Bob의 SDP는 표시되지 않음)

F10 200 OK biloxi.com 대리인 -> atlanta.com 대리인

SIP / 2.0 200 OK
경유 : SIP / 2.0 / UDP bigbox3.site3.atlanta.com; 지점 = z9hG4bK77ef4c2312983.1
 수신 = 192.0.2.2
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
연락처 : <sip : bob@192.0.2.4>
콘텐츠 유형 : application / sdp
콘텐츠 길이 : 131

(Bob의 SDP는 표시되지 않음)




Rosenberg, et. al. 표준 트랙 [쪽 216]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


F11 200 OK atlanta.com 프록시 -> Alice

SIP / 2.0 200 OK
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds8
 수신 = 192.0.2.1
받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 INVITE
연락처 : <sip : bob@192.0.2.4>
콘텐츠 유형 : application / sdp
콘텐츠 길이 : 131

(Bob의 SDP는 표시되지 않음)

F12 ACK Alice -> Bob

ACK sip : bob@192.0.2.4 SIP / 2.0
경유 : SIP / 2.0 / UDP pc33.atlanta.com; 지점 = z9hG4bKnashds9
최대 전진 : 70
받는 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
보낸 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 314159 ACK
콘텐츠 길이 : 0

   Alice와 Bob 사이의 미디어 세션이 설정되었습니다.

   Bob이 먼저 전화를 끊습니다. Bob의 SIP 전화는 자체 CSeq를 유지합니다.
   번호 매기기 공간은 231로 시작합니다. Bob
   To 및 From URI 및 태그가
   바꿔 치기했다.

F13 BYE Bob -> 앨리스

BYE sip : alice@pc33.atlanta.com SIP / 2.0
경유 : SIP / 2.0 / UDP 192.0.2.4; 지점 = z9hG4bKnashds10
최대 전진 : 70
보낸 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
받는 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 231 BYE
콘텐츠 길이 : 0








Rosenberg, et. al. 표준 트랙 [Page 218]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


F14 200 OK Alice -> Bob

SIP / 2.0 200 OK
경유 : SIP / 2.0 / UDP 192.0.2.4; 지점 = z9hG4bKnashds10
보낸 사람 : Bob <sip : bob@biloxi.com>; tag = a6c85cf
받는 사람 : Alice <sip : alice@atlanta.com>; tag = 1928301774
통화 ID : a84b4c76e66710
CSeq : 231 BYE
콘텐츠 길이 : 0

   SIP Call Flows 문서 [40]에는 SIP
   메시지.

25 SIP 프로토콜을위한 BNF 증강

   이 문서에 지정된 모든 메커니즘은 다음에서 설명됩니다.
   RFC에 정의 된 산문과 증대 된 Backus-Naur Form (BNF)
   2234 [10]. RFC 2234의 6.1 절에서는 다음과 같은 핵심 규칙을 정의합니다.
   이 명세서에서 사용되며 여기에서 반복되지 않는다. 구현 자
   에서 RFC 2234의 표기법 및 내용에 익숙해야합니다.
   이 명세를 이해하기 위해서 특정 기본 규칙은
   대문자 (예 : SP, LWS, HTAB, CRLF, DIGIT, ALPHA 등) 각도
   괄호는 정의 내에서 규칙의 사용을 명확히하기 위해 사용됩니다.
   이름.

   사각 괄호는 구문 적으로 중복 사용됩니다. 그것은으로 사용됩니다
   의미있는 힌트는 특정 매개 변수가 사용하기 위해 선택 사항이라는 것입니다.

25.1 기본 규칙

   다음의 규칙은이 규격 전반에 걸쳐
   기본 구문 분석 구문을 설명합니다. US-ASCII 코드 문자 집합
   ANSI X3.4-1986에 의해 정의됩니다.

      영숫자 = 알파 / 디지트
















Rosenberg, et. al. 표준 트랙 [Page 219]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   RFC 2396 [5]에는 몇 가지 규칙이 통합되어 있지만
   RFC 2234 [10]를 준수하도록합니다. 여기에는 다음이 포함됩니다.

      예약 = ";" / "/"/ "?" / ":"/ "@"/ "&"/ "="/ "+"
                     / "$"/ ","
      예약되지 않은 = 영숫자 / 마크
      mark = "-"/ "_"/ "." / "!" / "~"/ "*"/ " '"
                     / "("/ ")"
      이스케이프 됨 = "%"HEXDIG HEXDIG

   SIP 헤더 필드 값은 여러 줄로 묶을 수 있습니다.
   연속 선은 공백 또는 수평 탭으로 시작됩니다. 모든 선형
   접기를 포함하여 공백은 SP와 동일한 의미를가집니다. 에이
   수신자는 선형 백색 공간을 하나의 SP로 대체 할 수있다.
   필드 값 해석 또는 메시지 다운 스트림 전달.
   이것은 RFC에 설명 된대로 HTTP / 1.1과 똑같이 동작하기위한 것입니다.
   2616 [8]. SWS 구성은 선형 공백이
   선택 사항, 일반적으로 토큰과 분리 기호 사이.

      LWS = [* WSP CRLF] 1 * WSP; 선형 공백
      SWS = [LWS]; 공백 구분

   헤더 이름을 나머지 값과 구분하기 위해 콜론이 사용되며,
   위의 규칙에 따라 앞에 공백을 허용하지만 줄을 허용하지 않습니다.
   줄 바꿈을 포함하여 후에 줄 바꿈 및 공백 문자를 포함 할 수 있습니다. HCOLON
   이 구조를 정의합니다.

      HCOLON = * (SP / HTAB) ":"SWS

   TEXT-UTF8 규칙은 설명 필드 내용 및
   메시지 파서에 의해 해석되지 않는 값.
   * TEXT-UTF8의 단어에는 UTF-8 문자 세트의 문자가 포함됩니다 (RFC
   2279). 설명 필드에는 TEXT-UTF8-TRIM 규칙이 사용됩니다.
   인용 부호가없는 문자열 인 내용, 앞뒤 LWS
   의미가 없습니다. 이와 관련하여 SIP는 HTTP와는 다르며
   ISO 8859-1 문자 세트

      TEXT-UTF8-TRIM = 1 * TEXT-UTF8char * (* LWS TEXT-UTF8char)
      TEXT-UTF8char = % x21-7E / UTF8-NONASCII
      UTF8-NONASCII = % xC0-DF 1UTF8-CONT
                      / % xE0-EF 2UTF8-CONT
                      / % xF0-F7 3UTF8-CONT
                      / % xF8-Fb 4UTF8-CONT
                      / % xFC-FD 5UTF8-CONT
      UTF8-CONT = % x80-BF






Rosenberg, et. al. 표준 트랙 [쪽 220]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   CRLF는 TEXT-UTF8-TRIM의 정의에서
   헤더 필드 계속. 접히는 LWS
   TEXT의 해석 이전에 단일 SP로 대체 될 것이다.
   UTF8-TRIM 값입니다.

   16 진수는 여러 프로토콜 요소에서 사용됩니다.
   일부 요소 (인증)는 16 진수 alphas를 소문자로 만듭니다.

      LHEX = DIGIT / % x61-66, 소문자 a-f

   많은 SIP 헤더 필드 값은 LWS 또는
   특수 문자. 달리 명시되지 않는 한, 토큰은 대소 문자를 구별합니다.
   무신경. 이 특수 문자는 반드시 인용 문자열로 묶어야합니다.
   매개 변수 값 내에서 사용됩니다. 단어 구성은에서 사용됩니다.
   대부분의 구분 기호를 사용할 수 있도록 호출 ID.

      토큰 = 1 * (영숫자 / "-"/ "."/ "!"/ "%"/ "*"
                     / "_"/ "+"/ "`"/ " '"/ "~")
      구분 기호 = "("/ ")"/ "<"/ ">"/ "@"/
                     ","/ ";" / ":"/ "\"/ DQUOTE /
                     "/"/ "["/ "]"/ "?" / "="/
                     "{"/ "}"/ SP / HTAB
      단어 = 1 * (영숫자 / "-"/ "."/ "!"/ "%"/ "*"/
                     "_"/ "+"/ "`"/ " '"/ "~"/
                     "("/ ")"/ "<"/ ">"/
                     ":"/ "\"/ DQUOTE /
                     "/"/ "["/ "]"/ "?" /
                     "{"/ "}")

   토큰이 사용되거나 분리 기호가 요소간에 사용되면,
   공백 문자는 대개 이러한 문자 앞뒤에 허용됩니다.

      STAR = SWS "*"SWS; 별표
      슬래시 = SWS "/"SWS; 삭감
      EQUAL = SWS "="SWS; 같은
      LPAREN = SWS "("SWS; 왼쪽 괄호
      RPAREN = SWS ")"SWS; 오른쪽 괄호
      RAQUOT = ">"SWS; 직각 인용문
      LAQUOT = SWS "<"; 왼쪽 각도 따옴표
      COMMA = SWS ","SWS; 콤마
      SEMI = SWS ";" SWS; 세미콜론
      COLON = SWS ":"SWS; 콜론
      LDQUOT = SWS DQUOTE; 큰 따옴표 열기
      RDQUOT = DQUOTE SWS; 큰 따옴표 닫기







Rosenberg, et. al. 표준 트랙 [Page 221]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   일부 SIP 헤더 필드에 주석을 포함 할 수 있습니다.
   괄호로 된 주석 텍스트. 댓글은 필드에서만 허용됩니다.
   필드 값 정의의 일부로 "주석"을 포함합니다. 모두
   다른 필드는 괄호가 필드 값의 일부로 간주됩니다.

      comment = LPAREN * (ctext / quoted-pair / comment) RPAREN
      ctext = % x21-27 / % x2A-5B / % x5D-7E / UTF8-NONASCII
                  / LWS

   ctext는 왼쪽 및 오른쪽 괄호와 백 슬래시를 제외한 모든 문자를 포함합니다.
   텍스트의 문자열은 인용 부호로 둘러싸인 경우 하나의 단어로 구문 분석됩니다.
   큰 따옴표. 따옴표로 묶인 문자열에는 따옴표 ( ")와
   백 슬래시 (\)를 이스케이프 처리해야합니다.

      quoted-string = SWS DQUOTE * (qdtext / quoted-pair) DQUOTE
      qdtext = LWS / % x21 / % x23-5B / % x5D-7E
                        / UTF8-NONASCII

   백 슬래시 문자 ( "\")는 단일 문자로 사용될 수 있습니다
   quoted-string과 comment 구조 내에서만 메카니즘을 인용한다.
   HTTP / 1.1과 달리 CR 및 LF 문자는이 문자로 이스케이프 할 수 없습니다.
   라인 폴딩 및 헤더 분리와의 충돌을 피하는 메커니즘.

quoted-pair = "\"(% x00-09 / % x0B-0C
                / % x0E-7F)

SIP-URI = "sip :"[userinfo] hostport
                    uri-parameters [헤더]
SIPS-URI = "sips :"[userinfo] hostport
                    uri-parameters [헤더]
userinfo = (사용자 / 전화 - 구독자) [ ":"비밀번호] "@"
사용자 = 1 * (예약되지 않음 / 이스케이프 / 사용자 비 예약)
user-unreserved = "&"/ "="/ "+"/ "$"/ ","/ ";" / "?" / "/"
password = * (예약되지 않음 / 이스케이프 /
                    "&"/ "="/ "+"/ "$"/ ",")
hostport = 호스트 [ ":"포트]
호스트 = 호스트 이름 / IPv4 주소 / IPv6 참조
호스트 이름 = * (도메인 레이블 ".") toplabel [ "." ]
domainlabel = alphanum
                    / 영숫자 * (영숫자 / "-") 영숫자
toplabel = ALPHA / ALPHA * (영숫자 / "-") 영숫자










Rosenberg, et. al. 표준 트랙 [Page 222]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


IPv4address = 1 * 3DIGIT "." 1 * 3DIGIT "." 1 * 3DIGIT "." 1 * 3DIGIT
IPv6reference = "["IPv6address "]"
IPv6address = hexpart [ ":"IPv4address]
hexpart = hexseq / hexseq "::"[hexseq] / "::"[hexseq]
hexseq = hex4 * ( ":"hex4)
hex4 = 1 * 4HEXDIG
포트 = 1 * DIGIT

   전화 가입자를위한 BNF는 RFC 2806 [9]에 있습니다. 노트,
   그러나 허용 된 문자는 허용되지 않습니다.
   SIP URI의 사용자 부분을 이스케이프해야합니다 (MUST).

uri-parameters = * ( ";"uri-parameter)
uri-parameter = transport-param / user-param / method-param
                     / ttl-param / maddr-param / lr-param / other-param
transport-param = "전송 ="
                     ( "udp"/ "tcp"/ "sctp"/ "tls"
                     / 기타 운송)
기타 전송 = 토큰
user-param = "user ="( "전화"/ "ip"/ other-user)
다른 사용자 = 토큰
method-param = "method ="Method
ttl-param = "ttl ="ttl
maddr-param = "maddr ="호스트
lr-param = "lr"
other-param = pname [ "="pvalue]
pname = 1 * paramchar
pvalue = 1 * paramchar
paramchar = param-unreserved / unreserved / escaped
param-unreserved = "["/ "]"/ "/"/ ":"/ "&"/ "+"/ "$"

headers = "?" 헤더 * ( "&"헤더)
header = hname "="hvalue
hname = 1 * (hnv-unreserved / unreserved / escaped)
hvalue = * (hnv-unreserved / unreserved / escaped)
hnv-unreserved = "["/ "]"/ "/"/ "?" / ":"/ "+"/ "$"

SIP 메시지 = 요청 / 응답
요청 = 요청 - 라인
                  * (메시지 헤더)
                  CRLF
                  [message-body]
요청 라인 = 방법 SP 요청 URI SP SIP 버전 CRLF
Request-URI = SIP-URI / SIPS-URI / absoluteURI
absoluteURI = scheme ":"(hier-part / opaque-part)
hier-part = (net-path / abs-path) [ "?" 쿼리]
net-path = "//"권한 [abs-path]
abs-path = "/"경로 세그먼트



Rosenberg, et. al. 표준 트랙 [223 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


opaque-part = uric-no-slash * uric
요산 = 예약 / 비 예약 / 도주
비뇨기 - 아니 - 슬래시 = 예약되지 않은 / 이스케이프 / ";" / "?" / ":"/ "@"
                  / "&"/ "="/ "+"/ "$"/ ","
경로 세그먼트 = 세그먼트 * ( "/"세그먼트)
세그먼트 = * pchar * ( ";"매개 변수)
param = * pchar
pchar = 예약되지 않음 / 이스케이프 됨 /
                  ":"/ "@"/ "&"/ "="/ "+"/ "$"/ ","
scheme = ALPHA * (ALPHA / DIGIT / "+"/ "-"/ ".")
authority = srvr / reg-name
srvr = [[userinfo "@"] hostport]
reg-name = 1 * (예약되지 않음 / 이스케이프 됨 / "$"/ ","
                  / ";" / ":"/ "@"/ "&"/ "="/ "+")
query = * uric
SIP 버전 = "SIP" "/"1 * DIGIT "." 1 * DIGIT

message-header = (Accept
                / 수락 - 인코딩
                / 수락 언어
                / Alert-Info
                /  허용하다
                / 인증 정보
                / 승인
                / Call-ID
                / 호출 정보
                / 연락처
                / Content-Disposition
                / 콘텐츠 인코딩
                / 콘텐츠 언어
                / Content-Length
                / Content-Type
                / CSeq
                / 날짜
                / 오류 정보
                / 만료
                /에서
                / In-Reply-To
                / Max-Forwards
                / MIME-Version
                / 최소 만료
                / 조직
                /  우선 순위
                / 프록시 - 인증
                / 프록시 인증
                / Proxy-Require
                / Record-Route
                /  답장하다



Rosenberg, et. al. 표준 트랙 [Page 224]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


                / Require
                / 다시 시도 - 이후
                / Route
                / 서버
                / 제목
                / 지원됨
                / 타임 스탬프
                / ~
                / 지원되지 않음
                /  사용자 에이전트
                / 비아
                / 경고
                / WWW- 인증
                / 확장 헤더) CRLF

INVITEm = % x49.4E.56.49.54.45; INVITE in caps
ACKm = % x41.43.4B; 대문자로 된 ACK
OPTIONSm = % x4F.50.54.49.4F.4E.53; 대문자로 된 옵션
BYEm = % x42.59.45; BYE in 대문자
CANCELm = % x43.41.4E.43.45.4C; 대문자로 취소
REGISTERm = % x52.45.47.49.53.54.45.52; 등록시 대문자로 기입하십시오.
방법 = INVITEm / ACKm / OPTIONSm / BYEm
                     / CANCELm / REGISTERm
                     / extension-method
확장 메소드 = 토큰
응답 = 상태 - 라인
                     * (메시지 헤더)
                     CRLF
                     [message-body]

상태 줄 = SIP 버전 SP 상태 코드 SP 이유 - 구문 CRLF
상태 코드 = 정보 용
               / 리디렉션
               / 성공
               / 클라이언트 오류
               /   서버 오류
               / 글로벌 실패
               / extension-code
확장 코드 = 3DIGIT
이유 - 구문 = = (예약 됨 / 예약되지 않았 음 / 이스케이프 됨
                   / UTF8-NONASCII / UTF8-CONT / SP / HTAB)

정보 = "100"; 견딜 수 없는
              / "180"; 울리는
              / "181"; 통화 전달 중임
              / "182"; 대기 중
              / "183"; 세션 진행




Rosenberg, et. al. 표준 트랙 [225 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


성공 = "200"; 승인

리디렉션 = "300"; 다양한 선택
            / "301"; 영구히 이사했다.
            / "302"; 일시적으로 이동 됨
            / "305"; 프록시 사용
            / "380"; 대체 서비스

Client-Error = "400"; 잘못된 요청
             / "401"; 무단
             / "402"; 지불 필요
             / "403"; 금지 된
             / "404"; 찾을 수 없음
             / "405"; 허용되지 않는 메소드
             / "406"; 받아 드릴 수없는
             / "407"; 프록시 인증 필요
             / "408"; 요청 시간 초과
             / "410"; 지나간
             / "413"; 엔터티가 너무 큼 요청
             / "414"; 요청 URI가 너무 큼
             / "415"; 지원되지 않는 미디어 유형
             / "416"; 지원되지 않는 URI 체계
             / "420"; 잘못된 확장
             / "421"; 연장 필요
             / "423"; 간격이 너무 짧다.
             / "480"; 일시적으로 사용할 수 없음
             / "481"; 통화 다리 / 거래가 존재하지 않음
             / "482"; 루프 감지 됨
             / "483"; 너무 많은 홉
             / "484"; 불완전한 주소
             / "485"; 모호한
             / "486"; 여기에서 바쁜
             / "487"; 요청이 종료되었습니다.
             / "488"; 받아 들일 수없는
             / "491"; 요청 대기 중
             / "493"; 해독 할 수없는

Server-Error = "500"; 인터넷 서버 오류
             / "501"; 구현되지 않음
             / "502"; 잘못된 게이트웨이
             / "503"; 서비스를 사용할 수 없음
             / "504"; 서버 시간 초과
             / "505"; SIP 버전이 지원되지 않습니다.
             / "513"; 너무 큰 메시지







Rosenberg, et. al. 표준 트랙 [226 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


전역 실패 = "600"; 바쁜 모든 곳
               / "603"; 쇠퇴
               / "604"; 어디에도 존재하지 않습니다.
               / "606"; 받아 드릴 수없는

수락 = "수락"HCOLON
                   [수락 범위 * (COMMA 수락 범위)]
accept-range = media-range * (SEMI accept-param)
media-range = ( "* / *"
                  / (m 유형 슬래시 "*")
                  / (m 형 슬래브 m- 서브 타입)
                  ) * (SEMI m- 매개 변수)
accept-param = ( "q"EQUAL qvalue) / generic-param
qvalue = ( "0"[ "."0 * 3DIGIT])
                  / ( "1"[ "."0 * 3 ( "0")])
generic-param = 토큰 [EQUAL gen-value]
gen-value = token / host / quoted-string

Accept-Encoding = "Accept-Encoding"HCOLON
                     [인코딩 * (COMMA 인코딩)]
인코딩 = 코딩 * (SEMI accept-param)
코딩 = 콘텐츠 코딩 / "*"
내용 코딩 = 토큰

Accept-Language = "Accept-Language"HCOLON
                     [언어 * (COMMA 언어)]
language = language-range * (SEMI accept-param)
language-range = ((1 * 8ALPHA * ( "-"1 * 8ALPHA) / "*")

Alert-Info = "Alert-Info"HCOLON 경고 - 매개 변수 * (COMMA 경고 매개 변수)
alert-param = LAQUOT 절대 값 RAQUOT * (SEMI 제네릭 매개 변수)

허용 = "허용"HCOLON [방법 * (COMMA 방법)]

Authorization = "Authorization"HCOLON 증명서
credentials = ( "다이제스트"LWS 다이제스트 - 응답)
                     / 기타 응답
digest-response = dig-resp * (COMMA dig-resp)
dig-resp = username / realm / nonce / digest-uri
                      / dresponse / algorithm / cnonce
                      / opaque / message-qop
                      / nonce-count / auth-param
username = "username"EQUAL username-value
username-value = quoted-string
digest-uri = "uri"등호 LDQUOT digest-uri-value RDQUOT
digest-uri-value = rquest-uri; 지정된대로 uri 요청과 동일 함
                     HTTP / 1.1 기준
message-qop = "qop"EQUAL qop-value



Rosenberg, et. al. 표준 트랙 [쪽 227]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


cnonce = "cnonce"동일하게 cnonce-value
cnonce-value = nonce-value
nonce-count = "nc"등가의 nc 값
nc 값 = 8LHEX
dresponse = "응답"EQUAL 요청 - 요약
요청 다이제스트 = LDQUOT 32LHEX RDQUOT
auth-param = auth-param-name EQUAL
                     (토큰 / 인용 문자열)
auth-param-name = 토큰
other-response = auth-scheme LWS auth-param
                     * (COMMA auth-param)
auth-scheme = 토큰

인증 정보 = "인증 정보"HCOLON
 정보
                        * (COMMA ainfo)
ainfo = nextnonce / message-qop
                         / response-auth / cnonce
                         / nonce-count
nextnonce = "nextnonce"EQUAL nonce-value
response-auth = "rspauth"EQUAL 응답 - 다이제스트
응답 다이제스트 = LDQUOT * LHEX RDQUOT

통화 ID = ( "통화 ID"/ "i") HCOLON 통화 ID
callid = 단어 [ "@"단어]

호출 정보 = "호출 정보"HCOLON 정보 * (COMMA 정보)
정보 = LAQUOT 절대 값 RAQUOT * (SEMI 정보 - 매개 변수)
info-param = ( "목적"등호 ( "아이콘"/ "정보"
               / "카드"/ 토큰)) / generic-param

연락처 = ( "연락처"/ "m") HCOLON
                  (STAR ​​/ (contact-param * (COMMA contact-param)))
contact-param = (name-addr / addr-spec) * (SEMI contact-params)
name-addr = [표시 이름] LAQUOT addr-spec RAQUOT
addr-spec = SIP-URI / SIPS-URI / absoluteURI
display-name = * (토큰 LWS) / quoted-string

contact-params = c-p-q / c-p-expires
                      / contact-extension
c-p-q = "q"등가 qvalue
c-p-expires = "expires"EQUAL 델타 - 초
contact-extension = generic-param
델타 초 = 1 * DIGIT

콘텐츠 - 처분 = "콘텐츠 처분"HCOLON
                         disp 유형 * (SEMI disp-param)
disp-type = "render"/ "session"/ "icon"/ "alert"
                         / disp-extension-token



Rosenberg, et. al. 표준 트랙 [Page 228]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


disp-param = handling-param / generic-param
handling-param = "handling"EQUAL
                         ( "선택적"/ "필수"
                         / 기타 취급)
기타 처리 = 토큰
disp-extension-token = 토큰

콘텐츠 인코딩 = ( "콘텐츠 인코딩"/ "e") HCOLON
                     콘텐츠 코딩 * (COMMA 콘텐츠 코딩)

Content-Language = "Content-Language"HCOLON
                     언어 태그 * (COMMA 언어 태그)
language-tag = primary-tag * ( "-"서브 태그)
기본 태그 = 1 * 8ALPHA
하위 태그 = 1 * 8ALPHA

Content-Length = ( "Content-Length"/ "l") HCOLON 1 * DIGIT
Content-Type = ( "Content-Type"/ "c") HCOLON 미디어 유형
media-type = m-type SLASH m-subtype * (SEMI m- 매개 변수)
m 형 = 이산 형 / 복합 형
discrete-type = "text"/ "image"/ "audio"/ "video"
                    / "application"/ 확장 토큰
composite-type = "message"/ "multipart"/ extension-token
extension-token = ietf-token / x-token
ietf-token = 토큰
x-token = "x-"토큰
m-subtype = 확장 토큰 / iana-token
iana-token = 토큰
m- 매개 변수 = m- 속성 등가 m- 값
m 속성 = 토큰
m 값 = 토큰 / 인용 문자열

CSeq = "CSeq"HCOLON 1 * DIGIT LWS 방법

날짜 = "날짜"HCOLON SIP-date
SIP-date = rfc1123-date
rfc1123-date = wkday ","SP date1 SP time SP "GMT"
date1 = 2DIGIT SP 월 SP 4 디지털
                 ; 일 월 년 (예 : 1982 년 6 월 2 일)
시간 = 2DIGIT ":"2DIGIT ":"2DIGIT
                 ; 00:00:00 - 23:59:59
wkday = "월"/ "화"/ "수"
                 / "목"/ "금"/ "토"/ "일"
month = "Jan"/ "Feb"/ "Mar"/ "Apr"
                 / "5 월"/ "6 월"/ "7 월"/ "8 월"
                 / "Sep"/ "Oct"/ "Nov"/ "Dec"

오류 정보 = "오류 정보"HCOLON error-uri * (COMMA 오류 -URI)



Rosenberg, et. al. 표준 트랙 [Page 229]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


error-uri = LAQUOT 절대 값 RAQUOT * (SEMI 제네릭 매개 변수)

Expires = "Expires"HCOLON 델타 - 초
From = ( "From"/ "f") HCOLON from-spec
from-spec = (name-addr / addr-spec)
               * (SEMI에서 - 매개 변수)
from-param = tag-param / generic-param
tag-param = "tag"EQUAL 토큰

In-Reply-To = "In-Reply-To"HCOLON callid * (COMMA callid)

최대 - 전달 = "최대 - 전달"HCOLON 1 * 디지털

MIME-Version = "MIME-Version"HCOLON 1 * DIGIT "." 1 * DIGIT

최소 만료 = "최소 만료"HCOLON 델타 초

조직 = "조직"HCOLON [TEXT-UTF8-TRIM]

우선 순위 = "우선 순위"HCOLON 우선 순위 값
priority-value = "emergency"/ "emergency"/ "normal"
                   / "비 긴급"/ 기타 우선 순위
기타 우선 순위 = 토큰

Proxy-Authenticate = "프록시 인증"HCOLON 챌린지
challenge = ( "Digest"LWS digest-cln * (COMMA digest-cln))
                       / other-challenge
other-challenge = auth-scheme LWS auth-param
                       * (COMMA auth-param)
digest-cln = realm / domain / nonce
                        / opaque / stale / algorithm
                        / qop-options / auth-param
realm = "realm"EQUAL 영역 - 값
영역 - 값 = 따옴표 붙은 문자열
도메인 = "도메인"등호 LDQUOT URI
                       * (1 * SP URI) RDQUOT
URI = absoluteURI / abs-path
nonce = "nonce"EQUAL nonce-value
nonce-value = quoted-string
opaque = "opaque"EQUAL quoted-string
stale = "stale"EQUAL ( "true"/ "false")
알고리즘 = "알고리즘"EQUAL ( "MD5"/ "MD5-sess"
                       / 토큰)
qop-options = "qop"등호 LDQUOT qop-value
                       * ( ","qop-value) RDQUOT
qop-value = "auth"/ "auth-int"/ 토큰

Proxy-Authorization = "Proxy-Authorization"HCOLON 자격 증명



Rosenberg, et. al. 표준 트랙 [쪽 230]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


Proxy-Require = "Proxy-Require"HCOLON 옵션 태그
                  * (COMMA 옵션 태그)
option-tag = 토큰

Record-Route = "Record-Route"HCOLON rec-route * (COMMA rec-route)
rec-route = name-addr * (SEMI rr-param)
rr-param = generic-param

Reply-To = "Reply-To"HCOLON rplyto-spec
rplyto-spec = (name-addr / addr-spec)
                 * (SEMI rplyto-param)
rplyto-param = generic-param
Require = "Require"HCOLON 옵션 태그 * (COMMA 옵션 태그)

재시도 = "재시도 후"HCOLON 델타 초
                [의견] * (SEMI 재시도 - 매개 변수)

retry-param = ( "지속 시간"EQUAL 델타 - 초)
                / generic-param

Route = "Route"HCOLON route-param * (COMMA route-param)
route-param = name-addr * (SEMI rr-param)

서버 = "서버"HCOLON 서버 - 밸류 * (LWS 서버 - 밸류)
server-val = product / comment
제품 = 토큰 [SLASH product-version]
product-version = 토큰

제목 = ( "제목"/ "s") HCOLON [TEXT-UTF8-TRIM]

지원됨 = ( "지원됨"/ "k") HCOLON
              [option-tag * (콤마 옵션 태그)]

타임 스탬프 = "타임 스탬프"HCOLON 1 * (디지털)
               [ "." * (DIGIT)] [LWS 지연]
지연 = * (디지털) [ "." * (DIGIT)]

To = ( "To"/ "t") HCOLON (name-addr
             / addr-spec) * (SEMI에서 매개 변수로)
to-param = tag-param / generic-param

지원되지 않음 = "지원되지 않음"HCOLON 옵션 태그 * (COMMA 옵션 태그)
User-Agent = "User-Agent"HCOLON 서버 - 밸류 * (LWS 서버 - 밸류)








Rosenberg, et. al. 표준 트랙 [쪽 231]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


Via = ( "Via"/ "v") HCOLON via-parm * (COMMA via-parm)
via-parm = 전송 프로토콜 LWS * by (SEMI via-params)
via-params = via-ttl / via-maddr
                     / via-received / via-branch
                     / 경유지
via-ttl = "ttl"등식 ttl
via-maddr = "maddr"EQUAL 호스트
via-received = "received"EQUAL (IPv4 주소 / IPv6 주소)
via-branch = "branch"EQUAL 토큰
via-extension = generic-param
전송 프로토콜 = 프로토콜 이름 SLASH 프로토콜 버전
                     슬래시 전송
프로토콜 이름 = "SIP"/ 토큰
프로토콜 버전 = 토큰
전송 = "UDP"/ "TCP"/ "TLS"/ "SCTP"
                     / other-transport
sent-by = 호스트 [COLON 포트]
ttl = 1 * 3DIGIT; 0 ~ 255

경고 = "경고"HCOLON 경고 값 * (COMMA 경고 값)
경고 값 = 경고 코드 SP 경고 에이전트 SP 경고 텍스트
경고 코드 = 3DIGIT
warn-agent = 호스트 포트 / 가명
                  ; 서버의 이름 또는 가명
                  ; 디버그 용의 경고 헤더
warn-text = quoted-string
가명 = 토큰

WWW- 인증 = "WWW- 인증"HCOLON 챌린지

확장 헤더 = 헤더 이름 HCOLON 헤더 값
머리글 이름 = 토큰
header-value = * (TEXT-UTF8char / UTF8-CONT / LWS)
message-body = * OCTET

26 보안 고려 사항 : 위협 모델 및 보안 사용
   권장 사항

   SIP는 보안하기 쉬운 프로토콜이 아닙니다. 중개인의 사용,
   그 다중면 트러스트 관계, 그 사이의 예상 사용법
   전혀 신뢰하지 않는 엘리먼트들, 그리고 그것의 사용자 - 사용자 조작은
   안전은 사소한 것과는 거리가 멀다. 보안 솔루션이 필요합니다.
   광범위한 조정없이 오늘날 광범위하게 배포 가능
   환경 및 용도에 대한 이러한 다양한 요구를 충족시키기 위해,
   서로 다른 측면에 적용 할 수있는 몇 가지 별개의 메커니즘 및
   SIP의 사용이 요구됩니다.





Rosenberg, et. al. 표준 트랙 [232 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   SIP 신호 자체의 보안은
   RTP와 같이 SIP와 함께 사용되는 프로토콜의 보안 또는
   SIP가 수행 할 수있는 특정 기관의 보안 관련 내용
   (MIME 보안은 SIP 보안에 중요한 역할을하지만).
   세션과 관련된 모든 미디어는 엔드 투 엔드로 암호화 될 수 있습니다.
   관련된 SIP 시그널링과는 독립적으로 미디어 암호화
   이 문서의 범위 밖입니다.

   다음의 고려 사항은 먼저 고전적인 위협 집합을 검사합니다.
   SIP의 보안 요구를 광범위하게 식별하는 모델. 세트
   이러한 위협에 대처하기 위해 필요한 보안 서비스가 상세화되고,
   다음과 같은 몇 가지 보안 메커니즘에 대한 설명이 이어집니다.
   이러한 서비스를 제공하는 데 사용됩니다. 다음으로,
   예시적인 배치와 함께 SIP 구현자가 열거됩니다.
   이러한 보안 메커니즘을 사용하여
   SIP의 보안. 프라이버시에 대한 몇 가지주의 사항이이 섹션을 결론지었습니다.

26.1 공격 및 위협 모델

   이 섹션에서는 대부분의 공통적 인 위협 요소에 대해 자세히 설명합니다.
   SIP의 배치. 이러한 위협은 다음을 위해 특별히 선택되었습니다.
   SIP가 요구하는 각각의 보안 서비스를 설명합니다.

   다음 예제는 절대로
   SIP에 대한 위협; 오히려 이들은 "고전적인"위협입니다.
   특정 보안 서비스의 필요성을 보여줍니다.
   잠재적으로 모든 범주의 위협을 예방합니다.

   이러한 공격은 공격자가
   잠재적으로 네트워크상의 모든 패킷을 읽습니다.
   SIP는 공용 인터넷에서 자주 사용됩니다. 공격자
   네트워크가 패킷을 수정할 수 있습니다 (아마도 손상된 일부).
   중개인). 공격자는 서비스를 도용하고 도청하려고 할 수 있습니다.
   통신을 방해하거나 세션을 방해 할 수 있습니다.

26.1.1 등록 하이재킹

   SIP 등록 메커니즘은 사용자 에이전트가 자신을 식별 할 수있게합니다
   등록자에게 (주소에 의해 지정된) 사용자
   기록의)가 위치해 있습니다. 등록 기관은 다음에 주장 된 신원을 평가합니다.
   REGISTER 메시지의 From 헤더 필드를 사용하여
   요청은 해당 주소와 관련된 연락처 주소를 수정할 수 있습니다.
   To 헤더 필드에 레코드의 주소. 이 두 필드는
   자주 동일하게, 많은 유효한 배포가 있습니다.
   타사는 사용자를 대신하여 연락처를 등록 할 수 있습니다.






Rosenberg, et. al. 표준 트랙 [Page 233]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   그러나 SIP 요청의 From 헤더 필드는 수정할 수 있습니다
   UA의 소유자가 임의로
   악의적 인 등록. 성공적으로 가장 한 공격자
   주소와 관련된 연락처를 변경하도록 허가 된 당사자는,
   레코드는 예를 들어,
   URI를 입력하고 자신의 장치를 적절한 연락처로 등록하십시오.
   주소로 전송하여 해당 사용자에 대한 모든 요청을
   공격자의 장치.

   이 위협은 부재에 의존하는 위협의 가족에 속합니다.
   요청자의 송신자에 대한 암호 보증. 모든 SIP UAS
   귀중한 서비스 (SIP와 상호 작용하는 게이트웨이
   예를 들어, 전통적인 전화 통화의 요청)은
   요청을 인증하여 리소스에 대한 액세스를 제어합니다.
   받습니다. SIP 전화와 같은 최종 사용자 UA조차도
   요청자의 신분을 확인하는 데 관심이있다.

   이 위협은 다음을 가능하게하는 보안 서비스의 필요성을 보여줍니다.
   요청의 발신자를 인증하는 SIP 엔티티.

26.1.2 서버 위장

   요청이 예정된 도메인은 일반적으로 다음과 같이 지정됩니다.
   요청 URI. UA는 일반적으로이 도메인의 서버에 접속합니다.
   요청을 전달하기 위해 직접. 그러나 항상
   공격자가 원격 서버를 가장 할 수있는 가능성
   UA의 요청이 다른 당사자에 의해 가로 챌 수 있다는 것.

   예를 들어 하나의 리디렉션 서버가
   도메인, chicago.com, 다른 서버에서 리디렉션 서버로 가장합니다.
   도메인, biloxi.com. 사용자 에이전트가 biloxi.com에 요청을 보냅니다.
   chicago.com의 리디렉션 서버가 위조 된 응답으로 응답합니다.
   응답에 적합한 SIP 헤더 필드가있는
   biloxi.com. 리디렉션 응답의 위조 된 연락처 주소
   원래의 UA가 부적절하거나 안전하지 못하도록 지시 할 수있다.
   리소스를 사용하거나 단순히 biloxi.com에 대한 요청이 성공하지 못하게 할 수 있습니다.

   이 위협 요소 군은 방대한 회원을 보유하고 있으며 그 중 다수가
   결정적인. 등록 하이재킹 위협과 관련하여,
   biloxi.com으로 보낸 등록이
   chicago.com에 의해 가로채는, 도청 된 사람에게 응답합니다.
   단조 301 (영구 이사) 응답으로 등록하십시오. 이
   응답은 biloxi.com에서오고 chicago.com을 지정하는 것처럼 보일 수 있습니다.
   적절한 등록 기관으로 이후의 모든 REGISTER 요청
   원래 UA는 chicago.com으로 이동합니다.

   이 위협을 예방하려면 UA가 수행 할 수있는 수단이 필요합니다.
   요청을 보내는 서버를 인증합니다.



Rosenberg, et. al. 표준 트랙 [Page 234]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


26.1.3 메시지 본문 조작

   물론 SIP UA는 신뢰할 수있는 프록시를 통해 요청을 라우팅합니다.
   서버. 그 신뢰가 어떻게 확립 되든간에 (인증
   프록시에 대한 설명은이 섹션의 다른 곳에서 논의됩니다), UA는
   프록시 서버가 요청을 라우팅하지만 검사하지 않거나 가능하면
   해당 요청에 포함 된 본문을 수정하십시오.

   세션을 전달하기 위해 SIP 메시지 본문을 사용하는 UA를 고려하십시오.
   미디어 세션의 암호화 키 프록시를 신뢰하지만
   시그널을 적절하게 전달하기 위해 접촉하고있는 도메인의 서버,
   해당 도메인의 관리자가 가능하지 않을 수도 있습니다.
   후속 미디어 세션의 암호를 해독합니다. 더 나쁜 것은, 프록시
   서버가 적극적으로 악의적이었고, 세션 키를 수정할 수 있었으며,
   중간자 인 것처럼 행동하거나,
   발신 UA가 요청한 보안 특성.

   이 위협 요소 군은 세션 키뿐만 아니라 대부분의 위협에도 적용됩니다.
   상상할 수없는 형태의 컨텐츠가 SIP에서 엔드 - 투 - 엔드로 전달되었습니다. 이것들은
   사용자에게 렌더링해야하는 MIME 본문, SDP 또는
   캡슐화 된 전화 신호 등을 포함한다. 공격자가
   예를 들어 RTP를 가리 키기 위해 SDP 본문을 수정하려고 시도합니다.
   엿듣기 위해 도청 장치로 미디어 스트리밍
   후속 음성 통신.

   또한 SIP의 일부 헤더 필드는 의미있는 종단 간 (end-to-end)
   예를 들어 제목. UA가 이러한 헤더 필드를 보호 할 수 있습니다.
   뿐만 아니라 기관 (주제를 변경하는 악의적 인 중개자
   헤더 필드는 중요한 요청을 스팸으로 보일 수 있습니다.
   예). 그러나 많은 헤더 필드가 합법적이기 때문에
   요청이 라우팅 될 때 프록시 서버에 의해 검사되거나 변경됩니다.
   헤더 필드는 종단 간 (end-to-end)으로 보안되어야한다.

   이러한 이유로 UA는 SIP 메시지 본문을 보호하려고 할 수 있으며,
   일부 제한된 경우 헤더 필드가 종단 간입니다. 보안
   시체에 필요한 서비스에는 기밀성, 무결성 및
   입증. 이러한 엔드 - 투 - 엔드 서비스는
   중개자와의 상호 작용을 확보하는 데 사용되는 수단
   프록시 서버.

26.1.4 세션 중단

   초기 메시징에 의해 다이얼로그가 설정되면,
   대화 상자의 상태를 수정하는 요청을 보낼 수 있습니다.
   세션. 세션에서 교장이 확실 할 수있는 것이 중요합니다.
   그러한 요청은 공격자에 의해 위조되지 않는다.





Rosenberg, et. al. 표준 트랙 [Page 235]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   타사 공격자가 일부 초기 공격자를 포착 한 경우를 생각해보십시오.
   대화를 나누기 위해 두 당사자가 공유하는 대화 상자의 메시지
   세션의 매개 변수 (To 태그, From 태그 등)와
   BYE 요청을 세션에 삽입합니다. 공격자는 다음을 선택할 수 있습니다.
   요청을 위조하여
   참가자. BYE가 목표에 의해 수신되면, 세션
   조숙하게 찢어 질 것이다.

   비슷한 중간 세션 위협으로는 위조 된 재 -
   세션을 변경하는 INVITE (세션 보안을 줄이기 위해
   미디어 스트림을 도청 공격의 ​​일부로 리다이렉트).

   이 위협에 대한 가장 효과적인 대응책은
   BYE 송신자의 인증. 이 경우,
   수령인은 BYE가 다음과 같은 당사자로부터 왔음을 알 필요가 있습니다.
   해당 대화가 설정된 사람 (
   보낸 사람의 절대적인 신원 확인). 또한,
   공격자는 다음과 같은 이유로 세션의 매개 변수를 알 수 없습니다.
   기밀 유지, BYE 위조는 불가능합니다. 하나,
   일부 중개자 (프록시 서버와 같은)는
   세션이 확립 될 때 매개 변수

26.1.5 서비스 거부 및 증폭

   특정 네트워크 렌더링에 초점을 맞춘 서비스 거부 (DoS) 공격
   요소를 사용할 수없는 경우, 일반적으로 과도한 양의
   인터페이스에서 네트워크 트래픽. 분산 형 서비스 거부
   공격은 한 네트워크 사용자가 여러 네트워크 호스트가
   대량의 네트워크 트래픽으로 대상 호스트에 범람.

   많은 아키텍처에서 SIP 프록시 서버는 공용 인터넷에 직면 해 있습니다.
   전세계 IP 종단점의 요청을 수락합니다. SIP는
   분산 형 서비스 거부에 대한 잠재적 기회의 수
   구현 자들에 의해 인식되고 다루어 져야하는 공격들.
   SIP 시스템 운영자.

   공격자는 변조 된 소스가 포함 된 가짜 요청을 만들 수 있습니다.
   IP 주소 및 해당 Via 헤더 필드
   타겟 호스트를 요청의 발신자로 지정하고 다음을 보냅니다.
   다수의 SIP 네트워크 요소에 요청하여
   DoS (Denial-Of-Service) 트래픽을 생성하는 불운 한 SIP UA 또는 프록시
   목표물을 겨냥했다.

   마찬가지로 공격자는 다음과 같은 경우에 위장 된 Route 헤더 필드 값을 사용할 수 있습니다.
   대상 호스트를 식별하고 그런 메시지를 보내는 요청
   대상에게 보내는 메시징을 증폭시키는 프록시 포크 (forking proxies).





Rosenberg, et. al. 표준 트랙 [Page 236]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   Record-Route는 공격자가
   요청에 의해 시작된 SIP 대화 상자가
   역방향으로 시작된 수많은 거래.

   REGISTER 요청시 다수의 서비스 거부 (DoS) 공격이 시작됩니다.
   등록 기관이 적절히 인증하고 권한을 부여받지 못합니다.
   공격자는 관리자의 일부 또는 모든 사용자를 등록 취소 할 수 있습니다.
   도메인에 추가하여 이러한 사용자가 새로운 사용자로 초대되는 것을 방지 할 수 있습니다.
   세션. 공격자는 많은 수의 대화 상대를 등록 할 수도 있습니다
   지정된 주소 레코드에 대해 동일한 호스트를 지정하여
   레지스트라 및 관련 프록시 서버를
   DoS (Denial-of-Service) 공격. 공격자는 또한 고갈을 시도 할 수 있습니다
   등록으로 등록자의 사용 가능한 메모리 및 디스크 리소스
   엄청난 수의 바인딩.

   SIP 요청을 전송하기 위해 멀티 캐스트를 사용하면 크게 증가 할 수 있습니다
   DoS (Denial-of-Service) 공격의 가능성.

   이러한 문제는 아키텍처를 정의해야하는 일반적인 필요성을 보여줍니다.
   서비스 거부 (DoS) 위험을 최소화하고 필요성을 최소화해야합니다.
   이 클래스의 보안 메커니즘 권장 사항을 염두에 두십시오.
   공격.

26.2 보안 메커니즘

   위에서 설명한 위협으로부터 우리는
   SIP 프로토콜에 필요한 보안 서비스는 다음과 같습니다.
   메시징의 기밀성과 무결성, 재연 공격 방지
   또는 메시지 스푸핑, 인증 및 개인 정보 보호 제공
   세션 참가자 및 서비스 거부 방지
   공격. SIP 메시지 내의 본문에는 보안이 별도로 필요합니다.
   기밀 유지, 무결성 및 인증 서비스

   SIP에 고유 한 새로운 보안 메커니즘을 정의하는 대신 SIP
   기존의 보안 모델을 가능한 한 재사용합니다.
   HTTP 및 SMTP 공간.

   메시지를 완전히 암호화하면 메시지를 보존하는 가장 좋은 방법입니다.
   시그널링의 기밀 유지 - 메시지
   악의적 인 중개인에 의해 수정되지 않습니다. 그러나, SIP
   요청과 응답은 순전히 엔드 - 투 - 엔드로 암호화 될 수 없습니다.
   Request-URI, Route,
   Via는 대부분의 네트워크 아키텍처에서 프록시에 표시되어야합니다.
   SIP 요청은 올바르게 라우팅됩니다. 프록시 서버
   메시지의 일부 기능을 수정해야합니다 (예 : 비아 추가
   헤더 필드 값)을 설정합니다. 프록시 서버
   따라서 SIP UA에 의해 어느 정도 신뢰되어야합니다. 이에
   SIP를위한 다목적, 하위 계층 보안 메커니즘이 권장됩니다.



Rosenberg, et. al. 표준 트랙 [쪽 237]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   홉 (hop) 기반의 회선에서 전체 SIP 요청 또는 응답을 암호화합니다.
   홉별 기준을 사용하고 끝점에서
   프록시 서버는 요청을 보냅니다.

   SIP 엔티티는 또한 보안에서 서로를 식별 할 필요가 있습니다.
   유행. SIP 종점이 사용자의 신원을
   피어 UA 또는 프록시 서버에 연결해야합니다.
   증명할 수 있는. 암호 인증 메커니즘은 다음에서 제공됩니다.
   SIP는이 요구 사항을 해결합니다.

   SIP 메시지 본문에 대한 독립적 인 보안 메커니즘은
   엔드 - 투 - 엔드 상호 인증의 대체 수단뿐만 아니라
   사용자 에이전트가 신뢰해야하는 정도에 대한 제한을 제공
   중개인.

26.2.1 전송 및 네트워크 계층 보안

   전송 또는 네트워크 계층 보안은 신호 트래픽을 암호화하고,
   메시지 기밀성 및 무결성을 보장합니다.

   종종 인증서는 하위 계층의 설정에 사용됩니다
   보안 및 이러한 인증서는 또한 수단을 제공하는 데 사용할 수 있습니다
   많은 아키텍처에서 인증.

   전송시 보안을 제공하는 두 가지 인기있는 대안
   네트워크 계층은 각각 TLS [25]와 IPSec [26]이다.

   IPSec은 네트워크 계층 프로토콜 도구 세트로서
   전통적인 IP (인터넷
   실험 계획안). IPSec은 다음과 같은 아키텍처에서 가장 일반적으로 사용됩니다.
   호스트 또는 관리 도메인 집합에 기존 신뢰가 있습니다.
   서로의 관계. IPSec은 일반적으로
   호스트의 운영 체제 수준 또는 보안 게이트웨이에서
   수신하는 모든 트래픽에 대해 기밀성과 무결성을 제공합니다.
   특정 인터페이스 (VPN 아키텍처에서와 같이)에서. IPSec 수 있습니다
   또한 hop-by-hop 기반으로 사용될 수 있습니다.

   많은 아키텍처에서 IPSec은 SIP와의 통합을 필요로하지 않습니다.
   응용 프로그램; IPSec은
   SIP 호스트에 직접 보안을 추가하는 것은 어려울 것입니다. 저것
   첫 번째 홉 프록시와 사전 공유 키잉 관계가있다.
   서버는 IPSec을 사용하기에 적합한 후보입니다. 모든 배포
   SIP 용 IPSec에는 프로토콜을 설명하는 IPSec 프로필이 필요합니다.
   SIP 보안에 필요한 도구 그러한 프로필이 제공되지 않습니다.
   이 문서에서






Rosenberg, et. al. 표준 트랙 [Page 238]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   TLS는 연결 지향 보안보다 전송 계층 보안을 제공합니다.
   프로토콜 (이 문서의 목적 상, TCP); "tls"(
   TCP를 통한 TLS)는 원하는 전송 프로토콜로 지정할 수 있습니다
   Via 헤더 필드 값 또는 SIP-URI 내에서. TLS는 다음에 가장 적합합니다.
   호스트간에 hop-by-hop 보안이 필요한 아키텍처
   기존의 신뢰 관계가없는 예를 들어, Alice는
   인증서 교환 후 결정한 그녀의 로컬 프록시 서버
   Bob이 신뢰하는 Bob의 로컬 프록시 서버를 신뢰합니다. 따라서 Bob과 Alice
   안전하게 통신 할 수 있습니다.

   TLS는 SIP 응용 프로그램과 긴밀하게 결합되어야합니다. 유의 사항
   전송 메커니즘은 SIP에서 hop-by-hop 기반으로 지정되므로
   TLS를 통해 요청을 프록시 서버로 보내는 UA는 아무런 보증도하지 않습니다.
   그 TLS는 종단 간 (end-to-end)으로 사용될 것입니다.

   TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite [6]를에서 지원해야한다.
   TLS가 SIP 응용 프로그램에서 사용될 때 구현 자의 최소 요구 사항. 에 대한
   이전 버전과의 호환성, 프록시 서버, 리디렉션 서버,
   레지스트라는 TLS_RSA_WITH_3DES_EDE_CBC_SHA를 지원해야한다.
   구현자는 다른 암호문을 지원할 수도있다 (MAY).

26.2.2 SIPS URI 스킴

   SIPS URI 스키마는 SIP URI의 구문을 준수합니다 (
   19에서), 스킴 문자열은 "한 모금"보다는 "모금"됩니다. 그만큼
   그러나 SIPS의 의미는 SIP URI와 매우 다릅니다. SIPS
   리소스가 안전하게 도달해야한다고 지정할 수 있습니다.

   SIPS URI는 특정 사용자에 대한 레코드 주소로 사용될 수 있습니다
   - 사용자가 정식으로 알 수있는 URI (비즈니스에서 사용)
   To 헤더의 From 헤더 필드에
   REGISTER 요청 필드). Request-URI로 사용할 때
   요청 인 경우, SIPS 체계는
   요청이 SIP 엔터티에 도달 할 때까지 요청이 전달됩니다.
   Request-URI의 도메인 부분을 담당하는
   TLS로 보안. 문제의 도메인에 도달하면
   로컬 보안 및 라우팅 정책에 따라 처리
   UAS의 마지막 홉에 대해 TLS를 사용하는 것입니다. 사용하는 경우
   요청의 발신자 (SIPS를 사용하는 경우처럼)
   URI를 대상의 레코드 주소로 사용) SIPS는
   대상 도메인에 대한 전체 요청 경로가 보안되어야합니다.

   SIPS 체계는 SIP
   URI는 Request-URI 이외에 오늘날 SIP에서 사용됩니다.
   주소 기록에서 연락처 주소 (연락처의 내용
   헤더 메소드 (REGISTER 메소드의 헤더 포함) 및 라우트 헤더. 에서
   각 인스턴스에서 SIPS URI 스킴은 이러한 기존 필드가




Rosenberg, et. al. 표준 트랙 [Page 239]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   안전한 자원을 지정하십시오. SIPS URI가
   이러한 컨텍스트에서 참조 해제 된 것은 고유 한 보안 등록 정보를가집니다.
   이것들은 [4]에 자세히 나와있다.

   특히 SIPS를 사용하면 상호 TLS 인증이 필요합니다.
   ciphersuite와 같이 고용되어야한다 (SHOULD).
   TLS_RSA_WITH_AES_128_CBC_SHA. 받은 인증서
   인증 프로세스는 루트 인증서로 검증되어야합니다 (SHOULD).
   클라이언트에 의해 개최; 인증서의 유효성을 검증하지 못한 결과
   요청 실패시.

      SIPS URI 스킴에서, 전송은 TLS와 독립적이며,
      따라서 "얼간이 : alice@atlanta.com; 전송 = tcp"및
      "sips : alice@atlanta.com; transport = sctp"는 둘 다 유효합니다 (비록
      UDP는 SIPS에 대한 유효한 전송이 아닙니다. 의 사용
      따라서 "transport = tls"는 더 이상 사용되지 않습니다.
      그것은 요청의 단일 홉에만 해당됩니다. 이것은 변화이다.
      RFC 2543부터.

   SIPS URI를 주소 레코드로 배포하는 사용자는
   안전하지 않은 전송을 통해 요청을 거부하는 장치를 작동합니다.

26.2.3 HTTP 인증

   SIP는 HTTP 인증을 기반으로하는 챌린지 기능을 제공하며,
   401과 407 응답 코드와 헤더에 의존합니다.
   도전과 신임장을 운반하기위한 필드. 중요하지 않은
   수정, HTTP 다이제스트 인증 스키마의 재사용
   SIP는 재생 방지 및 단방향 인증을 허용합니다.

   SIP에서의 다이제스트 인증 사용은 섹션 22에 자세히 설명되어 있습니다.

26.2.4 S / MIME

   전술 한 바와 같이, 전체 SIP 메시지를 엔드 - 투 - 엔드에 대해
   기밀성의 목적은 네트워크가
   중개자 (프록시 서버와 같은)는 특정 헤더를 볼 필요가 있습니다.
   필드를 사용하여 메시지를 올바르게 라우팅하고,
   중개자가 보안 연결에서 제외되면 SIP
   메시지는 기본적으로 라우팅 할 수 없습니다.

   그러나 S / MIME을 사용하면 SIP UA가 SIP 내에서 MIME 본문을 암호화 할 수 있으므로,
   메시지 헤더에 영향을 미치지 않고 엔드 투 엔드 (end-to-end) 보안을 유지합니다.
   S / MIME은 엔드 투 엔드 기밀성을 제공 할 수 있으며

무결성
   메시지 본문 및 상호 인증을 제공합니다. 그것은 또한이다
   S / MIME을 사용하여 무결성 및
   SIP 메시지 터널링을 통한 SIP 헤더 필드에 대한 기밀성.




Rosenberg, et. al. 표준 트랙 [Page 240]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   SIP에서의 S / MIME 사용은 23 절에 자세히 설명되어 있습니다.

26.3 보안 메커니즘 구현

26.3.1 SIP 구현 자 요구 사항

   프록시 서버, 리디렉션 서버 및 등록 기관은 TLS,
   상호 및 단방향 인증을 모두 지원해야합니다 (MUST). 그것은
   UA가 TLS를 시작할 수 있다고 강력히 권고합니다. UA는 MAY 일 수도있다
   TLS 서버로 작동 할 수 있어야합니다. 프록시 서버, 리디렉션
   서버 및 등록 기관은 사이트 인증서를 소지해야합니다.
   subject는 정규 호스트 이름에 해당합니다. UA가 가질 수 있음
   TLS와의 상호 인증을위한 자체 인증서
   이 문서에서 사용을위한 조항이 명시되어 있습니다. 모든 SIP
   TLS를 지원하는 요소는 검증을위한 메커니즘을 가져야합니다
   TLS 협상 중에받은 인증서 이것은 소유물을 수반한다.
   인증 기관에서 발급 한 하나 이상의 루트 인증서
   (바람직하게는 사이트 인증서의 잘 알려진 유통 업체를 비교할 수 있습니다
   웹 브라우저에서 루트 인증서를 발급 한 사람에게).

   TLS를 지원하는 모든 SIP 요소는 SIPS URI도 지원해야합니다 (MUST).
   계획.

   프록시 서버, 리디렉션 서버, 등록 기관 및 UA는 MAY 일 수도 있습니다
   IPSec 또는 다른 하위 계층 보안 프로토콜을 구현합니다.

   UA가 프록시 서버, 리디렉션 서버 또는
   UAC는 TLS 연결을 초기화해야합니다.
   SIP 메시지를 보냅니다. 일부 아키텍처에서는 UAS가
   이러한 TLS 연결을 통한 요청도 마찬가지입니다.

   프록시 서버, 리디렉션 서버, 등록자 및 UA는 반드시 구현해야합니다
   22에서 요구되는 모든 측면을 포함하는 다이제스트 인증.
   프록시 서버, 리디렉션 서버 및 등록자를 구성해야합니다.
   적어도 하나의 다이제스트 영역과 적어도 하나의 "영역"문자열
   주어진 서버에 의해 지원되는 서버의
   호스트 이름 또는 도메인 이름.

   UA는 MIME 시체의 서명 및 암호화를 지원할 수 있으며,
   23 절에서 설명한 바와 같이 S / MIME을 통한 자격 증명의 이전.
   UA가 하나 이상의 인증서 루트 인증서를 보유하고있는 경우
   TLS 또는 IPSec에 대한 인증서의 유효성을 검사하기 위해
   S / MIME 인증서를 검증하기 위해 이것들을 재사용 할 수 있어야한다.
   적당한. UA는 특히
   S / MIME 인증서의 유효성 검사.






Rosenberg, et. al. 표준 트랙 [Page 241]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      향후의 보안 확장이
      S / MIME과 관련된 규범 적 강도를 S / MIME로 업그레이드
      구현이 나타나고 문제 공간이 개선됩니다.
      이해했다.

26.3.2 보안 솔루션

   이러한 보안 메커니즘의 작동은
   기존 웹 및 전자 메일 보안 모델을 어느 정도까지 지원합니다. 높은 곳에
   레벨, UA는 서버 (프록시 서버,
   리디렉션 서버 및 등록 기관)에 다이제스트 사용자 이름 및
   암호; 서버는 멀리 떨어진 곳으로 UA를 인증하거나
   다른 서버가 한 번 홉 (그리고 그 반대), 사이트 인증서와 함께
   TLS에서 제공합니다.

   피어 투 피어 수준에서 UA는 네트워크를 신뢰하여 인증합니다.
   보통 다른; 그러나 S / MIME을 사용하여
   네트워크가 없을 때 직접 인증 또는 네트워크가
   자체가 신뢰되지 않습니다.

   다음은 이러한 보안
   다양한 UA와 서버가 메커니즘을 사용하여 정렬을 방지합니다.
   26.1 절에 설명 된 위협에 대해 설명합니다. 구현 자와 네트워크
   행정관은에 주어진 규범 적 지침을 따를 수있다.
   이 절의 나머지 부분은 예제로만 제공됩니다.
   구현.

26.3.2.1 등록

   UA가 온라인에 접속하여 해당 지역 행정부에 등록하면
   도메인 인 경우 레지스트라와 TLS 연결을 설정해야합니다
   (섹션 10에서는 UA가 레지스트라에 어떻게 도달하는지 설명합니다). 그만큼
   레지스트라는 UA에 인증서를 제공해야하며, 사이트
   인증서로 식별되는 도메인은
   UA가 등록하고자하는 예를 들어, UA가
   기록 주소 'alice@atlanta.com'을 등록하고, 사이트
   인증서는 atlanta.com 도메인 내의 호스트를 식별해야합니다 (예 :
   sip.atlanta.com). TLS 인증서 메시지를 수신하면,
   UA는 인증서를 검증하고 식별 된 사이트를 조사해야한다.
   인증서로. 인증서가 유효하지 않거나 해지되거나 인증서가
   해당 당사자를 식별하지 못하면 UA는
   REGISTER 메시지를 보내고 그렇지 않으면 등록을 진행하십시오.

      등록 기관이 유효한 인증서를 제공하면
      UA는 레지스트라가 리디렉션 할 수있는 공격자가 아님을 알고 있습니다.
      UA, 암호를 도용하거나 유사한 공격을 시도 할 수 있습니다.





Rosenberg, et. al. 표준 트랙 [Page 242]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   그런 다음 UA는 REGISTER 요청을 만들어야한다.
   Request-URI로부터 수신 한 사이트 인증서에 해당하는 URI
   기록 사무관. UA가 REGISTER 요청을 기존
   TLS 연결에서 등록 기관은 401로 요청을 요청해야합니다 (SHOULD).
   (프록시 인증 필요) 응답. "영역"매개 변수
   응답의 Proxy-Authenticate 헤더 필드 내에 있어야한다.
   이전에 사이트 인증서에서 제공 한 도메인에 해당합니다.
   UAC가 챌린지를 수신하면 UAC는 사용자에게
   자격 증명을 얻거나 키링에서 적절한 자격 증명을 가져옵니다.
   챌린지의 "영역"매개 변수에 해당합니다. 그만큼
   이 신임장의 사용자 이름은 "userinfo"와 일치해야합니다 (SHOULD)
   REGISTER 요청의 To 헤더 필드에있는 URI의 일부.
   다이제스트 자격 증명이 적절한
   Proxy-Authorization 헤더 필드는 REGISTER를 다시 제출해야합니다.
   레지스트라에게.

      레지스트라는 사용자 에이전트가 인증을 요구하므로
      그 자체로, 공격자가 REGISTER를 위조하는 것은 어려울 것이다.
      사용자의 주소 레코드 요청 또한
      REGISTER는 기밀 TLS 연결을 통해 전송되고 공격자는
      자격 증명을 기록하기 위해 REGISTER를 인터셉트 할 수 없습니다
      가능한 모든 재생 공격.

   레지스트라가 등록을 수락하면 UA
   등록자가 제공 한 경우이 TLS 연결을 열어 두어야합니다 (SHOW).
   또한 사용자가 요청한 프록시 서버 역할을합니다.
   이 관리 도메인. 기존 TLS 연결은
   방금 완료 한 UA에 들어오는 요청을 전달하기 위해 다시 사용됩니다.
   기재.

      UA는 이미 다른 서버에서 서버를 인증했기 때문에
      TLS 연결의 한 쪽,이 요청과 관련된 모든 요청
      연결이 프록시 서버를 통과 한 것으로 알려져 있음 -
      공격자는 스푸핑 된 요청을 생성 할 수 없습니다.
      해당 프록시 서버를 통해 보냈습니다.

26.3.2.2 도메인 간 요청

   Alice의 UA가 다음과 같은 세션을 시작하려고합니다.
   원격 관리 도메인의 사용자, 즉 "bob@biloxi.com"입니다. 우리
   지방 행정 도메인 (atlanta.com)에는
   로컬 아웃 바운드 프록시

   관리에 대한 인바운드 요청을 처리하는 프록시 서버
   도메인은 또한 로컬 아웃 바운드 프록시 역할을 할 수있다. 단순함을 위해서
   우리는 이것을 atlanta.com의 경우라고 가정합니다 (그렇지 않으면 사용자
   에이전트는 별도의 서버에 새 TLS 연결을 시작합니다.
   이 시점). 클라이언트가 등록을 완료했다고 가정합니다.



Rosenberg, et. al. 표준 트랙 [Page 243]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   프로세스는 이전 절에서 설명한대로 TLS를 재사용해야합니다
   INVITE 요청을 보낼 때 로컬 프록시 서버에 연결
   다른 사용자에게. UA는 캐시 된 자격 증명을
   사용자를 불필요하게 묻지 않도록 초대하십시오.

   로컬 아웃 바운드 프록시 서버가 자격 증명의 유효성을 검사하면
   INVITE에서 UA에 의해 제시되면 Request-URI를 조사해야한다.
   메시지가 어떻게 라우팅되어야 하는지를 결정한다 ([4] 참조). 만약
   Request-URI의 "domainname"부분은
   도메인 (atlanta.com)이 아닌 biloxi.com을 사용하면 프록시 서버
   가장 좋은 방법을 결정하기 위해 위치 서비스에 문의했을 것입니다.
   요청한 사용자에게 연락하십시오.

      "alice@atlanta.com"이 (가) 연락하려고 시도했다면,
      "alex@atlanta.com", 로컬 프록시는
      알렉스는 TLS 연결에 대한 요청을
      그가 등록 할 때 등록 원. Alex가 이것을받을 것이기 때문에
      인증 된 채널을 통해 요청하면 그는
      앨리스의 요청이 해당 프록시 서버에 의해 승인되었습니다.
      로컬 관리 도메인.

   그러나이 경우 Request-URI는 원격 도메인을 지정합니다.
   따라서 atlanta.com의 로컬 아웃 바운드 프록시 서버는
   에서 원격 프록시 서버와 TLS 연결을 설정하십시오.
   biloxi.com. 이 TLS 연결의 참가자 모두
   사이트 인증서, 상호 TLS 인증을 보유한 서버
   해야한다. 연결의 각면은 확인하고 검사해야합니다
   다른 도메인의 인증서로서 도메인 이름에 표시됩니다.
   SIP의 헤더 필드와의 비교를위한 증명서
   메시지. atlanta.com 프록시 서버 (예 : SHOULD verify)
   이 단계에서 원격 측에서받은 인증서
   biloxi.com 도메인에 해당합니다. 일단 그렇게하면 TLS
   협상이 완료되어
   두 개의 프록시 인 atlanta.com 프록시는 INVITE 요청을
   biloxi.com.

   biloxi.com의 프록시 서버는 인증서를 검사해야합니다.
   atlanta.com에서 프록시 서버를 차례로 실행하고 주장 된 도메인을 비교합니다.
   From 헤더의 "domainname"부분이있는 인증서로
   필드를 포함한다. 빌럭시 프록시는 엄격한
   일치하지 않는 요청을 거부해야하는 보안 정책
   그들이 프록시 된 관리 도메인

      이러한 보안 정책은 SIP
      자주 사용되는 SMTP '오픈 릴레이'와 동일한 기능을 수행합니다.
      스팸을 생성합니다.





Rosenberg, et. al. 표준 트랙 [Page 244]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   그러나이 정책은 요청이
   그것 자체로 기인하는 영역; biloxi.com은 (는) 허용하지 않습니다.
   atlanta.com이 Alice를 어떻게 인증했는지 확인하십시오. biloxi.com 인 경우에만
   atlanta.com의 인증 정책을 아는 다른 방법이 있습니다.
   앨리스가 어떻게 자신의 정체성을 증명했는지 확인할 수 있습니까?
   biloxi.com은 더 엄격한 정책을 제정하여
   관리 상으로 알려지지 않은 도메인에서 오는 요청
   biloxi.com과 공통된 인증 정책을 공유 할 수 있습니다.

   일단 INVITE가 biloxi 프록시에 의해 승인되면 프록시
   서버는 기존의 TLS 채널을 식별해야한다 (존재한다면).
   이 요청에 의해 타겟팅 된 사용자와 함께 (이 경우
   "bob@biloxi.com"). INVITE는이 채널을 통해 프록시되어야합니다.
   Bob에게. 요청은 TLS 연결을 통해 수신되므로
   이전에 biloxi 프록시로 인증 된 Bob은
   From 헤더 필드는 조작되지 않았으며 atlanta.com은
   검증 된 앨리스, 반드시 신뢰할 지 여부는 불문
   앨리스의 신원.

   그들이 요청을 전달하기 전에 두 프록시 서버는
   Record-Route 헤더 필드를 요청에 전달하여 향후 모든 요청
   이 대화 상자에서 프록시 서버를 통과하게됩니다. 프록시
   서버는 이에 따라 보안 서비스를 계속 제공 할 수 있습니다.
   이 대화 상자의 수명. 프록시 서버가 스스로 추가하지 않으면
   Record-Route로 향하면 앞으로의 메시지는 직접 엔드 투 엔드로 전달됩니다.
   앨리스와 밥 사이에 보안 서비스없이
   당사자들은 다음과 같은 일부 독립적 인 종단 간 보안에 동의합니다.
   S / MIME). 이 관점에서 SIP 사다리꼴 모델은 좋은
   사이트 프록시 사이의 합의 컨벤션
   Alice와 Bob간에 합리적으로 안전한 채널을 제공합니다.

      이 아키텍처를 먹어 치는 공격자는 예를 들어
      BYE 요청을 위조 할 수없고 시그널링에 삽입 할 수 없다.
      Bob과 Alice 사이의 스트리밍
      세션의 매개 변수를 확인하고
      무결성 메커니즘은 사이의 트래픽을 전이 적으로 보호합니다.
      앨리스와 밥.

26.3.2.3 피어 - 투 - 피어 요청

   또는 신원을 확인하는 UA를 고려해보십시오.
   로컬 아웃 바운드 프록시가없는 "carol@chicago.com" 캐롤
   그녀의 UA가 "bob@biloxi.com"에게 INVITE를 보내길 원한다.
   biloxi 프록시와 직접 TLS 연결 (메커니즘 사용)
   [4]에서 주어진 것에 도달하는 최선의 방법을 결정하기 위해 설명했다.
   Request-URI). 그녀의 UA가 빌 록시
   프록시, 그것은 그녀가 그녀의 INVITE를 패스하기 전에 정상적으로 검증되어야한다.
   TLS 연결을 통해. 그러나 캐롤은 증명할 수단이 없다.



Rosenberg, et. al. 표준 트랙 [Page 245]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   그녀의 정체를 빌 록시 프록시에게 넘겼지 만 그녀는 CMS가 분리되어있다.
   INVITE의 "message / sip"본문에 대한 서명. 에서 가능성은 희박하다.
   Carol이 biloxi.com에 어떤 신임장도 가지고있을이 인스턴스
   그녀는 biloxi.com과 공식적인 관계가 없기 때문에 그만큼
   biloxi 대리인은 또한 그것을 금지하는 엄격한 정책을 가질 수 있습니다.
   심지어 biloxi.com이없는 요청에 도전하는 것을 괴롭힌다.
   From 헤더 필드의 "domainname"부분입니다.
   인증되지 않은 사용자.

   biloxi 프록시에는 Bob에게 모든 인증되지 않은 정책이 있습니다.
   요청은 해당 연락처 주소로 리디렉션되어야합니다.
   'bob@biloxi.com', 즉 <sip : bob@192.0.2.4>에 등록되었습니다.
   Carol은 TLS 연결을 통해 리디렉션 응답을받습니다.
   빌 록시 대리인과 함께 설립되었으므로 그녀는
   연락처.

   그런 다음 Carol은 지정된 TCP 연결을 설정해야합니다 (SHOULD).
   주소를 포함하고 요청 URI를 가진 새로운 INVITE를 보낸다.
   수신 된 연락처 주소 (본문의 서명을 다음과 같이 다시 계산하십시오.
   요청이 준비 됨). Bob이 안전하지 않은 상태에서이 INVITE를받습니다.
   인터페이스를 사용하지만 그의 UA는 검사를하고이 경우에는
   요청의 헤더 필드에서부터 로컬에서 일치합니다.
   서명 된 인증서로 캐시 된 인증서
   INVITE의 본문입니다. 그는 비슷한 방식으로 응답합니다.
   그 자신을 캐롤에게 보내면 안전한 대화가 시작됩니다.

      때로는 관리 도메인의 방화벽이나 NAT가
      UA에 직접 TCP 연결을 설정하지 못하게합니다. 에서
      이러한 경우 프록시 서버는 잠재적으로 요청을 중계 할 수 있습니다.
      신뢰 관계가없는 방식으로 UA에 전달 (예 :
      기존 TLS 연결을 거부하고 요청 전달
      일반 텍스트 TCP를 통해).

26.3.2.4 DoS 보호

   DoS (서비스 거부) 공격의 위험을 최소화하기 위해
   이러한 보안 솔루션을 사용하는 아키텍처, 구현자는
   다음 지침을 유의하십시오.

   SIP 프록시 서버가 작동중인 호스트가 라우팅 가능할 때
   공용 인터넷에서, 그것은 행정부에 배치되어야한다.
   방어적인 운영 정책이있는 도메인 (차단 소스 - 라우팅 됨
   트래픽, 바람직하게는 핑 트래픽을 필터링). TLS와 IPSec 모두
   또한 관리 도메인의 가장자리에 요새 호스트를 사용합니다.
   보안 모임에 참여하여 안전한 모임
   터널과 소켓. 이 요새 주인은 또한
   DoS (서비스 거부) 공격으로 인해
   관리 도메인은 불필요한 메시징으로 인해 방해받지 않습니다.



Rosenberg, et. al. 표준 트랙 [Page 246]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   어떤 보안 솔루션이 배포 되더라도 메시지가 넘쳐 흐릅니다.
   프록시 서버로 보내면 프록시 서버 리소스가 잠길 수 있고
   원하는 트래픽이 대상에 도달하는 것을 방지합니다. 이있다
   SIP 트랜잭션 처리와 관련된 계산 비용
   프록시 서버, 그 비용은 상태 보존 형 프록시보다 큽니다.
   서버가 아닌 상태 프록시 서버입니다. 따라서 상태 저장
   프록시는 상태 비 저장 프록시보다 플러딩에 더 취약합니다.
   서버.

   UA와 프록시 서버는 의심스러운 요청에
   단일 401 (인증되지 않음) 또는 407 (프록시 인증
   필수), 정상적인 응답 재전송 알고리즘을 거부하고,
   따라서 인증되지 않은 요청에 대해 무국적으로 작동합니다.

      401 (권한없는) 또는 407 (프록시 인증) 재전송
      필수) 상태 응답은 공격자의 문제를 증폭시킵니다.
      위장 된 헤더 필드 값 (예 : Via)을 사용하여
      제 3 자에 대한 트래픽.

   요약하면 다음을 통한 프록시 서버의 상호 인증
   TLS와 같은 메커니즘은 악성 프로그램의 잠재력을 크게 줄입니다.
   할 수있는 위조 된 요청이나 응답을 소개하는 중개자
   서비스 거부. 이것은 공평하게 공격자가
   무해한 SIP 노드를 증폭 에이전트로 만듭니다.

26.4 제한 사항

   이러한 보안 메커니즘이 사려 깊게 적용될 때
   방식으로 많은 위협을 저지 할 수 있습니다. 범위에 제한이 있습니다.
   구현 자와 네트워크가 이해해야하는 메커니즘
   연산자.

26.4.1 HTTP 다이제스트

   SIP에서 HTTP 다이제스트를 사용하는 주요 제한 사항 중 하나는
   다이제스트의 무결성 메커니즘이 SIP에서 제대로 작동하지 않습니다.
   특히 Request-URI와 메소드를 보호합니다
   UA가 사용하는 헤더 필드가 아닌
   가능성이 높습니다.

   RFC 2617에 설명 된 기존 재생 방지 메커니즘
   SIP에는 몇 가지 제한 사항이 있습니다. 다음 번 nonce 메커니즘
   예를 들어, 파이프 라인 요청을 지원하지 않습니다. 논스 카운트
   메커니즘은 재생 방지를 위해 사용해야합니다.

   HTTP 다이제스트의 또 다른 한계는 영역의 범위입니다. 다이제스트
   사용자가 리소스에 자신을 인증하려고 할 때 유용합니다.
   그들은 서비스와 같은 기존의 연관성을 가지고있다.



Rosenberg, et. al. 표준 트랙 [Page 247]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   사용자가 고객 인 공급자 (이것은 매우 일반적입니다.)
   따라서 다이제스트는 매우 유용한 기능을 제공합니다. 으로
   대조적으로, TLS의 범위는 도메인 간 또는 다중 영역입니다.
   인증서는 전 세계적으로 검증 될 수 있으므로 UA는
   기존의 연관성없이 서버를 인증하십시오.

26.4.2 S / MIME

   S / MIME 메커니즘의 가장 큰 결함은 부족한 부분입니다.
   최종 사용자를위한 널리 사용되는 공개 키 인프라 자기 -
   서명 된 인증서 (또는 하나의 인증서로 검증 할 수없는 인증서)
   다이얼로그의 참가자들)이 사용되는 경우, SIP 기반 키 교환
   메커니즘은 23.2 절에 설명 된 man-in-the-
   공격자가 잠재적으로 검사 할 수있는 중간 공격
   S / MIME 본문을 수정하십시오. 공격자는 첫 번째 요격을 가로 챌 필요가있다.
   대화 상자에서 두 당사자 간의 키 교환을
   요청 및 응답의 기존 CMS 분리 시그니처 및
   인증서가 포함 된 다른 CMS로 분리 된 서명 삽입
   공격자가 제공 한 것입니다 (하지만
   적절한 주소 기록). 각 당사자는 그들이 교환했다고 생각할 것입니다.
   사실, 각각의 공개 키가
   공격자.

   공격자는이 기능을 활용할 수 있다는 점에 유의해야합니다.
   두 당사자 간의 첫 번째 키 교환시 취약성 -
   이후의 경우에는 키의 변경이 눈에 띄게됩니다
   UA에. 공격자가 계속 침입하기가 어려울 수도 있습니다.
   시간이 지남에 따라 양 당사자 간의 모든 향후 대화 상자의 경로 (
   잠재적으로 일, 주 또는 년 패스).

   SSH는 첫 번째 공격에 동일한 중간자 공격을 받기 쉽습니다.
   열쇠 교환; 그러나 널리 인정되는 SSH
   완벽하지는 않습니다. 연결 보안을 향상시킵니다. 사용법
   키 지문은 SIP와 마찬가지로 일부 도움을 줄 수 있습니다.
   SSH에 대한 않습니다. 예를 들어, 두 당사자가 SIP를 사용하여
   음성 통신 세션, 각각의 지문을 읽을 수
   그들이 상대방으로부터받은 열쇠는 비교 될 수 있습니다.
   원래. 확실히 man-in-
   중간보다 참가자의 목소리를 에뮬레이트하는 중간
   시그널링 (클리퍼 칩 기반
   보안 전화).

   S / MIME 메커니즘을 통해 UA는
   그들이 목적지 주소에 대한 인증서를 가지고 있다면 프리앰블 (preamble)
   열쇠 고리에 기록을 남긴다. 그러나,
   레코드 주소에 대해 등록 된 특정 장치는 보유하지 않습니다.
   이전에 기기의 인증서에 사용 된 인증서
   따라서 현재 사용자를 처리 할 수 ​​없습니다.



Rosenberg, et. al. 표준 트랙 [Page 248]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   암호화 된 요청을 올바르게 처리하면 피할 수없는 오류가 발생할 수 있습니다.
   신호. 특히 암호화 된 요청이
   포크.

   S / MIME과 관련된 키는 다음과 관련된 경우에 가장 유용합니다.
   장치 (UA)가 아닌 특정 사용자 (레코드 주소).
   사용자가 기기 간을 이동할 때 이동이 어려울 수 있습니다.
   UA간에 개인 키를 안전하게; 그러한 키를 얻는 방법
   장치는이 문서의 범위를 벗어납니다.

   S / MIME 메커니즘을 사용하는 또 다른 어려 운 어려움은
   매우 큰 메시지가 발생할 수 있습니다. 특히 SIP 터널링
   메커니즘이 사용된다. 그 이유는
   TCP가 전송 프로토콜로 사용될 것을 권고한다.
   S / MIME 터널링이 사용됩니다.

26.4.3 TLS

   TLS에 대해 가장 흔하게 제기되는 우려는
   UDP; TLS에는 연결 지향 기본 전송이 필요합니다.
   프로토콜로서,이 문서의 목적 상 TCP를 의미합니다.

   또한 로컬 아웃 바운드 프록시 서버 및 / 또는
   많은 장기간 TLS 연결을 동시에 유지 관리하는 등록 업체
   수많은 UA와 이는 몇 가지 유효한 확장 성 문제를 야기하며,
   특히 집약적 인 암호 세트에 적합합니다. 중복성 유지
   오래 지속되는 TLS 연결, 특히 UA가 전적으로 TLS 연결 인 경우
   그들의 설립에 대한 책임은 또한 성 가실 수 있습니다.

   TLS를 사용하면 SIP 엔터티 만 서버를 인증 할 수 있습니다.
   인접하다; TLS는 엄격한 홉 바이 홉 보안을 제공합니다. TLS,
   이 문서에 지정된 다른 메커니즘도 클라이언트가
   직접 TCP를 구성 할 수없는 프록시 서버 인증
   연결.

26.4.4 SIPS URIs

   실제로 요청 경로의 모든 세그먼트에서 TLS를 사용하면
   착신 UAS는 TLS를 통해 도달 할 수 있어야합니다 (아마도 등록
   연락처 주소로 SIPS URI 사용). 이것은 다음을 선호하는 용도입니다.
   SIPS. 그러나 많은 유효한 아키텍처는 TLS를 사용하여
   요청 경로이지만, 최종 홉을위한 다른 메커니즘에 의존한다.
   예를 들어 UAS로 따라서 SIPS는 TLS 사용을 보장 할 수 없습니다.
   진정한 엔드 투 엔드가 될 것입니다. 많은 UA가 받아들이지 않기 때문에
   들어오는 TLS 연결, 심지어 TLS를 지원하는 UA가
   영구 TLS 연결을 유지하는 데 필요합니다.
   TLS를 통해 요청을 수신하려면 위의 TLS 제한 섹션을 참조하십시오.
   UAS로



Rosenberg, et. al. 표준 트랙 [Page 249]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   위치 서비스는 SIP 서비스에 대한 SIPS 바인딩을 제공 할 필요가 없습니다.
   SIPS 요청 URI. 위치 서비스는 일반적으로 채워지지만
   사용자 등록 (섹션 10.2.1에서 설명), 다양한 기타
   프로토콜 및 인터페이스가 연락처 주소를 제공 할 수 있습니다.
   AOR의 경우 이러한 도구는 SIPS URI를 SIP URI에 매핑 할 수 있습니다.
   적당한. 바인딩에 대해 쿼리하면 위치 서비스에서
   그 연락처를 받았는지 여부에 관계없이 연락처 주소
   SIPS 요청 URI로 요청. 리디렉션 서버가 액세스중인 경우
   위치 서비스를 처리하는 엔티티에 달려 있습니다.
   리디렉션의 헤더 필드에서 컨택의 적합성을 결정합니다.
   연락처 주소.

   모든 요청 세그먼트에 대해 TLS가 사용되는지 확인합니다.
   대상 도메인은 다소 복잡합니다. 가능하다.
   암호로 인증 된 프록시 서버는
   규정을 준수하지 않거나 손상된 경우 전달을 무시할 수 있습니다.
   SIPS와 관련된 규칙 (및 일반 전달 규칙
   섹션 16.6). 그러한 악의적 인 중개자는 예를 들어,
   SIPS URI에서 요청을 SIP URI로 재 지정하려는 시도
   다운 그레이드 보안.

   또는 중개자가 요청을 합법적으로 재 대상화 할 수 있습니다.
   SIP에서 SIPS URI로 변환합니다. Request-URI를 가진 요청의 수신자
   따라서 SIPS URI 스키마를 사용하므로
   전체 요청 경로에 대해 SIPS가 사용 된 요청 -URI 만
   (클라이언트부터).

   이러한 우려를 해소하기 위해
   Request-URI에 SIP 또는 SIPS URI가 포함 된 요청
   헤더 필드 값에 SIPS URI가 포함되어 있는지 확인합니다 (단,
   이 URI가 같으면 보안 침해를 구성하지 않습니다.
   scheme이지만 To 헤더 필드의 URI와 동일하지 않음).
   클라이언트가 Request-URI 및 To 헤더를 채우도록 선택할 수 있지만
   SIPS가이 불일치를 사용할 때 요청의 다른 필드
   가능한 보안 위반으로 해석 될 수 있으며
   따라서 요청은 수령인이 거부 할 수 있습니다. 수신자
   이중 확인을 위해 Via 헤더 체인을 검사 할 수도 있습니다
   때까지 TLS가 전체 요청 경로에 사용되었는지 여부
   로컬 관리 도메인에 도달했습니다. S / MIME는
   원래의 UAC를 사용하여
   헤더 필드는 종단 간 (end-to-end)으로 전달된다.

   UAS가 Request-URI의 스키마가
   운송 중에 부적절하게 수정 된 경우, UA는
   잠재적 보안 위반 사용자.






Rosenberg, et. al. 표준 트랙 [쪽 250]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   다운 그레이드 공격을 방지하기위한 또 다른 방법으로
   SIPS 요청 만 수락 할 수있다.
   포트.

   최종 사용자는 의심 할 여지없이 SIPS와
   SIP URI를 포함 할 수 있으며, 자극에 따라 수동으로 편집 할 수 있습니다.
   이는 보안에 도움이되거나 저하 될 수 있습니다. 예를 들어,
   공격자가 DNS 캐시를 손상시키고 가짜 레코드 세트를 삽입하여
   프록시 서버에 대한 모든 SIPS 레코드를 효과적으로 제거한 다음
   이 프록시 서버를 통과하는 SIPS 요청이 실패 할 수 있습니다. 사용자,
   그러나 SIPS AOR에 대한 반복 호출이 실패하고
   일부 장치에서 SIPS에서 SIP로 스키마를 수동으로 변환 할 수 있습니까?
   다시 시도하십시오. 물론 이것에 대한 몇 가지 안전 장치가 있습니다 (
   목적지 UA는 정말로 편집증 적이므로 모든 비 SIPS를 거절 할 수 있습니다
   요청)하지만 주목할 가치가있는 한계입니다. 밝은면에서,
   사용자는 'SIPS'가 유효한 경우에도 유효하다고 신분을 부여 할 수 있습니다.
   SIP URI로만 표시됩니다.

26.5 개인 정보

   SIP 메시지에는 해당 메시지에 대한 중요한 정보가
   보낸 사람 - 말하는 것뿐만 아니라 누구와
   의사 소통 할 때, 그리고 얼마나 오랫동안 그리고 언제 어디에서
   그들은 세션에 참여한다. 많은 응용 프로그램과 사용자
   개인 정보의 종류가
   파티는 그것을 알 필요가 없습니다.

   직접적인 방법으로는 비공식적 인
   정보가 공개 될 수 있습니다. 사용자 또는 서비스가
   그 사람의 이름에서 추측 할 수있는 주소로 도달 할 수 있어야하며
   조직 제휴 (대부분의 주소 -
   기록)을 유지함으로써 프라이버시를 보장하는 전통적인 방법입니다.
   비공개 "전화 번호"가 유출되었습니다. 사용자 위치 서비스는
   다음과 같은 방법으로 세션 초대장을받는 사람의 개인 정보를 침해하는 행위
   호출자에게 자신의 구체적인 위치를 밝히는 것; 구현
   결과적으로 사용자 단위로 무엇을 제한 할 수 있어야한다.
   종류 및 위치 정보는 특정 종류로 제공됩니다.
   발신자 클래스. 이것은 문제의 전체 클래스입니다.
   진행중인 SIP 작업에서 더 많이 연구 될 것으로 예상됩니다.

   경우에 따라 사용자가 개인 정보를 숨길 수 있습니다.
   헤더 필드는 ID를 전달합니다. 이것은
   요청의 발신자를 나타내는 보낸 사람 및 관련 헤더,
   하지만 또한 To - 최종에게 전달하는 것이 적절하지 않을 수도 있습니다.
   대상 고속 다이얼링 닉네임 또는 확장되지 않은 식별자
   그 중 하나는
   요청 - URI는 요청에 따라 라우팅되지만 변경되지는 않습니다.




Rosenberg, et. al. 표준 트랙
     [Page 251]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   두 필드가 처음에 동일하면 머리글 필드. 따라서
   To 헤더 필드를 생성하기 위해 개인 정보 보호상의 이유로
   Request-URI와 다릅니다.

27 IANA 고려 사항

   모든 메소드 이름, 헤더 필드 이름, 상태 코드 및 옵션 태그
   SIP 응용 프로그램에 사용되는 IANA는
   RFC의 IANA 고려 사항 섹션의 지침

   이 명세는 IANA에게 4 개의 새로운 서브 -
   http://www.iana.org/assignments/sip-parameters에있는 레지스트리 :
   옵션 태그, 경고 코드 (경고 코드), 메소드 및 응답 코드,
   이미 존재하는 헤더 필드의 서브 레지스트리에 추가된다.
   그곳에.

27.1 옵션 태그

   이 명세는 아래의 옵션 태그 서브 레지스트리를 확립한다.
   http://www.iana.org/assignments/sip-parameters.

   옵션 태그는 헤더 필드 (Require, Supported,
   SIP 호환성을 지원하기 위해 Proxy-Require 및 Unsupported
   확장을위한 메커니즘 (19.2 절). 옵션 태그 자체는
   특정 SIP 옵션과 연결된 문자열 (즉,
   신장). SIP 끝점에 대한 옵션을 식별합니다.

   옵션 태그는 IANA에 게시 될 때 IANA에 등록됩니다.
   표준은 RFC를 추적합니다. RFC의 IANA 고려 사항 섹션
   다음 정보를 포함해야합니다. IANA
   레지스트리와 함께 발행물의 RFC 번호.

      o 옵션 태그의 이름. 이름은 어떤 길이라도 될 수 있지만
         20 자 이하 여야합니다. 이름은 반드시
         영숫자 (섹션 25) 문자로만 구성됩니다.

      o 확장을 설명하는 설명 텍스트.

27.2 경고 코드

   이 명세는 Warn-codes sub-registry를
   http://www.iana.org/assignments/sip-parameters
   20.43 절에 나열된 경고 코드가있는 추가
   경고 코드는 RFC 게시에 의해 등록됩니다.







Rosenberg, et. al. 표준 트랙 [Page 252]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   warn-codes 테이블의 설명 텍스트는 다음과 같습니다.

   경고 코드는 다음의 상태 코드를 보완하는 정보를 제공합니다.
   트랜잭션 실패시 SIP 응답 메시지
   세션 설명 프로토콜 (SDP) (RFC 2327 [1]) 문제로부터.

   "경고 코드"는 세 자리 숫자로 구성됩니다. "3"의 첫번째 자릿수
   SIP 관련 경고를 나타냅니다. 미래의 사양까지
   3xx 이외의 경고 코드의 사용을 설명하고, 3xx 경고 코드 만
   등록되어 있어야합니다.

   경고 300 ~ 329는 다음과 같은 문제점을 나타 내기 위해 예약되어 있습니다.
   330 ~ 339 세션 ​​설명의 키워드는 경고입니다.
   세션에서 요청 된 기본 네트워크 서비스와 관련된
   370 ~ 379는 정량적 QoS와 관련된 경고입니다.
   세션 설명에 요청 된 매개 변수 및 390 - 399
   위의 중 하나에 해당하지 않는 기타 경고입니다.
   카테고리.

27.3 헤더 필드 이름

   이것은 헤더 하위 레지스트리에 대한 IANA 지침을 폐지합니다.
   http://www.iana.org/assignments/sip-parameters에서 확인할 수 있습니다.

   다음 정보는 RFC 게시에 제공되어야합니다.
   새로운 헤더 필드 명을 등록하기 위해서 :

      o 헤더가 등록 된 RFC 번호.

      o 등록되는 헤더 필드의 이름.

      해당 헤더 필드에 대한 압축 된 양식 버전 (있는 경우)
         한정된;

   일반적으로 널리 사용되는 일부 헤더 필드에는 한 문자
   콤팩트 폼 (7.3.3 절). 간략한 양식은 할당 만 가능합니다.
   SIP 작업 그룹 검토 후 RFC 출판.

27.4 방법 및 응답 코드

   이 명세는 Method and Response-Code 서브 -
   http://www.iana.org/assignments/sip-parameters 및
   그들의 인구를 다음과 같이 시작한다. 초기의 Methods 테이블은 다음과 같습니다.








Rosenberg, et. al. 표준 트랙 [쪽 253]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


         INVITE [RFC3261]
         ACK [RFC3261]
         바이 [RFC3261]
         CANCEL [RFC3261]
         등록 [RFC3261]
         옵션 [RFC3261]
         정보 [RFC2976]

   응답 코드 테이블은 처음에 섹션 21에서 채워집니다.
   정보, 성공, 리디렉션, 클라이언트 - 오류,
   서버 오류 및 전역 오류. 테이블에 다음이 있습니다.
   체재:

      유형 (예 : 정보)
            번호 기본 이유 구문 [RFC3261]

   다음 정보는 RFC 게시에 제공되어야합니다.
   새로운 응답 코드 또는 메소드를 등록하려면 다음을 수행하십시오.

      o 메소드 또는 응답 코드가있는 RFC 번호
         등기;

      o 응답 코드 또는 메소드 이름의 번호
         등기;

      o 해당 응답 코드의 기본 이유 구. if
         응용할 수 있는;

27.5 "message / sip"MIME 유형.

   이 문서는 "message / sip"MIME 미디어 유형을 등록하여
   SIP 메시지를 SIP 내의 본문으로 터널링 할 수 있습니다.
   종단 간 보안 목적. 이 미디어 유형은
   다음 정보 :

      미디어 유형 이름 : 메시지
      미디어 하위 유형 이름 : sip
      필수 매개 변수 : 없음

      선택적 매개 변수 : version
         버전 : 첨부 된 메시지의 SIP 버전 번호 (예 :
         "2.0"). 존재하지 않으면 버전은 "2.0"으로 기본 설정됩니다.
      인코딩 방식 : SIP 메시지는 8 비트 헤더로 구성됩니다.
         선택적으로 이진 MIME 데이터 객체가 뒤 따른다. 이와 같이, SIP
         메시지는 2 진수로 처리되어야합니다. 정상적인 상황에서
         SIP 메시지는 바이너리 가능 전송을 통해 전송됩니다.
         특수 인코딩이 필요합니다.




Rosenberg, et. al. 표준 트랙 [쪽 254]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


      보안 고려 사항 : 아래 참조
         동기 부여 및 보안 메커니즘으로서의이 사용 예
         S / MIME과 함께 23.4에 나와 있습니다.

27.6 새로운 내용 처분 매개 변수 등록

   이 문서는 또한 4 개의 새로운 Content-Disposition 헤더
   "처분 유형": 경보, 아이콘, 세션 및 렌더링. 저자
   이 값들을 IANA 레지스트리에 기록하도록 요청하십시오.
   내용 - 처분.

   이러한 "처분 유형"에 대한 설명 (동기 부여 및
   예는 섹션 20.11에 나와 있습니다.

   IANA 레지스트리에 적합한 간단한 설명은 다음과 같습니다.

      시체에 사용자에게 경고하는 사용자 지정 신호음임을 경고합니다.
      icon 본문이 사용자에게 아이콘으로 표시됩니다.
      본문을 렌더링하여 사용자에게 표시해야합니다.
      세션에서 본문은 통신 세션을 설명합니다.
                예 : RFC 2327 SDP 본문

RFC 2543의 변경 사항

   이 RFC는 RFC 2543을 수정합니다.
   RFC 2543. 여기에 설명 된 변경 사항은
   RFC 2543 및 RFC에 상세히 설명되지 않은 시나리오에 대한 정보 제공
   이 프로토콜은보다 깔끔하게 계층화되어 제공됩니다.
   여기 모델.

   우리는 차이를 기능적 행동으로 나눕니다.
   RFC 2543의 실질적인 변화.
   상호 운용성 또는 경우에 따라 올바른 작동 및 기능적
   RFC 2543과 다르지만 잠재적 인 출처가 아닌 행동
   상호 운용성 문제. 무수히 많았다.
   여기에 설명되어 있지 않은 명확한 설명도 포함됩니다.

28.1 주요 기능 변화

   o UAC가 전화 받기 전에 전화를 끊으려는 경우,
      CANCEL을 보냅니다. 원래 INVITE가 여전히 2xx를 반환하면
      그런 다음 UAC가 BYE를 보냅니다. BYE는 기존 통화 레그에서만 보낼 수 있습니다.
      (현재이 RFC에서 대화 상자라고 함) 반면,
      RFC 2543의 시간.

   o SIP BNF가 RFC 2234를 준수하도록 변환되었습니다.





Rosenberg, et. al. 표준 트랙 [255 페이지]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   o SIP URL BNF가보다 일반적으로 만들어 졌으므로
      사용자 부분의 문자. 또한 비교 규칙은
      주로 대소 문자를 구별하지 않도록 단순화하고 세부 처리
      매개 변수가있을 때의 비교가 설명되었다. 그만큼
      가장 중요한 변경 사항은 매개 변수가있는 URI가
      기본값은 해당 매개 변수가없는 URI와 일치하지 않습니다.

   o 숨어서 제거되었습니다. 신뢰할 수있는 문제가있었습니다.
      다음 홉에서 난독 처리를 수행합니다. 대신 Via
      상태 저장에서 로컬 구현 선택으로 숨김을 수행 할 수 있습니다.
      프록시이므로 더 이상 문서화되지 않습니다.

   o RFC 2543에서 CANCEL 및 INVITE 트랜잭션이 혼합되었습니다.
      그들은 지금 분리되어 있습니다. 사용자가 INVITE를 보낸 다음
      취소, INVITE 트랜잭션은 여전히 ​​정상적으로 종료됩니다. UAS
      487과 함께 원래 INVITE 요청에 응답해야합니다.
      응답.

   o 마찬가지로 CANCEL 및 BYE 트랜잭션이 혼합되었습니다. RFC 2543
      BYE가있을 때 UAS가 INVITE에 대한 응답을 보내지 못하게했습니다.
      받았습니다. 그건 여기서 허용되지 않습니다. 원래 INVITE에는
      응답.

   o RFC 2543에서, UA는 UDP 만 지원해야했습니다. 이 RFC에서는 UA
      UDP와 TCP를 모두 지원해야합니다.

   o RFC 2543에서, 포크 프록시는 한 번의 챌린지를 거절했다.
      여러 가지 문제가 발생할 경우 다운 스트림 요소. 이
      RFC, 프록시는 모든 문제를 수집하여 배치해야합니다.
      전달 된 응답으로

   다이제스트 자격 증명에서 URI는 따옴표로 묶어야합니다. 이것은 불분명하다.
      RFC 2617과 RFC 2069에서 모두 일치하지 않습니다.

   o SDP 처리가 별도의 사양으로 분리되었습니다.
      [13],보다 공식적으로 오퍼 / 대답 교환
      프로세스는 SIP를 통해 효과적으로 터널링됩니다. SDP 허용됨
      기본 SIP 구현을 위해 INVITE / 200 또는 200 / ACK; RFC
      2543은 INVITE, 200 및 ACK에서이를 사용할 수있는 능력을 암시합니다.
      단일 트랜잭션이지만 이는 잘 지정되지 않았습니다. 더 복잡한
      SDP 사용은 확장에 허용됩니다.










Rosenberg, et. al. 표준 트랙 [쪽 256]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   o IPv6 및 Via 헤더 필드에 IPv6에 대한 완벽한 지원을 추가했습니다.
      Via에서 IPv6을 지원하려면 헤더 필드
      매개 변수는 대괄호와 콜론 문자를 허용합니다. 이들
      문자는 이전에 허용되지 않았습니다. 이론적으로 이것은
      이전 구현에서 interop 문제가 발생합니다. 그러나 우리는
      대부분의 구현은 비 - 제어를 수용한다는 것을 관찰했다
      이 매개 변수의 ASCII 문자.

   o 이제 DNS SRV 절차가 별도의 사양으로 문서화됩니다.
      [4]. 이 절차에서는 SRV 및 NAPTR 리소스 레코드와
      에서 설명한대로 더 이상 SRV 레코드의 데이터를 결합하지 않습니다.
      RFC 2543.

   o 루프 감지가 선택적으로 이루어졌으며 필수 항목으로 대체되었습니다.
      Max-Forwards의 사용. RFC 2543의 루프 감지 절차
      "나선"을 오류로보고하는 심각한 버그가있었습니다.
      그것이 아니었을 때의 상태. 선택적 루프 감지 절차
      여기에 더 완전하고 정확하게 지정되어 있습니다.

   o 태그의 사용은 이제 필수적입니다 (RFC 2543에서 선택 사항 임).
      대화 상자의 기본 구성 요소가되었습니다.
      신분증.

   지원되는 헤더 필드를 추가하여 클라이언트가
      어떤 확장 기능이 서버에 지원되며, 확장 기능을 적용 할 수 있습니다.
      응답에 대한 확장 기능을 제공하고
      응답에서 요구하십시오.

   o 여러 헤더에 대한 확장 매개 변수가 BNF에서 누락되었습니다.
      필드가 추가되었습니다.

   Route와 Record-Route 구조의 취급은 매우 쉬웠다.
      RFC 2543에 명시되어 있지 않으며 올바른 접근 방식도 아닙니다. 이것
      이 명세서에서 실질적으로 수정되었다.
      대폭 단순 해짐), 이것은 틀림없이 가장 큰 변화입니다.
      이전 버전과의 호환성은
      초기 요청에 집합이있는 "미리로드 된 경로"를 사용하지 않습니다.
      외부에서 어떤 방법으로 얻은 Route 헤더 필드 값
      Record-Route. 이러한 상황에서 새로운 메커니즘은
      상호 운용 가능.

   o RFC 2543에서 메시지의 줄은 CR, LF,
      또는 CRLF. 이 사양은 CRLF 만 허용합니다.








Rosenberg, et. al. 표준 트랙 [쪽 257]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   CANCEL 및 ACK에서 Route의 사용법은 RFC 2543에서 잘 정의되지 않았습니다.
      이제는 잘 정의되어 있습니다. 요청에 Route 헤더 필드가있는 경우,
      요청에 대한 2xx가 아닌 응답에 대한 CANCEL 또는 ACK는
      동일한 Route 헤더 필드 값을 전달합니다. 2xx 응답에 대한 ACK
      2xx의 Record-Route에서 배운 Route 값을 사용하십시오.
      응답.

   o RFC 2543은 단일 UDP 패킷에서 여러 요청을 허용했습니다. 이
      사용이 제거되었습니다.

   o Expires 헤더 필드와 매개 변수에서 절대 시간 사용
      제거되었습니다. 요소에 상호 운용성 문제가 발생했습니다.
      시간 동기화되지 않았고 흔히 발생합니다. 상대적인
      시간이 대신 사용됩니다.

   o Via 헤더 필드 값의 분기 매개 변수가 이제
      모든 요소를 ​​사용하려면 필수입니다. 이제는
      고유 한 트랜잭션 식별자. 이것은 복잡한 버그 -
      RFC 2543의 트랜잭션 ID 식별 규칙.
      쿠키가 매개 변수 값에 사용되어 이전 매개 변수가
      hop은 매개 변수를 전역 적으로 고유하게 만들고 비교가 실패합니다.
      존재하지 않는 경우 이전 규칙으로 되돌아갑니다. 그러므로,
      상호 운용성이 보장됩니다.

   o RFC 2543에서 TCP 연결의 종료는
      취소하다. 이것은 (그리고 잘못) 구현하는 것이 거의 불가능했습니다.
      프록시 간의 TCP 연결. 이것은 제거되었으므로
      TCP 연결 상태와 SIP 간의 결합이 없음
      처리.

   RFC 2543은 UA가 새로운 것을 시작할 수 있는지 여부에 대해 침묵했다.
      다른 것이 진행중인 동안 동료에게 트랜잭션. 그게 지금이야.
      여기에 지정됩니다. 허용되지 않은 비 요청 인 경우 허용되며 허용되지 않습니다.
      INVITE.

   o PGP가 제거되었습니다. 그것은 충분하게 지정되지 않았고
      보다 완벽한 PGP MIME과 호환됩니다. 그것은
      S / MIME.

   o 종단 간 TLS에 "sips"URI 스키마를 추가했습니다. 이 제도는
      RFC 2543과 역 호환되지 않습니다.
      Request-URI에서 SIPS URI 스킴으로 요청을 수신한다.
      요청을 거부 할 가능성이 있습니다. 이것은 실제로 기능입니다. 그것은 보장한다.
      SIPS URI에 대한 호출은 모든 경로 홉이
      안전하게 지켜야한다.






Rosenberg, et. al. 표준 트랙 [쪽 258]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   추가 보안 기능이 TLS와 함께 추가되었습니다.
      훨씬 더 크고 완전한 보안 고려 사항에 설명되어 있습니다.
      섹션.

   o RFC 2543에서 프록시는 잠정적으로 전달할 필요가 없었습니다
      응답은 101에서 199 업스트림입니다. 이것은 반드시 MUST로 변경되었습니다.
      많은 후속 기능이
      101에서 199 사이의 모든 임시 응답 전달.

   o RFC 2543의 503 응답 코드에 대해서는 거의 언급되지 않았습니다.
      고장이나 과부하를 나타내는 데 상당한 사용이 발견 되었기 때문에
      프록시의 조건. 이것은 다소 특별한 치료가 필요합니다.
      특히, 503을 수신하면
      DNS SRV 조회의 결과에서 다음 요소에 문의하십시오. 또한,
      503 응답은 특정 조건에서 프록시에 의해 업스트림으로 만 전달됩니다
      정황.

   o RFC 2543은 정의되었지만 충분히 지정할 수는 없었습니다.
      서버의 UA 인증. 그것은 삭제되었습니다. 대신,
      RFC 2617의 상호 인증 절차가 허용됩니다.

   o UA는 ACK를 수신 할 때까지 BYE를 보낼 수 없습니다.
      초기 INVITE. 이것은 RFC 2543에서 허용되었지만
      잠재적 경쟁 상태.

   o UA 또는 프록시는 트랜잭션을 가져올 때까지 CANCEL을 보낼 수 없습니다.
      요청에 대한 잠정 응답. 이것은 RFC에서 허용되었습니다.
      2543은 잠재적 인 경쟁 조건으로 이어집니다.

   o 등록에서 action 매개 변수는 더 이상 사용되지 않습니다. 그것은이었다
      유용한 서비스에 충분하지
      응용 프로그램 처리가 프록시에서 적용되었습니다.

   o RFC 2543에는 멀티 캐스트에 대한 여러 가지 특별한 경우가있었습니다. 에 대한
      예를 들어, 특정 응답이 억제되고, 타이머가 조정되었으며,
      등등. 멀티 캐스트는 이제 더 제한된 역할을 수행하며
      프로토콜 동작은 멀티 캐스트의 사용에 영향을받지 않습니다
      유니 캐스트 할 수 있습니다. 그 결과로서의 한계가 문서화되어 있습니다.

   기본 인증이 완전히 제거되었으며 그 사용법
      금지 된.










Rosenberg, et. al. 표준 트랙 [쪽 259]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   o 프록시는 더 이상 6xx를 즉시 수신하지 않습니다.
      대신 보류중인 분기를 즉시 취소합니다. 이렇게하면
      잠재 경쟁 상태로 인해 UAC가 6xx를 얻게됩니다
      그 다음에 2xx가옵니다. 이 경쟁 조건을 제외한 모든 경우에서
      결과는 동일하게됩니다 - 6xx는 업스트림으로 전달됩니다.

   o RFC 2543은 요청 병합의 문제를 언급하지 않았다. 이
      프록시에서 요청을 포킹 한 후 나중에
      요소. 병합 처리는 UA에서만 이루어지며 절차
      첫 번째 요청을 제외한 모든 요청을 거부하기 위해 정의됩니다.

28.2 사소한 기능 변화

   o Alert-Info, Error-Info 및 Call-Info 헤더 필드를 추가했습니다.
      사용자에게 선택적인 콘텐츠 프리젠 테이션.

   o 콘텐츠 언어, 콘텐츠 처리 및 MIME 버전 추가
      헤더 필드.

   o "glare handling"메커니즘을 추가하여
      양 당사자는 서로에게 다시 INVITE를 보냅니다. 그것은 사용
      새로운 491 (Request Pending) 오류 코드

   o 지원을위한 In-Reply-To 및 Reply-To 헤더 필드 추가
      나중에 부재중 전화 또는 메시지를 반환합니다.

   o 유효한 SIP 전송으로 TLS 및 SCTP를 추가했습니다.

   o 오류 처리를위한 다양한 메커니즘이 설명되었습니다.
      전화 중 언제든지; 그것들은 이제 일반적으로 통일된다. 안녕
      종료되도록 전송됩니다.

   o RFC 2543은 TCP를 통한 INVITE 응답의 재전송을 요구했지만
      그것이 정말로 단지 2xx에 필요했다라고 언급했다. 그건 유물 이었어.
      불충분 한 프로토콜 레이어링. 보다 일관성있는 거래로
      여기서 정의 된 레이어는 더 이상 필요하지 않습니다. 2xx 응답 만
      INVITE는 TCP를 통해 재전송됩니다.

   o 클라이언트 및 서버 트랜잭션 시스템은 이제 다음을 기반으로 구동됩니다.
      재전송 횟수보다는 시간 초과. 이렇게하면 상태
      TCP 및 UDP에 맞게 올바르게 지정되어야합니다.

   o Date 헤더 필드는 REGISTER 응답에 사용되어
      사용자 에이전트에서 날짜의 자동 구성을위한 간단한 방법.

   o 레지스트라가 만료 된 등록을 거부 할 수 있도록 허용
      기간이 너무 짧습니다. 정의 된 423 응답 코드와
      최소 - 만료됩니다.



Rosenberg, et. al. 표준 트랙 [쪽 260]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


29 참고 문헌

   [1] Handley, M. 및 V. Jacobson, "SDP : 세션 설명
        프로토콜 ", RFC 2327, 1998 년 4 월.

   [2] Bradner, S., "Indicate Requirement에 RFC에서 사용하기위한 핵심어
        레벨 ", BCP 14, RFC 2119, 1997 년 3 월.

   [3] Resnick, P., "Internet Message Format", RFC 2822, 2001 년 4 월.

   [4] Rosenberg, J. 및 H. Schulzrinne, "SIP : Locating SIP Servers",
        RFC 3263, 2002 년 6 월.

   Berners-Lee, T., Fielding, R. 및 L. Masinter, "Uniform Resource
        식별자 (URI) : 일반 구문 ", RFC 2396, 1998 년 8 월.

   [6] Chown, P., "고급 암호화 표준 (AES) 암호 체계
        Transport Layer Security (TLS) ", RFC 3268, 2002 년 6 월.

   [7] Yergeau, F., "UTF-8, ISO 10646의 변형 형식", RFC
        2279, 1998 년 1 월

   Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L.,
        Leach, P. and T. Berners-Lee, "하이퍼 텍스트 전송 프로토콜 -
        HTTP / 1.1 ", RFC 2616, 1999 년 6 월.

   [9] Vaha-Sipila, A., "전화 통화 URL", RFC 2806, 4 월
        2000.

   [10] Crocker, D. and P. Overell, "Syntax를위한 BNF 증강
        명세 : ABNF ", RFC 2234, 1997 년 11 월.

   [11] Freed, F. 및 N. Borenstein, "다목적 인터넷 메일
        확장 (MIME) 2 부 : 미디어 유형 ", RFC 2046, 11 월
        1996.

   [12] Eastlake, D., Crocker, S. 및 J. Schiller, "Randomness
        보안 권고 사항 ", RFC 1750, 1994 년 12 월.

   [13] Rosenberg, J. and H. Schulzrinne, "다음을 제공하는 제안 / 응답 모델
        SDP ", RFC 3264, 2002 년 6 월.

   [14] Postel, J., "사용자 데이터 그램 프로토콜", STD 6, RFC 768, 8 월
        1980.

   [15] Postel, J., "DoD 표준 전송 제어 프로토콜", RFC
        761, 1980 년 1 월




Rosenberg, et. al. 표준 트랙 [쪽 261]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer,
        H., Taylor, T., Rytina, I., Kalla, M., Zhang, L. 및 V. Paxson,
        "스트림 제어 전송 프로토콜", RFC 2960, 2000 년 10 월.

   [17] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
        Leach, P., Luotonen, A. 및 L. Stewart, "HTTP 인증 :
        기본 및 다이제스트 액세스 인증 ", RFC 2617, 1999 년 6 월.

   [18] Troost, R., Dorner, S. 및 K. Moore, "Communicating Presentation
        인터넷 메시지의 정보 : 내용 처리 헤더
        필드 ", RFC 2183, 1997 년 8 월.

   Zimmerer, E., Peterson, J., Vemuri, A., Ong, L., Audet, F.,
        Watson, M. 및 M. Zonoun, "ISUP 및 QSIG 용 MIME 미디어 유형
        객체 ", RFC 3204, 2001 년 12 월.

   [20] Braden, R., "인터넷 호스트 요구 사항 - 응용 프로그램 및
        지원 ", STD 3, RFC 1123, 1989 년 10 월.

   [21] Alvestrand, H., "문자 집합과 언어에 대한 IETF 정책",
        BCP 18, RFC 2277, 1998 년 1 월.

   [22] Galvin, J., Murphy, S., Crocker, S. 및 N. Freed, "보안
        MIME 용 Multipart : Multipart / Signed and Multipart / Encrypted ",
        RFC 1847, 1995 년 10 월.

   [23] Housley, R., "Cryptographic Message Syntax", RFC 2630, June
        1999.

   [24] Ramsdell B., "S / MIME 버전 3 메시지 사양", RFC 2633,
        1999 년 6 월

   [25] Dierks, T. 및 C. Allen, "TLS 프로토콜 버전 1.0", RFC
        2246, 1999 년 1 월

   [26] Kent, S. 및 R. Atkinson, "보안 아키텍처
        인터넷 프로토콜 ", RFC 2401, 1998 년 11 월.

30 참고 문헌

   [27] R. Pandya, "신흥 모바일 및 개인 통신 시스템"
        IEEE 통신 잡지, Vol. 33, pp. 44--52, 1995 년 6 월.

   [28] Schulzrinne, H., Casner, S., Frederick, R. 및 V. Jacobson,
        "RTP : 실시간 응용 프로그램을위한 전송 프로토콜", RFC
        1889, 1996 년 1 월





Rosenberg, et. al. 표준 트랙 [쪽 262]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   [29] Schulzrinne, H., Rao, R. 및 R. Lanphier, "실시간 스트리밍
        프로토콜 (RTSP) ", RFC 2326, 1998 년 4 월.

   Cuervo, F., Greene, N., Rayhan, A., Huitema, C., Rosen, B. 및
        J. Segers, "Megaco Protocol Version 1.0", RFC 3015, November
        2000.

   [31] Handley, M., Schulzrinne, H., Schooler, E. 및 J. Rosenberg,
        "SIP : 세션 개시 프로토콜", RFC 2543, 1999 년 3 월.

   [32] Hoffman, P., Masinter, L. 및 J. Zawinski, "mailto URL
        scheme ", RFC 2368, 1998 년 7 월.

   E. M. Schooler, "멀티 캐스트 사용자 디렉토리 서비스
        동기 랑데뷰 "석사 학위 논문 CS-TR-96-18, 부서
        컴퓨터 과학, 캘리포니아 공과 대학,
        파사 데나, 캘리포니아, 1996 년 8 월

   [34] Donovan, S., "SIP INFO Method", RFC 2976, 2000 년 10 월.

   [35] Rivest, R., "MD5 Message-Digest Algorithm", RFC 1321, April
        1992.

   [36] Dawson, F. 및 T. Howes, "vCard MIME 디렉토리 프로필", RFC
        2426, 1998 년 9 월.

   [37] Good, G., "LDAP 데이터 교환 형식 (LDIF) - 기술
        사양 ", RFC 2849, 2000 년 6 월.

   [38] Palme, J., "Common Internet Message Headers", RFC 2076,
        1997 년 2 월

   Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,
        Luotonen, A., Sink, E. 및 L. Stewart, "HTTP 확장 기능 :
        다이제스트 액세스 인증 ", RFC 2069, 1997 년 1 월.

   Johnston, A., Donovan, S., Sparks, R., Cunningham, C., Willis,
        D., Rosenberg, J., Summers, K. 및 H. Schulzrinne, "SIP Call
        Flow Examples ", 진행중인 작업.

   [41] E. M. Schooler, "사례 연구 :
        패킷 교환식 전화 회의 시스템 ", Journal of
        인터 네트워킹 : Research and Experience, Vol. 4, pp. 99-120,
        1993 년 6 월 ISI 재판매 시리즈 ISI / RS-93-359.







Rosenberg, et. al. 표준 트랙 [쪽 263]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   [42] H. Schulzrinne, "멀티미디어 서비스를위한 개인 이동성
        인터넷, "인터랙티브 분산 유럽 워크샵
        멀티미디어 시스템 및 서비스 (IDMS), (베를린, 독일), Mar.
        1996.

   [43] Floyd, S., "Congestion Control Principles", RFC 2914, 9 월
        2000.












































Rosenberg, et. al. 표준 트랙 [쪽 264]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


타이머 값 테이블

   표 4는 다양한 타이머의 의미와 기본값을 요약 한 것입니다.
   이 명세서에서 사용된다.

타이머 값 섹션 의미
-------------------------------------------------- --------------------
T1 500ms 기본값 17.1.1.1 RTT 견적
T2 4s 섹션 17.1.2.2 최대 재전송
                                               비 -INVITE 간격
                                               요청 및 초대
                                               응답
T4 5s 섹션 17.1.2.2 최대 지속 시간 a
                                               메시지
                                               네트워크에 남아있다.
타이머 A 초기 T1 섹션 17.1.1.2 INVITE 요청 재전송
                                               간격, UDP 전용
타이머 B 64 * T1 섹션 17.1.1.2 INVITE 트랜잭션
                                               타임 아웃 타이머
타이머 C> 3min 16.6 절 프록시 INVITE 트랜잭션
                           글 머리 기호 11 시간 초과
타이머 D> 32 초 UDP의 경우 17.1.1.2 응답 대기 시간
         TCP / SCTP 재전송을위한 0
타이머 E 초기 T1 섹션 17.1.2.2 비 -INITE 요청
                                               재전송 간격,
                                               UDP 전용
타이머 F 64 * T1 섹션 17.1.2.2 비 -INITE 트랜잭션
                                               타임 아웃 타이머
타이머 G 초기 T1 섹션 17.2.1 INVITE 응답
                                               재전송 간격
타이머 H 64 * T1 섹션 17.2.1 대기 시간
                                               ACK 영수증
타이머 I T4 for UDP 섹션 17.2.1 대기 시간
         TCP / SCTP ACK 재전송의 경우 0
타이머 J 64 * T1 for UDP 섹션 17.2.2 대기 시간
         TCP / SCTP 비 초대 요청의 경우 0
                                               재전송
타이머 K T4 for UDP 섹션 17.1.2.2 대기 시간
         TCP / SCTP 응답 재전송에 대한 0

                   표 4 : 타이머 요약










Rosenberg, et. al. 표준 트랙 [쪽 265]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


감사 인사

   우리는 IETF MMUSIC 및 SIP WG 멤버에게 감사드립니다.
   의견 및 제안. Ofir이 상세한 코멘트를 제공했다.
   Arkin, Brian Bidulock, Jim Buller, Neil Deason, Dave Devanathan,
   Keith Drage, Bill Fenner, Cedric Fluckiger, Yaron Goland, John
   왕성한, Bernie Hoeneisen, Jo Hornsby, Phil Hoffer, Christian Huitema,
   Hisham Khartabil, Jean Jervis, Gadi Karmi, Peter Kjellerstedt, Anders
   크리스텐센, 조나단 레녹스, 게딘 리델, 앨리슨 만킨, 윌리엄
   마샬, Rohan Mahy, 키이스 무어, Vern Paxson, Bob Penfield, Moshe
   J. Sambol, 칩 샤프, 이고르 슬립 친, 에릭 트렘 블레이, 릭
   노동자.

   Brian Rosen은 컴파일 된 BNF를 제공했습니다.

   Jean Mahoney는 기술 지원 서비스를 제공했습니다.

   이 연구는 특히 [41,42]에 기초하고있다.

































Rosenberg, et. al. 표준 트랙 [쪽 266]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


저자 주소

   작성자 주소는 편집자,
   작가, 그리고 RFC 2543의 원저자가 포함됩니다.
   저자는이 문서에 많은 양의 텍스트를 적극적으로 기여했습니다.

   조나단 로젠버그
   다이나믹 소프트
   72 이글 락 애비뉴
   East Hanover, NJ 07936
   미국

   이메일 : jdrosen@dynamicsoft.com


   헤닝 슐린
   컴퓨터 과학과
   컬럼비아 대학
   1214 암스테르담 애비뉴
   뉴욕, 뉴욕 10027
   우리
에이

   이메일 : schulzrinne@cs.columbia.edu


   곤잘로 카마 릴로
   에릭슨
   Advanced Signaling Research Lab.
   FIN-02420 Jorvas
   핀란드

   이메일 : Gonzalo.Camarillo@ericsson.com


   앨런 존스턴
   월드컴
   100 South 4th Street
   세인트루이스, MO 63102
   미국

   이메일 : alan.johnston@wcom.com










Rosenberg, et. al. 표준 트랙 [쪽 267]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


   존 피터슨
   NeuStar, Inc
   1800 Sutter Street, Suite 570
   Concord, CA 94520
   미국

   이메일 : jon.peterson@neustar.com


   로버트 스파크 스
   다이나믹 소프트, Inc.
   5100 테니슨 파크 웨이
   스위트 1200
   텍사스 주 플라 노 (Plano)
   미국

   이메일 : rsparks@dynamicsoft.com


   마크 핸드리
   국제 컴퓨터 과학 연구소
   1947 Centre St, Suite 600
   버클리, 캘리포니아 94704
   미국

   이메일 : mjh@icir.org


   Eve Schooler
   AT & T Labs-Research
   75 윌로우로드
   멘로 파크, 캘리포니아 94025
   미국

   이메일 : schooler@research.att.com
















Rosenberg, et. al. 표준 트랙 [쪽 268]

RFC 3261 SIP : 세션 개시 프로토콜 2002 년 6 월


전체 저작권 선언문

   Copyright (C) The Internet Society (2002). 판권 소유.

   이 문서 및 번역본은 다음 주소로 복사 및 제공 될 수 있습니다.
   다른 사람, 또는 그것에 대해 의견을 말하고 설명하는 파생물
   또는 그 시행을 돕는 것은 준비, 복사, 출판 될 수있다.
   제한없이 전체적으로 또는 부분적으로 배포 됨.
   종류, 단, 위의 저작권 고지와 본 단락은
   그러한 모든 사본 및 파생물에 포함됩니다. 그러나이
   문서 자체는 어떤 방식 으로든 수정 될 수 없습니다.
   저작권 고지 또는 인터넷 사회 또는 기타에 대한 언급
   필요한 경우를 제외하고 인터넷 조직
   인터넷 표준을 개발하는 경우
   인터넷 표준 프로세스에 정의 된 저작권은
   따라하거나, 필요에 따라 다른 언어로 번역해야합니다.
   영어.

   위에 허가 된 제한된 권한은 영구적이며
   인터넷 사회 또는 그 후계자 또는 양도인에 의해 취소 된

   이 문서 및 여기에 포함 된 정보는
   "있는 그대로"의 기반과 인터넷 사회와 인터넷 공학
   TASK FORCE는 모든 명시 적 또는 묵시적 보증을 배제합니다
   본 정보의 사용에 대한 보증
   여기서는 어떠한 권리 나 묵시적 보증을 침해하지 않을 것입니다.
   상품성 또는 특정 목적에의 적합성을 보장하지 않습니다.

승인

   RFC Editor 기능에 대한 자금은 현재
   인터넷 사회.



















Rosenberg, et. al. 표준 트랙 [쪽 269]


